
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gpd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/dl-alexandre/gpd/cmd/gpd/main.go (66.7%)</option>
				
				<option value="file1">github.com/dl-alexandre/gpd/internal/api/client.go (91.5%)</option>
				
				<option value="file2">github.com/dl-alexandre/gpd/internal/auth/auth.go (85.1%)</option>
				
				<option value="file3">github.com/dl-alexandre/gpd/internal/auth/device_code.go (57.8%)</option>
				
				<option value="file4">github.com/dl-alexandre/gpd/internal/auth/token_source.go (84.0%)</option>
				
				<option value="file5">github.com/dl-alexandre/gpd/internal/auth/token_storage.go (88.3%)</option>
				
				<option value="file6">github.com/dl-alexandre/gpd/internal/cli/analytics_commands.go (41.2%)</option>
				
				<option value="file7">github.com/dl-alexandre/gpd/internal/cli/apps_commands.go (13.0%)</option>
				
				<option value="file8">github.com/dl-alexandre/gpd/internal/cli/auth_commands.go (12.3%)</option>
				
				<option value="file9">github.com/dl-alexandre/gpd/internal/cli/cli.go (71.2%)</option>
				
				<option value="file10">github.com/dl-alexandre/gpd/internal/cli/config_commands.go (6.3%)</option>
				
				<option value="file11">github.com/dl-alexandre/gpd/internal/cli/customapp_commands.go (26.1%)</option>
				
				<option value="file12">github.com/dl-alexandre/gpd/internal/cli/edit_commands.go (7.3%)</option>
				
				<option value="file13">github.com/dl-alexandre/gpd/internal/cli/games_commands.go (15.7%)</option>
				
				<option value="file14">github.com/dl-alexandre/gpd/internal/cli/grouping_commands.go (16.7%)</option>
				
				<option value="file15">github.com/dl-alexandre/gpd/internal/cli/integrity_commands.go (44.2%)</option>
				
				<option value="file16">github.com/dl-alexandre/gpd/internal/cli/migrate_commands.go (100.0%)</option>
				
				<option value="file17">github.com/dl-alexandre/gpd/internal/cli/migrate_fastlane.go (4.0%)</option>
				
				<option value="file18">github.com/dl-alexandre/gpd/internal/cli/monetization_baseplans.go (0.0%)</option>
				
				<option value="file19">github.com/dl-alexandre/gpd/internal/cli/monetization_commands.go (55.1%)</option>
				
				<option value="file20">github.com/dl-alexandre/gpd/internal/cli/monetization_offers.go (0.0%)</option>
				
				<option value="file21">github.com/dl-alexandre/gpd/internal/cli/monetization_products.go (0.0%)</option>
				
				<option value="file22">github.com/dl-alexandre/gpd/internal/cli/monetization_subscriptions.go (0.0%)</option>
				
				<option value="file23">github.com/dl-alexandre/gpd/internal/cli/pagination.go (100.0%)</option>
				
				<option value="file24">github.com/dl-alexandre/gpd/internal/cli/permissions_commands.go (15.4%)</option>
				
				<option value="file25">github.com/dl-alexandre/gpd/internal/cli/publish_builds.go (10.1%)</option>
				
				<option value="file26">github.com/dl-alexandre/gpd/internal/cli/publish_commands.go (77.0%)</option>
				
				<option value="file27">github.com/dl-alexandre/gpd/internal/cli/publish_common.go (0.0%)</option>
				
				<option value="file28">github.com/dl-alexandre/gpd/internal/cli/publish_deobfuscation.go (0.0%)</option>
				
				<option value="file29">github.com/dl-alexandre/gpd/internal/cli/publish_images.go (0.0%)</option>
				
				<option value="file30">github.com/dl-alexandre/gpd/internal/cli/publish_listing.go (0.0%)</option>
				
				<option value="file31">github.com/dl-alexandre/gpd/internal/cli/publish_obb.go (0.0%)</option>
				
				<option value="file32">github.com/dl-alexandre/gpd/internal/cli/publish_release.go (0.0%)</option>
				
				<option value="file33">github.com/dl-alexandre/gpd/internal/cli/publish_testers.go (0.0%)</option>
				
				<option value="file34">github.com/dl-alexandre/gpd/internal/cli/publish_upload.go (0.0%)</option>
				
				<option value="file35">github.com/dl-alexandre/gpd/internal/cli/purchases_commands.go (20.4%)</option>
				
				<option value="file36">github.com/dl-alexandre/gpd/internal/cli/recovery_commands.go (13.1%)</option>
				
				<option value="file37">github.com/dl-alexandre/gpd/internal/cli/reviews_commands.go (17.8%)</option>
				
				<option value="file38">github.com/dl-alexandre/gpd/internal/cli/vitals_commands.go (89.5%)</option>
				
				<option value="file39">github.com/dl-alexandre/gpd/internal/cli/vitals_common.go (0.0%)</option>
				
				<option value="file40">github.com/dl-alexandre/gpd/internal/cli/vitals_errors.go (0.0%)</option>
				
				<option value="file41">github.com/dl-alexandre/gpd/internal/cli/vitals_metrics.go (0.0%)</option>
				
				<option value="file42">github.com/dl-alexandre/gpd/internal/config/config.go (85.1%)</option>
				
				<option value="file43">github.com/dl-alexandre/gpd/internal/edits/manager.go (81.1%)</option>
				
				<option value="file44">github.com/dl-alexandre/gpd/internal/errors/auth.go (100.0%)</option>
				
				<option value="file45">github.com/dl-alexandre/gpd/internal/errors/codes.go (100.0%)</option>
				
				<option value="file46">github.com/dl-alexandre/gpd/internal/logging/logger.go (100.0%)</option>
				
				<option value="file47">github.com/dl-alexandre/gpd/internal/migrate/fastlane/parser.go (82.7%)</option>
				
				<option value="file48">github.com/dl-alexandre/gpd/internal/migrate/fastlane/validator.go (81.0%)</option>
				
				<option value="file49">github.com/dl-alexandre/gpd/internal/migrate/limits.go (100.0%)</option>
				
				<option value="file50">github.com/dl-alexandre/gpd/internal/output/result.go (78.7%)</option>
				
				<option value="file51">github.com/dl-alexandre/gpd/internal/storage/storage.go (100.0%)</option>
				
				<option value="file52">github.com/dl-alexandre/gpd/pkg/version/version.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package main provides the entry point for the gpd CLI.
package main

import (
        "os"

        "github.com/dl-alexandre/gpd/internal/cli"
)

func main() <span class="cov0" title="0">{
        os.Exit(run())
}</span>

func run() int <span class="cov8" title="1">{
        app := cli.New()
        return app.Execute()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package api provides the unified API client for Google Play APIs.
package api

import (
        "context"
        crand "crypto/rand"
        "encoding/binary"
        "fmt"
        "net/http"
        "os"
        "strconv"
        "sync"
        "time"

        "golang.org/x/oauth2"
        "google.golang.org/api/androidpublisher/v3"
        "google.golang.org/api/games/v1"
        gamesmanagement "google.golang.org/api/gamesmanagement/v1management"
        "google.golang.org/api/googleapi"
        "google.golang.org/api/option"
        "google.golang.org/api/playcustomapp/v1"
        playdeveloperreporting "google.golang.org/api/playdeveloperreporting/v1beta1"
        "google.golang.org/api/playintegrity/v1"
)

type RetryConfig struct {
        MaxAttempts  int
        InitialDelay time.Duration
        MaxDelay     time.Duration
}

func DefaultRetryConfig() RetryConfig <span class="cov4" title="3">{
        return RetryConfig{
                MaxAttempts:  3,
                InitialDelay: 1 * time.Second,
                MaxDelay:     30 * time.Second,
        }
}</span>

type Client struct {
        httpClient  *http.Client
        timeout     time.Duration
        retryConfig RetryConfig

        publisherOnce sync.Once
        publisherSvc  *androidpublisher.Service
        publisherErr  error

        reportingOnce sync.Once
        reportingSvc  *playdeveloperreporting.Service
        reportingErr  error

        gamesManagementOnce sync.Once
        gamesManagementSvc  *gamesmanagement.Service
        gamesManagementErr  error

        gamesOnce sync.Once
        gamesSvc  *games.Service
        gamesErr  error

        playIntegrityOnce sync.Once
        playIntegritySvc  *playintegrity.Service
        playIntegrityErr  error

        customAppOnce sync.Once
        customAppSvc  *playcustomapp.Service
        customAppErr  error

        semaphore chan struct{}
}

// DefaultConcurrentCalls is the default number of concurrent API calls.
const DefaultConcurrentCalls = 3

// Option configures the API client.
type Option func(*Client)

// WithTimeout sets the HTTP client timeout.
func WithTimeout(d time.Duration) Option <span class="cov1" title="1">{
        return func(c *Client) </span><span class="cov1" title="1">{
                c.timeout = d
        }</span>
}

func WithConcurrentCalls(n int) Option <span class="cov1" title="1">{
        return func(c *Client) </span><span class="cov1" title="1">{
                c.semaphore = make(chan struct{}, n)
        }</span>
}

func WithRetryConfig(cfg RetryConfig) Option <span class="cov1" title="1">{
        return func(c *Client) </span><span class="cov1" title="1">{
                c.retryConfig = cfg
        }</span>
}

func WithMaxRetryAttempts(n int) Option <span class="cov1" title="1">{
        return func(c *Client) </span><span class="cov1" title="1">{
                c.retryConfig.MaxAttempts = n
        }</span>
}

func NewClient(ctx context.Context, tokenSource oauth2.TokenSource, opts ...Option) (*Client, error) <span class="cov3" title="2">{
        c := &amp;Client{
                timeout:     30 * time.Second,
                semaphore:   make(chan struct{}, DefaultConcurrentCalls),
                retryConfig: DefaultRetryConfig(),
        }

        for _, opt := range opts </span><span class="cov6" title="4">{
                opt(c)
        }</span>

        <span class="cov3" title="2">transport := &amp;http.Transport{
                MaxIdleConns:        100,
                MaxIdleConnsPerHost: 10,
                IdleConnTimeout:     90 * time.Second,
        }

        c.httpClient = &amp;http.Client{
                Transport: &amp;oauth2.Transport{
                        Base:   transport,
                        Source: tokenSource,
                },
                Timeout: c.timeout,
        }

        return c, nil</span>
}

// AndroidPublisher returns the Android Publisher API service.
func (c *Client) AndroidPublisher() (*androidpublisher.Service, error) <span class="cov1" title="1">{
        c.publisherOnce.Do(func() </span><span class="cov1" title="1">{
                c.publisherSvc, c.publisherErr = androidpublisher.NewService(
                        context.Background(),
                        option.WithHTTPClient(c.httpClient),
                )
        }</span>)
        <span class="cov1" title="1">return c.publisherSvc, c.publisherErr</span>
}

// PlayReporting returns the Play Developer Reporting API service.
func (c *Client) PlayReporting() (*playdeveloperreporting.Service, error) <span class="cov1" title="1">{
        c.reportingOnce.Do(func() </span><span class="cov1" title="1">{
                c.reportingSvc, c.reportingErr = playdeveloperreporting.NewService(
                        context.Background(),
                        option.WithHTTPClient(c.httpClient),
                )
        }</span>)
        <span class="cov1" title="1">return c.reportingSvc, c.reportingErr</span>
}

// GamesManagement returns the Games Management API service.
func (c *Client) GamesManagement() (*gamesmanagement.Service, error) <span class="cov1" title="1">{
        c.gamesManagementOnce.Do(func() </span><span class="cov1" title="1">{
                c.gamesManagementSvc, c.gamesManagementErr = gamesmanagement.NewService(
                        context.Background(),
                        option.WithHTTPClient(c.httpClient),
                )
        }</span>)
        <span class="cov1" title="1">return c.gamesManagementSvc, c.gamesManagementErr</span>
}

// Games returns the Play Games Services API service.
func (c *Client) Games() (*games.Service, error) <span class="cov0" title="0">{
        c.gamesOnce.Do(func() </span><span class="cov0" title="0">{
                c.gamesSvc, c.gamesErr = games.NewService(
                        context.Background(),
                        option.WithHTTPClient(c.httpClient),
                )
        }</span>)
        <span class="cov0" title="0">return c.gamesSvc, c.gamesErr</span>
}

// PlayIntegrity returns the Play Integrity API service.
func (c *Client) PlayIntegrity() (*playintegrity.Service, error) <span class="cov0" title="0">{
        c.playIntegrityOnce.Do(func() </span><span class="cov0" title="0">{
                c.playIntegritySvc, c.playIntegrityErr = playintegrity.NewService(
                        context.Background(),
                        option.WithHTTPClient(c.httpClient),
                )
        }</span>)
        <span class="cov0" title="0">return c.playIntegritySvc, c.playIntegrityErr</span>
}

// PlayCustomApp returns the Play Custom App Publishing API service.
func (c *Client) PlayCustomApp() (*playcustomapp.Service, error) <span class="cov0" title="0">{
        c.customAppOnce.Do(func() </span><span class="cov0" title="0">{
                c.customAppSvc, c.customAppErr = playcustomapp.NewService(
                        context.Background(),
                        option.WithHTTPClient(c.httpClient),
                )
        }</span>)
        <span class="cov0" title="0">return c.customAppSvc, c.customAppErr</span>
}

// Acquire acquires a semaphore slot for concurrent API calls.
func (c *Client) Acquire(ctx context.Context) error <span class="cov3" title="2">{
        select </span>{
        case c.semaphore &lt;- struct{}{}:<span class="cov1" title="1">
                return nil</span>
        case &lt;-ctx.Done():<span class="cov1" title="1">
                return ctx.Err()</span>
        }
}

// Release releases a semaphore slot.
func (c *Client) Release() <span class="cov1" title="1">{
        &lt;-c.semaphore
}</span>

// AcquireForUpload acquires exclusive access for upload operations.
// Uploads are single-threaded for reliability.
func (c *Client) AcquireForUpload(ctx context.Context) error <span class="cov4" title="3">{
        // Acquire all slots to ensure exclusive access
        for i := 0; i &lt; cap(c.semaphore); i++ </span><span class="cov6" title="5">{
                select </span>{
                case c.semaphore &lt;- struct{}{}:<span class="cov4" title="3"></span>
                case &lt;-ctx.Done():<span class="cov3" title="2">
                        // Release any acquired slots
                        for j := 0; j &lt; i; j++ </span><span class="cov1" title="1">{
                                &lt;-c.semaphore
                        }</span>
                        <span class="cov3" title="2">return ctx.Err()</span>
                }
        }
        <span class="cov1" title="1">return nil</span>
}

func (c *Client) ReleaseForUpload() <span class="cov1" title="1">{
        for i := 0; i &lt; cap(c.semaphore); i++ </span><span class="cov3" title="2">{
                &lt;-c.semaphore
        }</span>
}

func (c *Client) DoWithRetry(ctx context.Context, fn func() error) error <span class="cov6" title="5">{
        var lastErr error

        for attempt := 0; attempt &lt; c.retryConfig.MaxAttempts; attempt++ </span><span class="cov8" title="7">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return ctx.Err()</span>
                default:<span class="cov7" title="6"></span>
                }

                <span class="cov7" title="6">lastErr = fn()
                if lastErr == nil </span><span class="cov1" title="1">{
                        return nil
                }</span>

                <span class="cov6" title="5">if !isRetryableError(lastErr) </span><span class="cov1" title="1">{
                        return lastErr
                }</span>

                <span class="cov6" title="4">if attempt == c.retryConfig.MaxAttempts-1 </span><span class="cov1" title="1">{
                        break</span>
                }

                <span class="cov4" title="3">delay := c.calculateDelay(attempt, lastErr)
                fmt.Fprintf(os.Stderr, "Retrying request (attempt %d/%d) after %v due to: %v\n", attempt+2, c.retryConfig.MaxAttempts, delay, lastErr)
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return ctx.Err()</span>
                case &lt;-time.After(delay):<span class="cov3" title="2"></span>
                }
        }

        <span class="cov1" title="1">return lastErr</span>
}

func isRetryableError(err error) bool <span class="cov8" title="9">{
        if err == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov8" title="8">if apiErr, ok := err.(*googleapi.Error); ok </span><span class="cov8" title="7">{
                if apiErr.Code == http.StatusTooManyRequests </span><span class="cov1" title="1">{
                        return true
                }</span>
                <span class="cov7" title="6">if apiErr.Code &gt;= 500 &amp;&amp; apiErr.Code &lt; 600 </span><span class="cov6" title="5">{
                        return true
                }</span>
        }

        <span class="cov3" title="2">return false</span>
}

func (c *Client) calculateDelay(attempt int, err error) time.Duration <span class="cov6" title="4">{
        return calculateDelayWithConfig(c.retryConfig, attempt, err)
}</span>

func cryptoRandFloat64() float64 <span class="cov8" title="8">{
        var buf [8]byte
        _, err := randRead(buf[:])
        if err != nil </span><span class="cov1" title="1">{
                return 0.5
        }</span>
        <span class="cov8" title="7">return float64(binary.BigEndian.Uint64(buf[:])&amp;(1&lt;&lt;53-1)) / float64(1&lt;&lt;53)</span>
}

var randRead = crand.Read

func calculateDelayWithConfig(cfg RetryConfig, attempt int, err error) time.Duration <span class="cov8" title="9">{
        if retryAfter := extractRetryAfter(err); retryAfter &gt; 0 </span><span class="cov3" title="2">{
                if retryAfter &gt; cfg.MaxDelay </span><span class="cov1" title="1">{
                        return cfg.MaxDelay
                }</span>
                <span class="cov1" title="1">return retryAfter</span>
        }

        <span class="cov8" title="7">shift := attempt
        if shift &gt; 62 </span><span class="cov1" title="1">{
                shift = 62
        }</span>
        <span class="cov8" title="7">delay := cfg.InitialDelay * time.Duration(1&lt;&lt;shift)
        if delay &gt; cfg.MaxDelay </span><span class="cov1" title="1">{
                delay = cfg.MaxDelay
        }</span>

        <span class="cov8" title="7">jitter := time.Duration(cryptoRandFloat64() * float64(delay) * 0.3)
        return delay + jitter</span>
}

func extractRetryAfter(err error) time.Duration <span class="cov10" title="12">{
        apiErr, ok := err.(*googleapi.Error)
        if !ok </span><span class="cov6" title="4">{
                return 0
        }</span>

        <span class="cov8" title="8">for key, values := range apiErr.Header </span><span class="cov6" title="5">{
                if http.CanonicalHeaderKey(key) == "Retry-After" &amp;&amp; len(values) &gt; 0 </span><span class="cov6" title="5">{
                        if seconds, parseErr := strconv.Atoi(values[0]); parseErr == nil </span><span class="cov4" title="3">{
                                return time.Duration(seconds) * time.Second
                        }</span>
                        <span class="cov3" title="2">if t, parseErr := http.ParseTime(values[0]); parseErr == nil </span><span class="cov1" title="1">{
                                return time.Until(t)
                        }</span>
                }
        }
        <span class="cov6" title="4">return 0</span>
}

func (c *Client) RetryConfig() RetryConfig <span class="cov1" title="1">{
        return c.retryConfig
}</span>

var ValidTracks = []string{"internal", "alpha", "beta", "production"}

// IsValidTrack checks if a track name is valid.
func IsValidTrack(track string) bool <span class="cov3" title="2">{
        for _, t := range ValidTracks </span><span class="cov6" title="5">{
                if t == track </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}

// ReleaseStatus represents the status of a release.
type ReleaseStatus string

const (
        StatusDraft      ReleaseStatus = "draft"
        StatusCompleted  ReleaseStatus = "completed"
        StatusHalted     ReleaseStatus = "halted"
        StatusInProgress ReleaseStatus = "inProgress"
)

// IsValidReleaseStatus checks if a release status is valid.
func IsValidReleaseStatus(status string) bool <span class="cov3" title="2">{
        switch ReleaseStatus(status) </span>{
        case StatusDraft, StatusCompleted, StatusHalted, StatusInProgress:<span class="cov1" title="1">
                return true</span>
        default:<span class="cov1" title="1">
                return false</span>
        }
}

// ReleaseConfig holds configuration for creating a release.
type ReleaseConfig struct {
        Track        string
        Name         string
        Status       ReleaseStatus
        VersionCodes []int64
        UserFraction float64
        ReleaseNotes map[string]string // locale -&gt; text
}

// UploadOptions holds options for artifact uploads.
type UploadOptions struct {
        ChunkSize    int64                      // Chunk size for resumable uploads
        ProgressFunc func(current, total int64) // Progress callback
}

// DefaultUploadOptions returns the default upload options.
func DefaultUploadOptions() *UploadOptions <span class="cov1" title="1">{
        return &amp;UploadOptions{
                ChunkSize: 8 * 1024 * 1024, // 8MB chunks
        }
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package auth provides authentication management for gpd.
package auth

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "sync"
        "time"

        "golang.org/x/oauth2"
        "golang.org/x/oauth2/google"

        "github.com/dl-alexandre/gpd/internal/config"
        "github.com/dl-alexandre/gpd/internal/errors"
)

// OAuth scopes required for gpd operations.
const (
        // ScopeAndroidPublisher is the scope for Android Publisher API
        // Used for: publish, reviews, monetization, purchases
        ScopeAndroidPublisher = "https://www.googleapis.com/auth/androidpublisher"

        // ScopePlayReporting is the scope for Play Developer Reporting API
        // Used for: analytics, vitals
        ScopePlayReporting = "https://www.googleapis.com/auth/playdeveloperreporting"

        // ScopeGames is the scope for Play Games Services APIs
        // Used for: games management, play grouping tokens
        ScopeGames = "https://www.googleapis.com/auth/games"

        // ScopePlayIntegrity is the scope for Play Integrity API
        // Used for: integrity token decoding
        ScopePlayIntegrity = "https://www.googleapis.com/auth/playintegrity"

        // Origin string constants
        originADCString         = "adc"
        originKeyfileString     = "keyfile"
        originEnvironmentString = "environment"
        originOAuthString       = "oauth"
        originUnknownString     = "unknown"
)

// CredentialOrigin indicates where credentials were obtained from.
type CredentialOrigin int

const (
        OriginADC CredentialOrigin = iota
        OriginKeyfile
        OriginEnvironment
        OriginOAuth
)

func (o CredentialOrigin) String() string <span class="cov6" title="8">{
        switch o </span>{
        case OriginADC:<span class="cov1" title="1">
                return originADCString</span>
        case OriginKeyfile:<span class="cov4" title="4">
                return originKeyfileString</span>
        case OriginEnvironment:<span class="cov1" title="1">
                return originEnvironmentString</span>
        case OriginOAuth:<span class="cov1" title="1">
                return originOAuthString</span>
        default:<span class="cov1" title="1">
                return originUnknownString</span>
        }
}

// Credentials holds the authenticated credentials.
type Credentials struct {
        TokenSource oauth2.TokenSource
        Origin      CredentialOrigin
        KeyPath     string // Only for keyfile origin
        Email       string // Service account email
        ClientID    string // Service account client ID
        Scopes      []string
}

// Manager handles authentication operations.
type Manager struct {
        creds           *Credentials
        mu              sync.Mutex
        storage         SecureStorage
        storeTokensMode string
        activeProfile   string
}

// NewManager creates a new authentication manager.
func NewManager(storage SecureStorage) *Manager <span class="cov10" title="38">{
        return &amp;Manager{
                storage:         storage,
                storeTokensMode: "auto",
                activeProfile:   defaultAuthProfile,
        }
}</span>

func (m *Manager) SetStoreTokens(mode string) <span class="cov6" title="8">{
        if mode == "" </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov5" title="7">m.storeTokensMode = mode</span>
}

func (m *Manager) SetActiveProfile(profile string) <span class="cov5" title="6">{
        m.mu.Lock()
        defer m.mu.Unlock()
        if profile == "" </span><span class="cov2" title="2">{
                profile = defaultAuthProfile
        }</span>
        <span class="cov5" title="6">m.activeProfile = profile</span>
}

func (m *Manager) GetActiveProfile() string <span class="cov5" title="7">{
        m.mu.Lock()
        defer m.mu.Unlock()
        if m.activeProfile == "" </span><span class="cov0" title="0">{
                return defaultAuthProfile
        }</span>
        <span class="cov5" title="7">return m.activeProfile</span>
}

// Authenticate attempts to obtain credentials from various sources.
func (m *Manager) Authenticate(ctx context.Context, keyPath string) (*Credentials, error) <span class="cov4" title="4">{
        scopes := []string{
                ScopeAndroidPublisher,
                ScopePlayReporting,
                ScopeGames,
                ScopePlayIntegrity,
        }

        // Priority 1: Explicit key path
        if keyPath != "" </span><span class="cov1" title="1">{
                creds, err := m.authenticateFromKeyfile(ctx, keyPath, scopes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">m.mu.Lock()
                m.creds = creds
                m.mu.Unlock()
                return creds, nil</span>
        }

        // Priority 2: Environment variable
        <span class="cov3" title="3">envKey := config.GetEnvServiceAccountKey()
        if envKey != "" </span><span class="cov1" title="1">{
                creds, err := m.authenticateFromJSON(ctx, []byte(envKey), scopes, OriginEnvironment, "")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">creds.Origin = OriginEnvironment
                m.mu.Lock()
                m.creds = creds
                m.mu.Unlock()
                return creds, nil</span>
        }

        // Priority 3: GOOGLE_APPLICATION_CREDENTIALS
        <span class="cov2" title="2">gacPath := os.Getenv("GOOGLE_APPLICATION_CREDENTIALS")
        if gacPath != "" </span><span class="cov1" title="1">{
                creds, err := m.authenticateFromKeyfile(ctx, gacPath, scopes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">m.mu.Lock()
                m.creds = creds
                m.mu.Unlock()
                return creds, nil</span>
        }

        // Priority 4: Application Default Credentials
        <span class="cov1" title="1">creds, err := m.authenticateFromADC(ctx, scopes)
        if err != nil </span><span class="cov1" title="1">{
                details := map[string]interface{}{
                        "gpdServiceAccountKeySet":            envKey != "",
                        "googleApplicationCredentialsSet":    gacPath != "",
                        "googleApplicationCredentialsExists": false,
                }
                if gacPath != "" </span><span class="cov0" title="0">{
                        if _, statErr := os.Stat(gacPath); statErr == nil </span><span class="cov0" title="0">{
                                details["googleApplicationCredentialsExists"] = true
                        }</span>
                }
                <span class="cov1" title="1">return nil, errors.NewAPIError(errors.CodeAuthFailure, "authentication not configured").
                        WithHint("Provide --key, set GPD_SERVICE_ACCOUNT_KEY, or set GOOGLE_APPLICATION_CREDENTIALS").
                        WithDetails(details)</span>
        }
        <span class="cov0" title="0">m.mu.Lock()
        m.creds = creds
        m.mu.Unlock()
        return creds, nil</span>
}

func (m *Manager) authenticateFromKeyfile(ctx context.Context, path string, scopes []string) (*Credentials, error) <span class="cov3" title="3">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov1" title="1">{
                return nil, errors.NewAPIError(errors.CodeAuthFailure, fmt.Sprintf("failed to read key file: %v", err)).
                        WithHint("Check that the service account key file exists and is readable")
        }</span>

        <span class="cov2" title="2">creds, err := m.authenticateFromJSON(ctx, data, scopes, OriginKeyfile, path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="2">creds.Origin = OriginKeyfile
        creds.KeyPath = path
        return creds, nil</span>
}

func (m *Manager) authenticateFromJSON(ctx context.Context, jsonKey []byte, scopes []string, origin CredentialOrigin, keyPath string) (*Credentials, error) <span class="cov6" title="9">{
        // Validate JSON structure
        var keyData struct {
                Type                    string `json:"type"`
                ProjectID               string `json:"project_id"`
                PrivateKeyID            string `json:"private_key_id"`
                PrivateKey              string `json:"private_key"`
                ClientEmail             string `json:"client_email"`
                ClientID                string `json:"client_id"`
                AuthURI                 string `json:"auth_uri"`
                TokenURI                string `json:"token_uri"`
                AuthProviderX509CertURL string `json:"auth_provider_x509_cert_url"`
                ClientX509CertURL       string `json:"client_x509_cert_url"`
        }
        if err := json.Unmarshal(jsonKey, &amp;keyData); err != nil </span><span class="cov1" title="1">{
                return nil, invalidServiceAccountError(map[string]interface{}{"reason": "invalid_json", "details": err.Error()})
        }</span>

        <span class="cov6" title="8">if keyData.Type != "service_account" </span><span class="cov1" title="1">{
                return nil, invalidServiceAccountError(map[string]interface{}{"reason": "invalid_type", "type": keyData.Type})
        }</span>

        <span class="cov5" title="7">missing := []string{}
        if keyData.ClientEmail == "" </span><span class="cov1" title="1">{
                missing = append(missing, "client_email")
        }</span>
        <span class="cov5" title="7">if keyData.ClientID == "" </span><span class="cov1" title="1">{
                missing = append(missing, "client_id")
        }</span>
        <span class="cov5" title="7">if keyData.PrivateKey == "" </span><span class="cov1" title="1">{
                missing = append(missing, "private_key")
        }</span>
        <span class="cov5" title="7">if keyData.TokenURI == "" </span><span class="cov1" title="1">{
                missing = append(missing, "token_uri")
        }</span>
        <span class="cov5" title="7">if len(missing) &gt; 0 </span><span class="cov4" title="4">{
                return nil, invalidServiceAccountError(map[string]interface{}{"reason": "missing_fields", "fields": missing})
        }</span>

        <span class="cov3" title="3">jwtConfig, err := google.JWTConfigFromJSON(jsonKey, scopes...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, invalidServiceAccountError(map[string]interface{}{"reason": "jwt_config_error", "details": err.Error()})
        }</span>

        <span class="cov3" title="3">baseTokenSource := jwtConfig.TokenSource(ctx)
        wrappedTokenSource := m.wrapTokenSource(baseTokenSource, origin, keyData.ClientEmail, keyData.ClientID, scopes)

        return &amp;Credentials{
                TokenSource: wrappedTokenSource,
                Origin:      origin,
                Email:       keyData.ClientEmail,
                ClientID:    keyData.ClientID,
                Scopes:      scopes,
                KeyPath:     keyPath,
        }, nil</span>
}

func invalidServiceAccountError(details map[string]interface{}) *errors.APIError <span class="cov5" title="6">{
        return errors.NewAPIError(errors.CodeAuthFailure, "invalid service account key").
                WithHint("Ensure the service account key JSON includes client_email, client_id, private_key, and token_uri").
                WithDetails(details)
}</span>

func (m *Manager) authenticateFromADC(ctx context.Context, scopes []string) (*Credentials, error) <span class="cov2" title="2">{
        creds, err := google.FindDefaultCredentials(ctx, scopes...)
        if err != nil </span><span class="cov1" title="1">{
                return nil, errors.NewAPIError(errors.CodeAuthFailure, "failed to find default credentials").
                        WithHint("Set GOOGLE_APPLICATION_CREDENTIALS or configure Application Default Credentials")
        }</span>

        <span class="cov1" title="1">wrappedTokenSource := m.wrapTokenSource(creds.TokenSource, OriginADC, "", "", scopes)

        return &amp;Credentials{
                TokenSource: wrappedTokenSource,
                Origin:      OriginADC,
                Scopes:      scopes,
        }, nil</span>
}

func (m *Manager) AuthenticateWithDeviceCode(ctx context.Context, clientID, clientSecret string, scopes []string, promptWriter io.Writer) (*Credentials, error) <span class="cov3" title="3">{
        if clientID == "" </span><span class="cov1" title="1">{
                return nil, errors.NewAPIError(errors.CodeAuthFailure, "OAuth client ID is required").
                        WithHint("Provide --client-id or set GPD_CLIENT_ID")
        }</span>
        <span class="cov2" title="2">if len(scopes) == 0 </span><span class="cov1" title="1">{
                return nil, errors.NewAPIError(errors.CodeAuthFailure, "OAuth scopes are required")
        }</span>

        <span class="cov1" title="1">oauthConfig := &amp;oauth2.Config{
                ClientID:     clientID,
                ClientSecret: clientSecret,
                Scopes:       scopes,
                Endpoint:     google.Endpoint,
        }

        flow := NewDeviceCodeFlow(oauthConfig)
        deviceResp, err := flow.RequestDeviceCode(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, errors.NewAPIError(errors.CodeAuthFailure,
                        fmt.Sprintf("failed to request device code: %v", err))
        }</span>
        <span class="cov0" title="0">displayDeviceCodePrompt(promptWriter, deviceResp)

        token, err := flow.PollForToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewAPIError(errors.CodeAuthFailure,
                        fmt.Sprintf("device code authentication failed: %v", err))
        }</span>

        <span class="cov0" title="0">baseTokenSource := oauthConfig.TokenSource(ctx, token)
        wrappedTokenSource := m.wrapTokenSource(baseTokenSource, OriginOAuth, "", clientID, scopes)

        creds := &amp;Credentials{
                TokenSource: wrappedTokenSource,
                Origin:      OriginOAuth,
                ClientID:    clientID,
                Scopes:      scopes,
        }
        m.mu.Lock()
        m.creds = creds
        m.mu.Unlock()
        return creds, nil</span>
}

func (m *Manager) wrapTokenSource(base oauth2.TokenSource, origin CredentialOrigin, email, clientID string, scopes []string) oauth2.TokenSource <span class="cov5" title="6">{
        tokenSource := base
        if m.storageEnabled() </span><span class="cov1" title="1">{
                hash, last4 := clientIDHash(clientID)
                profile := m.GetActiveProfile()
                key := tokenStorageKey(profile, hash)
                if storedToken, err := m.loadStoredToken(key); err == nil &amp;&amp; storedToken != nil </span><span class="cov0" title="0">{
                        tokenSource = oauth2.ReuseTokenSource(storedToken, tokenSource)
                }</span>
                <span class="cov1" title="1">tokenSource = &amp;EarlyRefreshTokenSource{
                        base:          tokenSource,
                        refreshLeeway: 300 * time.Second,
                        clockSkew:     30 * time.Second,
                }
                metadata := &amp;TokenMetadata{
                        Profile:       profile,
                        ClientIDHash:  hash,
                        ClientIDLast4: last4,
                        Origin:        origin.String(),
                        Email:         email,
                        Scopes:        scopes,
                        UpdatedAt:     time.Now().UTC().Format(time.RFC3339),
                }
                return &amp;PersistedTokenSource{
                        base:       tokenSource,
                        storage:    m.storage,
                        storageKey: key,
                        metadata:   metadata,
                }</span>
        }

        <span class="cov4" title="5">return &amp;EarlyRefreshTokenSource{
                base:          tokenSource,
                refreshLeeway: 300 * time.Second,
                clockSkew:     30 * time.Second,
        }</span>
}

// GetTokenSource returns the current token source.
func (m *Manager) GetTokenSource(ctx context.Context) (oauth2.TokenSource, error) <span class="cov2" title="2">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.creds == nil </span><span class="cov1" title="1">{
                return nil, errors.ErrAuthNotConfigured
        }</span>

        <span class="cov1" title="1">return m.creds.TokenSource, nil</span>
}

// GetCredentials returns the current credentials.
func (m *Manager) GetCredentials() *Credentials <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        return m.creds
}</span>

// Clear clears the current credentials.
func (m *Manager) Clear() <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.creds = nil
}</span>

// EarlyRefreshTokenSource wraps a token source to refresh tokens early.
type EarlyRefreshTokenSource struct {
        base          oauth2.TokenSource
        refreshLeeway time.Duration
        clockSkew     time.Duration
        mu            sync.Mutex
        cachedToken   *oauth2.Token
}

// Token returns a token, refreshing early if needed.
func (s *EarlyRefreshTokenSource) Token() (*oauth2.Token, error) <span class="cov4" title="5">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Check if we have a valid cached token
        if s.cachedToken != nil &amp;&amp; s.cachedToken.Valid() </span><span class="cov1" title="1">{
                // Check if we should refresh early
                expiryWithLeeway := s.cachedToken.Expiry.Add(-s.refreshLeeway).Add(-s.clockSkew)
                if time.Now().Before(expiryWithLeeway) </span><span class="cov1" title="1">{
                        return s.cachedToken, nil
                }</span>
        }

        // Get a new token
        <span class="cov4" title="4">token, err := s.base.Token()
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="3">s.cachedToken = token
        return token, nil</span>
}

// SecureStorage interface for platform-specific credential storage.
type SecureStorage interface {
        Store(key string, value []byte) error
        Retrieve(key string) ([]byte, error)
        Delete(key string) error
        Available() bool
}

// PermissionCheck represents a permission validation result.
type PermissionCheck struct {
        Surface   string `json:"surface"`
        HasAccess bool   `json:"hasAccess"`
        Error     string `json:"error,omitempty"`
        TestCall  string `json:"testCall"`
}

// CheckResult contains the results of permission validation.
type CheckResult struct {
        Valid       bool               `json:"valid"`
        Origin      string             `json:"origin"`
        Email       string             `json:"email,omitempty"`
        Permissions []*PermissionCheck `json:"permissions"`
}

// Status represents the current authentication status.
type Status struct {
        Authenticated bool   `json:"authenticated"`
        Origin        string `json:"origin,omitempty"`
        Email         string `json:"email,omitempty"`
        KeyPath       string `json:"keyPath,omitempty"`
        TokenValid    bool   `json:"tokenValid"`
        TokenExpiry   string `json:"tokenExpiry,omitempty"`
}

// GetStatus returns the current authentication status.
func (m *Manager) GetStatus(ctx context.Context) (*Status, error) <span class="cov3" title="3">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.creds == nil </span><span class="cov1" title="1">{
                return &amp;Status{
                        Authenticated: false,
                }, nil
        }</span>

        <span class="cov2" title="2">status := &amp;Status{
                Authenticated: true,
                Origin:        m.creds.Origin.String(),
                Email:         m.creds.Email,
                KeyPath:       m.creds.KeyPath,
        }

        // Check token validity
        token, err := m.creds.TokenSource.Token()
        if err != nil </span><span class="cov1" title="1">{
                status.TokenValid = false
        }</span> else<span class="cov1" title="1"> {
                status.TokenValid = token.Valid()
                if !token.Expiry.IsZero() </span><span class="cov1" title="1">{
                        status.TokenExpiry = token.Expiry.Format(time.RFC3339)
                }</span>
        }

        <span class="cov2" title="2">return status, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package auth

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strings"
        "time"

        "golang.org/x/oauth2"
)

type DeviceCodeResponse struct {
        DeviceCode              string `json:"device_code"`
        UserCode                string `json:"user_code"`
        VerificationURL         string `json:"verification_url"`
        VerificationURI         string `json:"verification_uri"`
        VerificationURLComplete string `json:"verification_uri_complete"`
        ExpiresIn               int    `json:"expires_in"`
        Interval                int    `json:"interval"`
}

type TokenResponse struct {
        AccessToken  string `json:"access_token"`
        RefreshToken string `json:"refresh_token"`
        ExpiresIn    int    `json:"expires_in"`
        TokenType    string `json:"token_type"`
        Scope        string `json:"scope"`
        Error        string `json:"error,omitempty"`
}

const (
        // #nosec G101 -- OAuth endpoints, not credentials.
        deviceCodeEndpoint = "https://oauth2.googleapis.com/device/code"
        // #nosec G101 -- OAuth endpoints, not credentials.
        tokenEndpoint = "https://oauth2.googleapis.com/token"
        authPending   = "authorization_pending"
        slowDown      = "slow_down"
)

type DeviceCodeFlow struct {
        config   *oauth2.Config
        response *DeviceCodeResponse
}

func NewDeviceCodeFlow(config *oauth2.Config) *DeviceCodeFlow <span class="cov9" title="9">{
        return &amp;DeviceCodeFlow{config: config}
}</span>

func (f *DeviceCodeFlow) RequestDeviceCode(ctx context.Context) (*DeviceCodeResponse, error) <span class="cov3" title="2">{
        data := url.Values{}
        data.Set("client_id", f.config.ClientID)
        data.Set("scope", strings.Join(f.config.Scopes, " "))

        req, err := http.NewRequestWithContext(ctx, http.MethodPost, deviceCodeEndpoint, strings.NewReader(data.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create device code request: %w", err)
        }</span>
        <span class="cov3" title="2">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

        client := &amp;http.Client{Timeout: 30 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("failed to request device code: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = resp.Body.Close()
        }</span>()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("device code request failed: %s - %s", resp.Status, string(body))
        }</span>

        <span class="cov0" title="0">var deviceResp DeviceCodeResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;deviceResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode device code response: %w", err)
        }</span>
        <span class="cov0" title="0">f.response = &amp;deviceResp
        return &amp;deviceResp, nil</span>
}

func (f *DeviceCodeFlow) PollForToken(ctx context.Context) (*oauth2.Token, error) <span class="cov6" title="4">{
        if f.response == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("device code not requested")
        }</span>

        <span class="cov5" title="3">interval := time.Duration(f.response.Interval) * time.Second
        if interval &lt; 5*time.Second </span><span class="cov5" title="3">{
                interval = 5 * time.Second
        }</span>
        <span class="cov5" title="3">expiry := time.Now().Add(time.Duration(f.response.ExpiresIn) * time.Second)
        client := &amp;http.Client{Timeout: 30 * time.Second}

        for </span><span class="cov5" title="3">{
                if time.Now().After(expiry) </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("device code expired")
                }</span>
                <span class="cov3" title="2">select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return nil, ctx.Err()</span>
                default:<span class="cov1" title="1"></span>
                }

                <span class="cov1" title="1">token, errType, err := f.pollOnce(ctx, client)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if token != nil </span><span class="cov0" title="0">{
                        return token, nil
                }</span>
                <span class="cov0" title="0">switch errType </span>{
                case authPending:<span class="cov0" title="0">
                        time.Sleep(interval)</span>
                case slowDown:<span class="cov0" title="0">
                        interval += 5 * time.Second
                        time.Sleep(interval)</span>
                default:<span class="cov0" title="0">
                        time.Sleep(interval)</span>
                }
        }
}

func (f *DeviceCodeFlow) pollOnce(ctx context.Context, client *http.Client) (*oauth2.Token, string, error) <span class="cov1" title="1">{
        data := url.Values{}
        data.Set("client_id", f.config.ClientID)
        if f.config.ClientSecret != "" </span><span class="cov0" title="0">{
                data.Set("client_secret", f.config.ClientSecret)
        }</span>
        <span class="cov1" title="1">data.Set("device_code", f.response.DeviceCode)
        data.Set("grant_type", "urn:ietf:params:oauth:grant-type:device_code")

        req, err := http.NewRequestWithContext(ctx, http.MethodPost, tokenEndpoint, strings.NewReader(data.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to create token poll request: %w", err)
        }</span>
        <span class="cov1" title="1">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

        resp, err := client.Do(req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, "", fmt.Errorf("failed to poll for token: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = resp.Body.Close()
        }</span>()

        <span class="cov0" title="0">var tokenResp TokenResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;tokenResp); err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to decode token response: %w", err)
        }</span>

        <span class="cov0" title="0">if tokenResp.Error != "" </span><span class="cov0" title="0">{
                switch tokenResp.Error </span>{
                case authPending, slowDown:<span class="cov0" title="0">
                        return nil, tokenResp.Error, nil</span>
                case "expired_token":<span class="cov0" title="0">
                        return nil, "", fmt.Errorf("device code has expired")</span>
                case "access_denied":<span class="cov0" title="0">
                        return nil, "", fmt.Errorf("user denied authorization")</span>
                default:<span class="cov0" title="0">
                        return nil, "", fmt.Errorf("token error: %s", tokenResp.Error)</span>
                }
        }

        <span class="cov0" title="0">if tokenResp.AccessToken != "" </span><span class="cov0" title="0">{
                expiryDate := time.Now().Add(time.Duration(tokenResp.ExpiresIn) * time.Second)
                return &amp;oauth2.Token{
                        AccessToken:  tokenResp.AccessToken,
                        RefreshToken: tokenResp.RefreshToken,
                        TokenType:    tokenResp.TokenType,
                        Expiry:       expiryDate,
                }, "", nil
        }</span>

        <span class="cov0" title="0">return nil, authPending, nil</span>
}

func displayDeviceCodePrompt(w io.Writer, resp *DeviceCodeResponse) <span class="cov10" title="11">{
        if w == nil || resp == nil </span><span class="cov3" title="2">{
                return
        }</span>
        <span class="cov9" title="9">verificationURL := resp.VerificationURL
        if verificationURL == "" </span><span class="cov5" title="3">{
                verificationURL = resp.VerificationURI
        }</span>
        <span class="cov9" title="9">_, _ = fmt.Fprintln(w, "Authenticate with Google Play Developer CLI")
        _, _ = fmt.Fprintln(w, "1) Visit:", verificationURL)
        _, _ = fmt.Fprintln(w, "2) Enter code:", resp.UserCode)
        if resp.VerificationURLComplete != "" </span><span class="cov3" title="2">{
                _, _ = fmt.Fprintln(w, "Or visit:", resp.VerificationURLComplete)
        }</span>
        <span class="cov9" title="9">_, _ = fmt.Fprintln(w, "Waiting for authorization...")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package auth

import (
        "encoding/json"
        "time"

        "golang.org/x/oauth2"

        gpdErrors "github.com/dl-alexandre/gpd/internal/errors"
)

type PersistedTokenSource struct {
        base       oauth2.TokenSource
        storage    SecureStorage
        storageKey string
        metadata   *TokenMetadata
}

func (s *PersistedTokenSource) Token() (*oauth2.Token, error) <span class="cov10" title="3">{
        token, err := s.base.Token()
        if err != nil </span><span class="cov1" title="1">{
                if apiErr := gpdErrors.ClassifyAuthError(err); apiErr != nil </span><span class="cov1" title="1">{
                        return nil, apiErr
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov6" title="2">if token == nil || s.storage == nil </span><span class="cov1" title="1">{
                return token, nil
        }</span>

        <span class="cov1" title="1">if token.RefreshToken == "" </span><span class="cov1" title="1">{
                if existing, err := s.storage.Retrieve(s.storageKey); err == nil &amp;&amp; len(existing) &gt; 0 </span><span class="cov0" title="0">{
                        var storedToken StoredToken
                        if err := json.Unmarshal(existing, &amp;storedToken); err == nil &amp;&amp; storedToken.RefreshToken != "" </span><span class="cov0" title="0">{
                                token.RefreshToken = storedToken.RefreshToken
                        }</span>
                }
        }

        <span class="cov1" title="1">stored := StoredToken{
                AccessToken:  token.AccessToken,
                RefreshToken: token.RefreshToken,
                TokenType:    token.TokenType,
                Expiry:       token.Expiry.Format(time.RFC3339),
        }
        if s.metadata != nil </span><span class="cov1" title="1">{
                stored.Origin = s.metadata.Origin
                stored.Email = s.metadata.Email
                stored.Scopes = s.metadata.Scopes
        }</span>
        <span class="cov1" title="1">data, err := json.Marshal(stored)
        if err == nil </span><span class="cov1" title="1">{
                _ = s.storage.Store(s.storageKey, data)
        }</span>
        <span class="cov1" title="1">if s.metadata != nil </span><span class="cov1" title="1">{
                s.metadata.TokenExpiry = token.Expiry.Format(time.RFC3339)
                s.metadata.UpdatedAt = time.Now().UTC().Format(time.RFC3339)
                _ = writeTokenMetadata(s.storageKey, s.metadata)
        }</span>
        <span class="cov1" title="1">return token, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package auth

import (
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "time"

        "golang.org/x/oauth2"

        "github.com/dl-alexandre/gpd/internal/config"
)

const (
        defaultAuthProfile  = "default"
        tokenKeySeparator   = "--"
        tokenMetadataSuffix = ".meta.json"
)

type StoredToken struct {
        AccessToken  string   `json:"access_token"`
        RefreshToken string   `json:"refresh_token,omitempty"`
        TokenType    string   `json:"token_type,omitempty"`
        Expiry       string   `json:"expiry"`
        Scopes       []string `json:"scopes,omitempty"`
        Origin       string   `json:"origin,omitempty"`
        Email        string   `json:"email,omitempty"`
        KeyPath      string   `json:"keyPath,omitempty"`
        ClientID     string   `json:"clientId,omitempty"`
}

type TokenMetadata struct {
        Profile       string   `json:"profile"`
        ClientIDHash  string   `json:"clientIdHash"`
        ClientIDLast4 string   `json:"clientIdLast4,omitempty"`
        Origin        string   `json:"origin"`
        Email         string   `json:"email,omitempty"`
        Scopes        []string `json:"scopes,omitempty"`
        TokenExpiry   string   `json:"tokenExpiry,omitempty"`
        UpdatedAt     string   `json:"updatedAt"`
}

func (m *Manager) storageEnabled() bool <span class="cov9" title="16">{
        if m.storeTokensMode == "never" </span><span class="cov4" title="3">{
                return false
        }</span>
        <span class="cov8" title="13">if m.storage == nil || !m.storage.Available() </span><span class="cov5" title="4">{
                return false
        }</span>
        <span class="cov7" title="9">return true</span>
}

func (m *Manager) TokenLocation() string <span class="cov3" title="2">{
        if m.storageEnabled() </span><span class="cov1" title="1">{
                return "secure-storage"
        }</span>
        <span class="cov1" title="1">return "memory"</span>
}

func (m *Manager) LoadTokenMetadata(profile string) (*TokenMetadata, error) <span class="cov1" title="1">{
        meta, _, err := findTokenMetadata(profile)
        return meta, err
}</span>

func (m *Manager) ListProfiles() ([]TokenMetadata, error) <span class="cov5" title="5">{
        paths := config.GetPaths()
        dir := filepath.Join(paths.ConfigDir, "tokens")
        entries, err := os.ReadDir(dir)
        if err != nil </span><span class="cov3" title="2">{
                if os.IsNotExist(err) </span><span class="cov3" title="2">{
                        return []TokenMetadata{}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov4" title="3">byProfile := make(map[string]*TokenMetadata)
        byProfileMod := make(map[string]time.Time)
        for _, entry := range entries </span><span class="cov6" title="6">{
                if entry.IsDir() || !strings.HasSuffix(entry.Name(), tokenMetadataSuffix) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov6" title="6">info, err := entry.Info()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov6" title="6">metaPath := filepath.Join(dir, entry.Name())
                meta, err := readTokenMetadata(metaPath)
                if err != nil || meta == nil || meta.Profile == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov6" title="6">if priorMod, ok := byProfileMod[meta.Profile]; !ok || info.ModTime().After(priorMod) </span><span class="cov6" title="6">{
                        byProfile[meta.Profile] = meta
                        byProfileMod[meta.Profile] = info.ModTime()
                }</span>
        }
        <span class="cov4" title="3">profiles := make([]TokenMetadata, 0, len(byProfile))
        for _, meta := range byProfile </span><span class="cov5" title="5">{
                if meta == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov5" title="5">profiles = append(profiles, *meta)</span>
        }
        <span class="cov4" title="3">sort.Slice(profiles, func(i, j int) bool </span><span class="cov3" title="2">{
                return profiles[i].Profile &lt; profiles[j].Profile
        }</span>)
        <span class="cov4" title="3">return profiles, nil</span>
}

func tokenStorageKey(profile, hash string) string <span class="cov4" title="3">{
        if hash == "" </span><span class="cov1" title="1">{
                return profile
        }</span>
        <span class="cov3" title="2">return profile + tokenKeySeparator + hash</span>
}

func clientIDHash(clientID string) (hash, last4 string) <span class="cov4" title="3">{
        if clientID == "" </span><span class="cov1" title="1">{
                return "", ""
        }</span>
        <span class="cov3" title="2">hashBytes := sha256.Sum256([]byte(clientID))
        hexHash := hex.EncodeToString(hashBytes[:])
        last4 = clientID
        if len(clientID) &gt; 4 </span><span class="cov3" title="2">{
                last4 = clientID[len(clientID)-4:]
        }</span>
        <span class="cov3" title="2">return hexHash, last4</span>
}

func tokenMetadataPath(key string) string <span class="cov10" title="19">{
        paths := config.GetPaths()
        return filepath.Join(paths.ConfigDir, "tokens", key+tokenMetadataSuffix)
}</span>

func writeTokenMetadata(key string, metadata *TokenMetadata) error <span class="cov8" title="13">{
        paths := config.GetPaths()
        dir := filepath.Join(paths.ConfigDir, "tokens")
        if err := os.MkdirAll(dir, 0700); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="13">data, err := json.MarshalIndent(metadata, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="13">return os.WriteFile(tokenMetadataPath(key), data, 0600)</span>
}

func readTokenMetadata(path string) (*TokenMetadata, error) <span class="cov8" title="13">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="12">var metadata TokenMetadata
        if err := json.Unmarshal(data, &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="12">return &amp;metadata, nil</span>
}

func findTokenMetadata(profile string) (*TokenMetadata, string, error) <span class="cov5" title="4">{
        paths := config.GetPaths()
        dir := filepath.Join(paths.ConfigDir, "tokens")
        entries, err := os.ReadDir(dir)
        if err != nil </span><span class="cov1" title="1">{
                if os.IsNotExist(err) </span><span class="cov1" title="1">{
                        return nil, "", nil
                }</span>
                <span class="cov0" title="0">return nil, "", err</span>
        }
        <span class="cov4" title="3">var selected *TokenMetadata
        var selectedKey string
        var selectedMod time.Time
        for _, entry := range entries </span><span class="cov5" title="5">{
                if entry.IsDir() || !strings.HasSuffix(entry.Name(), tokenMetadataSuffix) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov5" title="5">info, err := entry.Info()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov5" title="5">metaPath := filepath.Join(dir, entry.Name())
                meta, err := readTokenMetadata(metaPath)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov5" title="5">if meta.Profile != profile </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov5" title="4">if selected == nil || info.ModTime().After(selectedMod) </span><span class="cov5" title="4">{
                        selected = meta
                        selectedKey = strings.TrimSuffix(entry.Name(), tokenMetadataSuffix)
                        selectedMod = info.ModTime()
                }</span>
        }
        <span class="cov4" title="3">return selected, selectedKey, nil</span>
}

func (m *Manager) loadStoredToken(key string) (*oauth2.Token, error) <span class="cov6" title="6">{
        if !m.storageEnabled() </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov6" title="6">data, err := m.storage.Retrieve(key)
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>
        <span class="cov5" title="4">var stored StoredToken
        if err := json.Unmarshal(data, &amp;stored); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov4" title="3">token := &amp;oauth2.Token{
                AccessToken:  stored.AccessToken,
                RefreshToken: stored.RefreshToken,
                TokenType:    stored.TokenType,
        }
        if stored.Expiry != "" </span><span class="cov4" title="3">{
                expiry, err := time.Parse(time.RFC3339, stored.Expiry)
                if err == nil </span><span class="cov4" title="3">{
                        token.Expiry = expiry
                }</span>
        }
        <span class="cov4" title="3">if !token.Valid() &amp;&amp; token.RefreshToken == "" </span><span class="cov3" title="2">{
                return nil, nil
        }</span>
        <span class="cov1" title="1">return token, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package cli provides analytics commands for gpd.
package cli

import (
        "context"

        "github.com/spf13/cobra"

        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

func (c *CLI) addAnalyticsCommands() <span class="cov10" title="18">{
        analyticsCmd := &amp;cobra.Command{
                Use:   "analytics",
                Short: "Analytics commands",
                Long:  "Access app analytics and install statistics.",
        }

        var (
                startDate  string
                endDate    string
                metrics    []string
                dimensions []string
                outputFmt  string
                pageSize   int64
                pageToken  string
                all        bool
        )

        // analytics query
        queryCmd := &amp;cobra.Command{
                Use:   "query",
                Short: "Query analytics data",
                Long:  "Query app analytics data for a date range.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.analyticsQuery(cmd.Context(), startDate, endDate, metrics, dimensions, outputFmt, pageSize, pageToken, all)
                }</span>,
        }
        <span class="cov10" title="18">queryCmd.Flags().StringVar(&amp;startDate, "start-date", "", "Start date (ISO 8601)")
        queryCmd.Flags().StringVar(&amp;endDate, "end-date", "", "End date (ISO 8601)")
        queryCmd.Flags().StringSliceVar(&amp;metrics, "metrics", []string{"installs"}, "Metrics to retrieve")
        queryCmd.Flags().StringSliceVar(&amp;dimensions, "dimensions", nil, "Dimensions for grouping")
        queryCmd.Flags().StringVar(&amp;outputFmt, "format", "json", "Output format: json, csv")
        queryCmd.Flags().Int64Var(&amp;pageSize, "page-size", 100, "Results per page")
        queryCmd.Flags().StringVar(&amp;pageToken, "page-token", "", "Pagination token")
        addPaginationFlags(queryCmd, &amp;all)

        // analytics capabilities
        capabilitiesCmd := &amp;cobra.Command{
                Use:   "capabilities",
                Short: "List analytics capabilities",
                Long:  "List available metrics, dimensions, and granularities.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.analyticsCapabilities(cmd.Context())
                }</span>,
        }

        <span class="cov10" title="18">analyticsCmd.AddCommand(queryCmd, capabilitiesCmd)
        c.rootCmd.AddCommand(analyticsCmd)</span>
}

func (c *CLI) analyticsQuery(ctx context.Context, startDate, endDate string, metrics, dimensions []string,
        outputFmt string, pageSize int64, pageToken string, all bool) error <span class="cov0" title="0">{
        if apiErr := validateReportingDates(startDate, endDate); apiErr != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(apiErr).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>
        <span class="cov0" title="0">if len(metrics) != 1 </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError, "exactly one metric is required").
                        WithHint("Use --metrics with a single value. For multiple metrics, run separate queries.")).
                        WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">metric := metrics[0]
        switch metric </span>{
        case "crashRate":<span class="cov0" title="0">
                return c.vitalsCrashes(ctx, startDate, endDate, dimensions, outputFmt, pageSize, pageToken, all)</span>
        case "anrRate":<span class="cov0" title="0">
                return c.vitalsANRs(ctx, startDate, endDate, dimensions, outputFmt, pageSize, pageToken, all)</span>
        case "excessiveWakeups":<span class="cov0" title="0">
                return c.vitalsExcessiveWakeups(ctx, startDate, endDate, dimensions, outputFmt, pageSize, pageToken, all)</span>
        case "slowRendering":<span class="cov0" title="0">
                return c.vitalsSlowRendering(ctx, startDate, endDate, dimensions, outputFmt, pageSize, pageToken, all)</span>
        case "slowStart":<span class="cov0" title="0">
                return c.vitalsSlowStart(ctx, startDate, endDate, dimensions, outputFmt, pageSize, pageToken, all)</span>
        case "stuckWakelocks":<span class="cov0" title="0">
                return c.vitalsStuckWakelocks(ctx, startDate, endDate, dimensions, outputFmt, pageSize, pageToken, all)</span>
        default:<span class="cov0" title="0">
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                        "requested metric is not available in public Play Reporting APIs").
                        WithHint("Supported metrics: crashRate, anrRate, excessiveWakeups, slowRendering, slowStart, stuckWakelocks")).
                        WithServices("playdeveloperreporting")
                return c.Output(result)</span>
        }
}

func (c *CLI) analyticsCapabilities(_ context.Context) error <span class="cov0" title="0">{
        result := output.NewResult(map[string]interface{}{
                "requiredScopes": []string{"https://www.googleapis.com/auth/playdeveloperreporting"},
                "metrics": []map[string]interface{}{
                        {"name": "crashRate", "description": "Crash rate per 1000 sessions"},
                        {"name": "anrRate", "description": "ANR rate per 1000 sessions"},
                        {"name": "excessiveWakeups", "description": "Excessive wakeups"},
                        {"name": "slowRendering", "description": "Slow rendering rate"},
                        {"name": "slowStart", "description": "Slow start rate"},
                        {"name": "stuckWakelocks", "description": "Stuck wakelocks"},
                },
                "dimensions": []map[string]interface{}{
                        {"name": "country", "description": "Country code"},
                        {"name": "device", "description": "Device model"},
                        {"name": "androidVersion", "description": "Android OS version"},
                        {"name": "appVersion", "description": "App version code"},
                },
                "granularities":   []string{"daily"},
                "maxLookbackDays": 28,
                "dataFreshness": map[string]interface{}{
                        "typical": "24-48 hours",
                        "note":    "Analytics queries proxy to Play Reporting vitals metrics",
                },
                "notes": []string{
                        "Install, revenue, and discovery analytics are not available via public APIs.",
                        "Use gpd vitals for full app quality metrics and error reports.",
                },
        })
        return c.Output(result.WithServices("playdeveloperreporting"))
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package cli

import (
        "context"
        "fmt"

        "github.com/spf13/cobra"

        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

func (c *CLI) addAppsCommands() <span class="cov10" title="18">{
        appsCmd := &amp;cobra.Command{
                Use:   "apps",
                Short: "App discovery commands",
                Long:  "List apps accessible in the Google Play developer account.",
        }

        var (
                pageSize  int64
                pageToken string
                all       bool
        )

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List apps in the developer account",
                Long:  "List apps accessible to the authenticated account with pagination support.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.appsList(cmd.Context(), pageSize, pageToken, all)
                }</span>,
        }
        <span class="cov10" title="18">listCmd.Flags().Int64Var(&amp;pageSize, "page-size", 100, "Results per page")
        listCmd.Flags().StringVar(&amp;pageToken, "page-token", "", "Pagination token")
        addPaginationFlags(listCmd, &amp;all)

        getCmd := &amp;cobra.Command{
                Use:   "get [package]",
                Short: "Get app details",
                Long:  "Get details for a specific app package. Uses --package when omitted.",
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        packageName := c.packageName
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                packageName = args[0]
                        }</span>
                        <span class="cov0" title="0">if packageName == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError, "package name is required").
                                        WithHint("Provide a package as an argument or set --package")).WithServices("playdeveloperreporting")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.appsGet(cmd.Context(), packageName)</span>
                },
        }

        <span class="cov10" title="18">appsCmd.AddCommand(listCmd, getCmd)
        c.rootCmd.AddCommand(appsCmd)</span>
}

func (c *CLI) appsList(ctx context.Context, pageSize int64, pageToken string, all bool) error <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">reporting, err := client.PlayReporting()
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeGeneralError, err.Error())).
                        WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">req := reporting.Apps.Search()
        if pageSize &gt; 0 </span><span class="cov0" title="0">{
                req = req.PageSize(pageSize)
        }</span>
        <span class="cov0" title="0">if pageToken != "" </span><span class="cov0" title="0">{
                req = req.PageToken(pageToken)
        }</span>

        <span class="cov0" title="0">startToken := pageToken
        nextToken := ""
        apps := make([]interface{}, 0)
        for </span><span class="cov0" title="0">{
                resp, err := req.Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        result := output.NewErrorResult(errors.NewAPIError(errors.CodeGeneralError, err.Error())).
                                WithServices("playdeveloperreporting")
                        return c.Output(result)
                }</span>

                <span class="cov0" title="0">for _, app := range resp.Apps </span><span class="cov0" title="0">{
                        apps = append(apps, app)
                }</span>

                <span class="cov0" title="0">nextToken = resp.NextPageToken
                if nextToken == "" || !all </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">req = req.PageToken(nextToken)</span>
        }

        <span class="cov0" title="0">result := output.NewResult(apps)
        result.WithPagination(startToken, nextToken)
        return c.Output(result.WithServices("playdeveloperreporting"))</span>
}

func (c *CLI) appsGet(ctx context.Context, packageName string) error <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">reporting, err := client.PlayReporting()
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeGeneralError, err.Error())).
                        WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">req := reporting.Apps.Search().PageSize(100)
        for </span><span class="cov0" title="0">{
                resp, err := req.Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        result := output.NewErrorResult(errors.NewAPIError(errors.CodeGeneralError, err.Error())).
                                WithServices("playdeveloperreporting")
                        return c.Output(result)
                }</span>

                <span class="cov0" title="0">for _, app := range resp.Apps </span><span class="cov0" title="0">{
                        if app.PackageName == packageName </span><span class="cov0" title="0">{
                                return c.Output(output.NewResult(app).WithServices("playdeveloperreporting"))
                        }</span>
                }

                <span class="cov0" title="0">if resp.NextPageToken == "" </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">req = req.PageToken(resp.NextPageToken)</span>
        }

        <span class="cov0" title="0">result := output.NewErrorResult(errors.NewAPIError(errors.CodeNotFound,
                fmt.Sprintf("app not found for package %s", packageName))).WithServices("playdeveloperreporting")
        return c.Output(result)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package cli provides auth commands for gpd.
package cli

import (
        "context"
        "fmt"
        "sort"
        "time"

        "github.com/spf13/cobra"

        "github.com/dl-alexandre/gpd/internal/auth"

        "github.com/dl-alexandre/gpd/internal/config"
        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

const defaultProfileName = "default"

func (c *CLI) addAuthCommands() <span class="cov10" title="18">{
        authCmd := &amp;cobra.Command{
                Use:   "auth",
                Short: "Authentication commands",
                Long:  "Manage authentication and credentials for Google Play APIs.",
        }

        // auth status
        statusCmd := &amp;cobra.Command{
                Use:   "status",
                Short: "Check current authentication status",
                Long:  "Display the current authentication state and credential information.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.authStatus(cmd.Context())
                }</span>,
        }

        // auth check
        <span class="cov10" title="18">checkCmd := &amp;cobra.Command{
                Use:   "check",
                Short: "Validate service account permissions",
                Long:  "Validate that the service account has required permissions for each API surface.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.authCheck(cmd.Context())
                }</span>,
        }

        // auth logout
        <span class="cov10" title="18">logoutCmd := &amp;cobra.Command{
                Use:   "logout",
                Short: "Clear stored credentials",
                Long:  "Remove stored credentials from secure storage.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.authLogout(cmd.Context())
                }</span>,
        }

        // auth diagnose
        <span class="cov10" title="18">diagnoseCmd := &amp;cobra.Command{
                Use:   "diagnose",
                Short: "Diagnose authentication setup",
                Long:  "Show detailed authentication diagnostics and token refresh status.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        refreshCheck, _ := cmd.Flags().GetBool("refresh-check")
                        return c.authDiagnose(cmd.Context(), refreshCheck)
                }</span>,
        }
        <span class="cov10" title="18">diagnoseCmd.Flags().Bool("refresh-check", false, "Attempt a token refresh and report errors")

        // auth doctor (alias of diagnose for parity)
        doctorCmd := &amp;cobra.Command{
                Use:   "doctor",
                Short: "Diagnose authentication setup",
                Long:  "Alias for auth diagnose to match parity expectations.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        refreshCheck, _ := cmd.Flags().GetBool("refresh-check")
                        return c.authDiagnose(cmd.Context(), refreshCheck)
                }</span>,
        }
        <span class="cov10" title="18">doctorCmd.Flags().Bool("refresh-check", false, "Attempt a token refresh and report errors")

        // auth login
        var (
                loginClientID     string
                loginClientSecret string
                loginFlow         string
        )
        loginCmd := &amp;cobra.Command{
                Use:   "login [profile]",
                Short: "Authenticate using OAuth device flow",
                Long:  "Authenticate using OAuth device flow and store credentials for a profile.",
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        profile := defaultProfileName
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                profile = args[0]
                        }</span>
                        <span class="cov0" title="0">return c.authLogin(cmd.Context(), profile, loginClientID, loginClientSecret, loginFlow)</span>
                },
        }
        <span class="cov10" title="18">loginCmd.Flags().StringVar(&amp;loginClientID, "client-id", "", "OAuth client ID (or set GPD_CLIENT_ID)")
        loginCmd.Flags().StringVar(&amp;loginClientSecret, "client-secret", "", "OAuth client secret (or set GPD_CLIENT_SECRET)")
        loginCmd.Flags().StringVar(&amp;loginFlow, "flow", "device", "OAuth flow (device)")

        // auth init (alias of login)
        initCmd := &amp;cobra.Command{
                Use:   "init [profile]",
                Short: "Initialize OAuth authentication",
                Long:  "Alias for auth login to initialize credentials for a profile.",
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        profile := defaultProfileName
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                profile = args[0]
                        }</span>
                        <span class="cov0" title="0">return c.authLogin(cmd.Context(), profile, loginClientID, loginClientSecret, loginFlow)</span>
                },
        }
        <span class="cov10" title="18">initCmd.Flags().StringVar(&amp;loginClientID, "client-id", "", "OAuth client ID (or set GPD_CLIENT_ID)")
        initCmd.Flags().StringVar(&amp;loginClientSecret, "client-secret", "", "OAuth client secret (or set GPD_CLIENT_SECRET)")
        initCmd.Flags().StringVar(&amp;loginFlow, "flow", "device", "OAuth flow (device)")

        // auth switch
        switchCmd := &amp;cobra.Command{
                Use:   "switch &lt;profile&gt;",
                Short: "Switch active authentication profile",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.authSwitch(cmd.Context(), args[0])
                }</span>,
        }

        // auth list
        <span class="cov10" title="18">listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List stored authentication profiles",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.authList(cmd.Context())
                }</span>,
        }

        <span class="cov10" title="18">authCmd.AddCommand(statusCmd, checkCmd, logoutCmd, diagnoseCmd, doctorCmd, loginCmd, initCmd, switchCmd, listCmd)
        c.rootCmd.AddCommand(authCmd)</span>
}

func (c *CLI) authStatus(ctx context.Context) error <span class="cov0" title="0">{
        // Try to authenticate
        _, err := c.authMgr.Authenticate(ctx, c.keyPath)
        if err != nil </span><span class="cov0" title="0">{
                authErr := errors.ClassifyAuthError(err)
                payload := map[string]interface{}{
                        "authenticated": false,
                }
                if authErr != nil </span><span class="cov0" title="0">{
                        payload["error"] = authErr
                }</span> else<span class="cov0" title="0"> {
                        payload["error"] = err.Error()
                }</span>
                <span class="cov0" title="0">result := output.NewResult(payload)
                return c.Output(result.WithServices("auth"))</span>
        }

        <span class="cov0" title="0">status, err := c.authMgr.GetStatus(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeAuthFailure, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(status)
        return c.Output(result.WithServices("auth"))</span>
}

func (c *CLI) authCheck(ctx context.Context) error <span class="cov0" title="0">{
        // Authenticate first
        creds, err := c.authMgr.Authenticate(ctx, c.keyPath)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        // Get API client
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">checks := []*auth.PermissionCheck{}

        // Check Android Publisher API (edits)
        publisherSvc, err := client.AndroidPublisher()
        if err == nil &amp;&amp; c.packageName != "" </span><span class="cov0" title="0">{
                // Insert and immediately delete an edit to test permissions
                edit, err := publisherSvc.Edits.Insert(c.packageName, nil).Context(ctx).Do()
                check := &amp;auth.PermissionCheck{
                        Surface:  "edits",
                        TestCall: "edits.insert",
                }
                if err != nil </span><span class="cov0" title="0">{
                        check.HasAccess = false
                        check.Error = err.Error()
                }</span> else<span class="cov0" title="0"> {
                        check.HasAccess = true
                        // Clean up test edit
                        _ = publisherSvc.Edits.Delete(c.packageName, edit.Id).Context(ctx).Do()
                }</span>
                <span class="cov0" title="0">checks = append(checks, check)</span>
        }

        // Check Reviews API
        <span class="cov0" title="0">if publisherSvc != nil &amp;&amp; c.packageName != "" </span><span class="cov0" title="0">{
                _, err := publisherSvc.Reviews.List(c.packageName).Context(ctx).MaxResults(1).Do()
                check := &amp;auth.PermissionCheck{
                        Surface:  "reviews",
                        TestCall: "reviews.list",
                }
                if err != nil </span><span class="cov0" title="0">{
                        check.HasAccess = false
                        check.Error = err.Error()
                }</span> else<span class="cov0" title="0"> {
                        check.HasAccess = true
                }</span>
                <span class="cov0" title="0">checks = append(checks, check)</span>
        }

        // Check Play Reporting API
        <span class="cov0" title="0">reportingSvc, err := client.PlayReporting()
        if err == nil &amp;&amp; c.packageName != "" </span><span class="cov0" title="0">{
                // Note: This would require proper method call for reporting API
                check := &amp;auth.PermissionCheck{
                        Surface:  "reporting",
                        TestCall: "apps.fetchReleaseFilterOptions",
                }
                if reportingSvc != nil </span><span class="cov0" title="0">{
                        check.HasAccess = true // Simplified - actual implementation would make API call
                }</span> else<span class="cov0" title="0"> {
                        check.HasAccess = false
                        check.Error = "reporting service unavailable"
                }</span>
                <span class="cov0" title="0">checks = append(checks, check)</span>
        }

        // Determine overall validity
        <span class="cov0" title="0">valid := true
        for _, check := range checks </span><span class="cov0" title="0">{
                if !check.HasAccess </span><span class="cov0" title="0">{
                        valid = false
                        break</span>
                }
        }

        <span class="cov0" title="0">checkResult := &amp;auth.CheckResult{
                Valid:       valid,
                Origin:      creds.Origin.String(),
                Email:       creds.Email,
                Permissions: checks,
        }

        result := output.NewResult(checkResult)
        return c.Output(result.WithServices("androidpublisher", "playdeveloperreporting"))</span>
}

func (c *CLI) authLogout(_ context.Context) error <span class="cov0" title="0">{
        c.authMgr.Clear()

        result := output.NewResult(map[string]interface{}{
                "success": true,
                "message": "Credentials cleared",
        })
        return c.Output(result.WithServices("auth"))
}</span>

func (c *CLI) authDiagnose(ctx context.Context, refreshCheck bool) error <span class="cov0" title="0">{
        creds, err := c.authMgr.Authenticate(ctx, c.keyPath)
        if err != nil </span><span class="cov0" title="0">{
                authErr := errors.ClassifyAuthError(err)
                payload := map[string]interface{}{
                        "authenticated": false,
                }
                if authErr != nil </span><span class="cov0" title="0">{
                        payload["error"] = authErr
                }</span> else<span class="cov0" title="0"> {
                        payload["error"] = err.Error()
                }</span>
                <span class="cov0" title="0">result := output.NewResult(payload)
                return c.Output(result.WithServices("auth"))</span>
        }

        <span class="cov0" title="0">meta, _ := c.authMgr.LoadTokenMetadata(c.authMgr.GetActiveProfile())
        tokenLocation := c.authMgr.TokenLocation()

        token, tokenErr := creds.TokenSource.Token()
        tokenValid := tokenErr == nil &amp;&amp; token != nil &amp;&amp; token.Valid()
        tokenExpiry := ""
        if tokenErr == nil &amp;&amp; token != nil &amp;&amp; !token.Expiry.IsZero() </span><span class="cov0" title="0">{
                tokenExpiry = token.Expiry.Format(time.RFC3339)
        }</span>

        <span class="cov0" title="0">clientHash := ""
        clientLast4 := ""
        if meta != nil </span><span class="cov0" title="0">{
                clientHash = meta.ClientIDHash
                clientLast4 = meta.ClientIDLast4
        }</span>

        <span class="cov0" title="0">diagnostics := map[string]interface{}{
                "authenticated": true,
                "origin":        creds.Origin.String(),
                "email":         creds.Email,
                "keyPath":       creds.KeyPath,
                "tokenLocation": tokenLocation,
                "clientIdHash":  clientHash,
                "clientIdLast4": clientLast4,
                "scopes":        creds.Scopes,
                "tokenValid":    tokenValid,
                "tokenExpiry":   tokenExpiry,
        }

        if refreshCheck </span><span class="cov0" title="0">{
                refreshResult := map[string]interface{}{
                        "success": tokenErr == nil,
                }
                if tokenErr != nil </span><span class="cov0" title="0">{
                        if apiErr := errors.ClassifyAuthError(tokenErr); apiErr != nil </span><span class="cov0" title="0">{
                                refreshResult["error"] = apiErr
                        }</span> else<span class="cov0" title="0"> {
                                refreshResult["error"] = tokenErr.Error()
                        }</span>
                }
                <span class="cov0" title="0">diagnostics["refreshCheck"] = refreshResult</span>
        }

        <span class="cov0" title="0">result := output.NewResult(diagnostics)
        return c.Output(result.WithServices("auth"))</span>
}

func (c *CLI) authLogin(ctx context.Context, profile, clientID, clientSecret, flow string) error <span class="cov0" title="0">{
        if flow != "" &amp;&amp; flow != "device" </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError,
                        fmt.Sprintf("unsupported flow: %s", flow)).
                        WithHint("Supported flows: device"))
        }</span>
        <span class="cov0" title="0">if clientID == "" </span><span class="cov0" title="0">{
                clientID = config.GetEnvOAuthClientID()
        }</span>
        <span class="cov0" title="0">if clientSecret == "" </span><span class="cov0" title="0">{
                clientSecret = config.GetEnvOAuthClientSecret()
        }</span>
        <span class="cov0" title="0">if profile == "" </span><span class="cov0" title="0">{
                profile = "default"
        }</span>
        <span class="cov0" title="0">c.profile = profile
        c.authMgr.SetActiveProfile(profile)
        scopes := []string{
                auth.ScopeAndroidPublisher,
                auth.ScopePlayReporting,
                auth.ScopeGames,
                auth.ScopePlayIntegrity,
        }
        creds, err := c.authMgr.AuthenticateWithDeviceCode(ctx, clientID, clientSecret, scopes, c.stderr)
        if err != nil </span><span class="cov0" title="0">{
                if apiErr, ok := err.(*errors.APIError); ok </span><span class="cov0" title="0">{
                        return c.OutputError(apiErr)
                }</span>
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeAuthFailure, err.Error()))</span>
        }
        <span class="cov0" title="0">if err := c.setActiveProfile(profile); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err)
        }</span>
        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":  true,
                "profile":  profile,
                "origin":   creds.Origin.String(),
                "scopes":   creds.Scopes,
                "location": c.authMgr.TokenLocation(),
        })
        return c.Output(result.WithServices("auth"))</span>
}

func (c *CLI) authSwitch(_ context.Context, profile string) error <span class="cov0" title="0">{
        meta, err := c.authMgr.LoadTokenMetadata(profile)
        if err != nil || meta == nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeNotFound,
                        fmt.Sprintf("profile not found: %s", profile)).
                        WithHint("Use gpd auth list to see available profiles"))
        }</span>
        <span class="cov0" title="0">if err := c.setActiveProfile(profile); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err)
        }</span>
        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success": true,
                "profile": profile,
                "origin":  meta.Origin,
                "email":   meta.Email,
        })
        return c.Output(result.WithServices("auth"))</span>
}

func (c *CLI) authList(_ context.Context) error <span class="cov0" title="0">{
        profiles, err := c.authMgr.ListProfiles()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">sort.Slice(profiles, func(i, j int) bool </span><span class="cov0" title="0">{
                return profiles[i].Profile &lt; profiles[j].Profile
        }</span>)
        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "profiles":      profiles,
                "count":         len(profiles),
                "activeProfile": c.authMgr.GetActiveProfile(),
        })
        return c.Output(result.WithServices("auth"))</span>
}

func (c *CLI) setActiveProfile(profile string) *errors.APIError <span class="cov0" title="0">{
        if profile == "" </span><span class="cov0" title="0">{
                profile = "default"
        }</span>
        <span class="cov0" title="0">c.profile = profile
        c.authMgr.SetActiveProfile(profile)
        if c.config == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">c.config.ActiveProfile = profile
        if err := c.config.Save(); err != nil </span><span class="cov0" title="0">{
                return errors.NewAPIError(errors.CodeGeneralError, fmt.Sprintf("failed to save config: %v", err))
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package cli provides the main CLI framework for gpd.
package cli

import (
        "context"
        "fmt"
        "io"
        "os"
        "strings"
        "time"

        "github.com/spf13/cobra"

        "github.com/dl-alexandre/gpd/internal/api"
        "github.com/dl-alexandre/gpd/internal/auth"
        "github.com/dl-alexandre/gpd/internal/config"
        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
        "github.com/dl-alexandre/gpd/internal/storage"
        "github.com/dl-alexandre/gpd/pkg/version"
)

// CLI represents the main CLI application.
type CLI struct {
        rootCmd   *cobra.Command
        config    *config.Config
        authMgr   *auth.Manager
        apiClient *api.Client
        outputMgr *output.Manager
        stdout    io.Writer
        stderr    io.Writer
        startTime time.Time

        // Global flags
        packageName  string
        outputFormat string
        pretty       bool
        timeout      time.Duration
        storeTokens  string
        fields       string
        quiet        bool
        verbose      bool
        keyPath      string
        profile      string
}

// New creates a new CLI instance.
func New() *CLI <span class="cov10" title="18">{
        cli := &amp;CLI{
                stdout:    os.Stdout,
                stderr:    os.Stderr,
                startTime: time.Now(),
        }

        cli.outputMgr = output.NewManager(cli.stdout)

        // Initialize authentication manager with secure storage
        secureStorage := storage.New()
        cli.authMgr = auth.NewManager(secureStorage)

        cli.buildCommands()
        return cli
}</span>

// Execute runs the CLI.
func (c *CLI) Execute() int <span class="cov0" title="0">{
        if err := c.rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                return errors.ExitGeneralError
        }</span>
        <span class="cov0" title="0">return errors.ExitSuccess</span>
}

func (c *CLI) buildCommands() <span class="cov10" title="18">{
        c.rootCmd = &amp;cobra.Command{
                Use:   "gpd",
                Short: "Google Play Developer CLI",
                Long: `gpd is a fast, lightweight command-line interface for the Google Play Developer Console.

It provides programmatic access to Google Play Developer Console functionality
for automating Android app publishing and management tasks.`,
                SilenceUsage:  true,
                SilenceErrors: true,
                PersistentPreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov1" title="1">{
                        return c.setup(cmd)
                }</span>,
        }

        // Global flags
        <span class="cov10" title="18">pf := c.rootCmd.PersistentFlags()
        pf.StringVar(&amp;c.packageName, "package", "", "App package name")
        pf.StringVar(&amp;c.outputFormat, "output", "json", "Output format: json, table, markdown, csv (analytics/vitals only)")
        pf.BoolVar(&amp;c.pretty, "pretty", false, "Pretty print JSON output")
        pf.DurationVar(&amp;c.timeout, "timeout", 30*time.Second, "Network timeout")
        pf.StringVar(&amp;c.storeTokens, "store-tokens", "auto", "Token storage: auto, never, secure")
        pf.StringVar(&amp;c.fields, "fields", "", "JSON field projection (comma-separated paths)")
        pf.BoolVar(&amp;c.quiet, "quiet", false, "Suppress stderr except errors")
        pf.BoolVar(&amp;c.verbose, "verbose", false, "Verbose output")
        pf.StringVar(&amp;c.keyPath, "key", "", "Service account key file path")
        pf.StringVar(&amp;c.profile, "profile", "", "Authentication profile name")

        // Add command groups
        c.addVersionCommand()
        c.addAuthCommands()
        c.addConfigCommands()
        c.addAppsCommands()
        c.addPublishCommands()
        c.addCustomAppCommands()
        c.addMigrateCommands()
        c.addReviewsCommands()
        c.addPurchasesCommands()
        c.addAnalyticsCommands()
        c.addVitalsCommands()
        c.addMonetizationCommands()
        c.addPermissionsCommands()
        c.addGamesCommands()
        c.addGroupingCommands()
        c.addIntegrityCommands()
        c.addRecoveryCommands()
        c.addHelpCommands()</span>
}

func (c *CLI) setup(_ *cobra.Command) error <span class="cov4" title="3">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                cfg = config.DefaultConfig()
        }</span>
        <span class="cov4" title="3">c.config = cfg

        // Apply environment variable overrides
        if envPkg := config.GetEnvPackage(); envPkg != "" &amp;&amp; c.packageName == "" </span><span class="cov1" title="1">{
                c.packageName = envPkg
        }</span>
        <span class="cov4" title="3">if c.packageName == "" &amp;&amp; c.config.DefaultPackage != "" </span><span class="cov0" title="0">{
                c.packageName = c.config.DefaultPackage
        }</span>
        <span class="cov4" title="3">if envStore := config.GetEnvStoreTokens(); envStore != "" &amp;&amp; c.storeTokens == "auto" </span><span class="cov1" title="1">{
                c.storeTokens = envStore
        }</span>
        <span class="cov4" title="3">if c.storeTokens == "auto" &amp;&amp; c.config.StoreTokens != "" </span><span class="cov3" title="2">{
                c.storeTokens = c.config.StoreTokens
        }</span>
        <span class="cov4" title="3">if envProfile := config.GetEnvAuthProfile(); envProfile != "" &amp;&amp; c.profile == "" </span><span class="cov0" title="0">{
                c.profile = envProfile
        }</span>
        <span class="cov4" title="3">if c.profile == "" &amp;&amp; c.config.ActiveProfile != "" </span><span class="cov0" title="0">{
                c.profile = c.config.ActiveProfile
        }</span>
        <span class="cov4" title="3">c.authMgr.SetStoreTokens(c.storeTokens)
        c.authMgr.SetActiveProfile(c.profile)

        // Configure output manager
        c.outputMgr.SetFormat(output.ParseFormat(c.outputFormat))
        c.outputMgr.SetPretty(c.pretty)
        if c.fields != "" </span><span class="cov1" title="1">{
                c.outputMgr.SetFields(strings.Split(c.fields, ","))
        }</span>

        <span class="cov4" title="3">return nil</span>
}

// Output writes a result to stdout.
func (c *CLI) Output(r *output.Result) error <span class="cov1" title="1">{
        r.WithDuration(time.Since(c.startTime))
        return c.outputMgr.Write(r)
}</span>

// OutputError writes an error result.
func (c *CLI) OutputError(err *errors.APIError) error <span class="cov1" title="1">{
        r := output.NewErrorResult(err)
        r.WithDuration(time.Since(c.startTime))
        return c.outputMgr.Write(r)
}</span>

// getAPIClient lazily initializes and returns the API client.
func (c *CLI) getAPIClient(ctx context.Context) (*api.Client, error) <span class="cov0" title="0">{
        if c.apiClient != nil </span><span class="cov0" title="0">{
                return c.apiClient, nil
        }</span>

        // Authenticate first
        <span class="cov0" title="0">creds, err := c.authMgr.Authenticate(ctx, c.keyPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create API client
        <span class="cov0" title="0">client, err := api.NewClient(ctx, creds.TokenSource,
                api.WithTimeout(c.timeout),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewAPIError(errors.CodeGeneralError, fmt.Sprintf("failed to create API client: %v", err))
        }</span>

        <span class="cov0" title="0">c.apiClient = client
        return client, nil</span>
}

// requirePackage ensures a package name is provided.
func (c *CLI) requirePackage() error <span class="cov3" title="2">{
        if c.packageName == "" </span><span class="cov1" title="1">{
                return errors.ErrPackageRequired
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// addVersionCommand adds the version command.
func (c *CLI) addVersionCommand() <span class="cov10" title="18">{
        versionCmd := &amp;cobra.Command{
                Use:   "version",
                Short: "Print version information",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        info := version.Get()
                        result := output.NewResult(map[string]interface{}{
                                "version":   info.Version,
                                "gitCommit": info.GitCommit,
                                "buildTime": info.BuildTime,
                                "goVersion": info.GoVersion,
                                "platform":  info.Platform,
                        })
                        return c.Output(result.WithServices("version"))
                }</span>,
        }
        <span class="cov10" title="18">c.rootCmd.AddCommand(versionCmd)

        // Also add --version flag
        c.rootCmd.Version = version.Get().Short()
        c.rootCmd.SetVersionTemplate(`{{.Version}}
`)</span>
}

// addHelpCommands adds help-related commands.
func (c *CLI) addHelpCommands() <span class="cov10" title="18">{
        helpCmd := &amp;cobra.Command{
                Use:   "help [command]",
                Short: "Help about any command",
                Args:  cobra.ArbitraryArgs,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        root := cmd.Root()
                        if len(args) == 0 </span><span class="cov0" title="0">{
                                return root.Help()
                        }</span>
                        <span class="cov0" title="0">target, _, err := root.Find(args)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if target == nil </span><span class="cov0" title="0">{
                                return root.Help()
                        }</span>
                        <span class="cov0" title="0">target.InitDefaultHelpFlag()
                        return target.Help()</span>
                },
        }

        <span class="cov10" title="18">agentCmd := &amp;cobra.Command{
                Use:   "agent",
                Short: "AI agent quickstart guide",
                Long: `AI Agent Quickstart Guide for gpd

gpd is designed for programmatic access by AI agents and automation systems.

Key Features for AI Agents:
1. Minified JSON output by default (single-line)
2. Predictable exit codes for error handling
3. Explicit flags over interactive prompts
4. No browser-based authentication

Example Workflow:
  # Check authentication
  gpd auth status

  # Upload an artifact
  gpd publish upload app.aab --package com.example.app

  # Create a release
  gpd publish release --package com.example.app --track internal --status draft

  # Check release status
  gpd publish status --package com.example.app --track internal

Exit Codes:
  0 - Success
  1 - General API error
  2 - Authentication failure
  3 - Permission denied
  4 - Validation error
  5 - Rate limited
  6 - Network error
  7 - Not found
  8 - Conflict

Output Format:
  All responses follow the envelope structure: {data, error, meta}
  Use --pretty for human-readable JSON
  Use --output table for tabular output
`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov1" title="1">{
                        _, err := fmt.Fprintln(c.stdout, cmd.Long)
                        return err
                }</span>,
        }

        <span class="cov10" title="18">helpCmd.AddCommand(agentCmd)
        c.rootCmd.SetHelpCommand(helpCmd)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package cli provides config commands for gpd.
package cli

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "runtime"
        "strings"
        "time"

        "github.com/spf13/cobra"

        "github.com/dl-alexandre/gpd/internal/config"
        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
        "github.com/dl-alexandre/gpd/internal/storage"
)

func (c *CLI) addConfigCommands() <span class="cov10" title="18">{
        configCmd := &amp;cobra.Command{
                Use:   "config",
                Short: "Configuration commands",
                Long:  "Manage gpd configuration and system health.",
        }

        // config init
        initCmd := &amp;cobra.Command{
                Use:   "init",
                Short: "Initialize project configuration",
                Long:  "Scaffold config files, sample release-notes.json, assets/ layout, and .gitignore.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.configInit(cmd)
                }</span>,
        }

        // config doctor
        <span class="cov10" title="18">doctorCmd := &amp;cobra.Command{
                Use:   "doctor",
                Short: "Diagnose configuration and credential issues",
                Long:  "Check configuration, credentials, and system health.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.configDoctor(cmd)
                }</span>,
        }

        // config path
        <span class="cov10" title="18">pathCmd := &amp;cobra.Command{
                Use:   "path",
                Short: "Show configuration file locations",
                Long:  "Display the paths used for configuration and cache files.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.configPath(cmd)
                }</span>,
        }

        // config get
        <span class="cov10" title="18">getCmd := &amp;cobra.Command{
                Use:   "get [key]",
                Short: "Get a configuration value",
                Long:  "Get the value of a configuration key.",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.configGet(cmd, args[0])
                }</span>,
        }

        // config set
        <span class="cov10" title="18">setCmd := &amp;cobra.Command{
                Use:   "set [key] [value]",
                Short: "Set a configuration value",
                Long:  "Set a configuration key to a value.",
                Args:  cobra.ExactArgs(2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.configSet(cmd, args[0], args[1])
                }</span>,
        }

        // config print
        <span class="cov10" title="18">printCmd := &amp;cobra.Command{
                Use:     "print",
                Short:   "Print resolved configuration",
                Long:    "Print the fully resolved configuration showing precedence.",
                Aliases: []string{"show"},
        }
        printCmd.Flags().Bool("resolved", false, "Show precedence resolution")
        printCmd.RunE = func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                resolved, _ := cmd.Flags().GetBool("resolved")
                return c.configPrint(cmd, resolved)
        }</span>

        // config export
        <span class="cov10" title="18">var exportOutput string
        var exportIncludePaths bool
        exportCmd := &amp;cobra.Command{
                Use:   "export",
                Short: "Export configuration to file",
                Long:  "Export safe configuration values to a JSON file.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.configExport(cmd, exportOutput, exportIncludePaths)
                }</span>,
        }
        <span class="cov10" title="18">exportCmd.Flags().StringVarP(&amp;exportOutput, "output", "o", "gpd-config.json", "Output file path")
        exportCmd.Flags().BoolVar(&amp;exportIncludePaths, "include-paths", false, "Include serviceAccountKeyPath (warning: may be machine-specific)")

        // config import
        var importMerge bool
        importCmd := &amp;cobra.Command{
                Use:   "import &lt;file&gt;",
                Short: "Import configuration from file",
                Long:  "Import configuration values from a JSON file.",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.configImport(cmd, args[0], importMerge)
                }</span>,
        }
        <span class="cov10" title="18">importCmd.Flags().BoolVar(&amp;importMerge, "merge", true, "Merge with existing config (default: true, use --merge=false to replace)")

        // config completion
        completionCmd := &amp;cobra.Command{
                Use:   "completion [bash|zsh|fish]",
                Short: "Generate shell completion scripts",
                Long: `Generate shell completion scripts for gpd.

To load completions:

Bash:
  $ source &lt;(gpd config completion bash)

Zsh:
  $ source &lt;(gpd config completion zsh)

Fish:
  $ gpd config completion fish | source
`,
                Args:      cobra.ExactArgs(1),
                ValidArgs: []string{"bash", "zsh", "fish"},
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.configCompletion(cmd, args[0])
                }</span>,
        }

        <span class="cov10" title="18">configCmd.AddCommand(initCmd, doctorCmd, pathCmd, getCmd, setCmd, printCmd, exportCmd, importCmd, completionCmd)
        c.rootCmd.AddCommand(configCmd)</span>
}

func (c *CLI) configInit(_ *cobra.Command) error <span class="cov0" title="0">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">if err := config.InitProject(cwd); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">paths := config.GetPaths()
        result := output.NewResult(map[string]interface{}{
                "success":    true,
                "configDir":  paths.ConfigDir,
                "cacheDir":   paths.CacheDir,
                "configFile": paths.ConfigFile,
                "assetsDir":  filepath.Join(cwd, "assets"),
                "created": []string{
                        paths.ConfigFile,
                        filepath.Join(cwd, "release-notes.json"),
                        filepath.Join(cwd, "assets"),
                        filepath.Join(cwd, ".gitignore"),
                },
        })
        return c.Output(result.WithServices("config"))</span>
}

type doctorResult struct {
        issues []string
        check  map[string]interface{}
}

func checkCredentials(envKey, gacPath string, parsedConfig *config.Config, configLoaded bool) doctorResult <span class="cov0" title="0">{
        result := doctorResult{
                check: map[string]interface{}{},
        }
        credentialsChecks := result.check

        // Check envServiceAccountKey
        if envKey != "" </span><span class="cov0" title="0">{
                valid, reason, fields := validateServiceAccountJSON([]byte(envKey))
                entry := map[string]interface{}{
                        "set":   true,
                        "valid": valid,
                }
                if !valid </span><span class="cov0" title="0">{
                        entry["reason"] = reason
                        if len(fields) &gt; 0 </span><span class="cov0" title="0">{
                                entry["missingFields"] = fields
                        }</span>
                        <span class="cov0" title="0">result.issues = append(result.issues, "GPD_SERVICE_ACCOUNT_KEY is not a valid service account key")</span>
                }
                <span class="cov0" title="0">credentialsChecks["envServiceAccountKey"] = entry</span>
        } else<span class="cov0" title="0"> {
                credentialsChecks["envServiceAccountKey"] = map[string]interface{}{"set": false}
        }</span>

        // Check GOOGLE_APPLICATION_CREDENTIALS
        <span class="cov0" title="0">gacEntry := map[string]interface{}{"set": gacPath != ""}
        if gacPath != "" </span><span class="cov0" title="0">{
                gacEntry["path"] = gacPath
                if _, err := os.Stat(gacPath); err != nil </span><span class="cov0" title="0">{
                        gacEntry["exists"] = false
                        result.issues = append(result.issues, "GOOGLE_APPLICATION_CREDENTIALS points to a missing file")
                }</span> else<span class="cov0" title="0"> {
                        gacEntry["exists"] = true
                        data, err := os.ReadFile(gacPath)
                        if err != nil </span><span class="cov0" title="0">{
                                gacEntry["readable"] = false
                                result.issues = append(result.issues, "GOOGLE_APPLICATION_CREDENTIALS file is not readable")
                        }</span> else<span class="cov0" title="0"> {
                                valid, reason, fields := validateServiceAccountJSON(data)
                                gacEntry["readable"] = true
                                gacEntry["valid"] = valid
                                if !valid </span><span class="cov0" title="0">{
                                        gacEntry["reason"] = reason
                                        if len(fields) &gt; 0 </span><span class="cov0" title="0">{
                                                gacEntry["missingFields"] = fields
                                        }</span>
                                        <span class="cov0" title="0">result.issues = append(result.issues, "GOOGLE_APPLICATION_CREDENTIALS does not contain a valid service account key")</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">credentialsChecks["googleApplicationCredentials"] = gacEntry

        // Check serviceAccountKeyPath from config
        if configLoaded &amp;&amp; parsedConfig.ServiceAccountKeyPath != "" </span><span class="cov0" title="0">{
                keyEntry := map[string]interface{}{"path": parsedConfig.ServiceAccountKeyPath}
                if _, err := os.Stat(parsedConfig.ServiceAccountKeyPath); err != nil </span><span class="cov0" title="0">{
                        keyEntry["exists"] = false
                        result.issues = append(result.issues, "serviceAccountKeyPath points to a missing file")
                }</span> else<span class="cov0" title="0"> {
                        keyEntry["exists"] = true
                        data, err := os.ReadFile(parsedConfig.ServiceAccountKeyPath)
                        if err != nil </span><span class="cov0" title="0">{
                                keyEntry["readable"] = false
                                result.issues = append(result.issues, "serviceAccountKeyPath file is not readable")
                        }</span> else<span class="cov0" title="0"> {
                                valid, reason, fields := validateServiceAccountJSON(data)
                                keyEntry["readable"] = true
                                keyEntry["valid"] = valid
                                if !valid </span><span class="cov0" title="0">{
                                        keyEntry["reason"] = reason
                                        if len(fields) &gt; 0 </span><span class="cov0" title="0">{
                                                keyEntry["missingFields"] = fields
                                        }</span>
                                        <span class="cov0" title="0">result.issues = append(result.issues, "serviceAccountKeyPath does not contain a valid service account key")</span>
                                }
                        }
                }
                <span class="cov0" title="0">credentialsChecks["serviceAccountKeyPath"] = keyEntry</span>
        } else<span class="cov0" title="0"> {
                credentialsChecks["serviceAccountKeyPath"] = map[string]interface{}{"set": false}
        }</span>

        <span class="cov0" title="0">return result</span>
}

func checkConfigFile(path string) (config.Config, bool, doctorResult) <span class="cov0" title="0">{
        var parsedConfig config.Config
        result := doctorResult{
                check: map[string]interface{}{"path": path},
        }

        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                result.issues = append(result.issues, "Config file does not exist (run 'gpd config init')")
                result.check["exists"] = false
                return parsedConfig, false, result
        }</span>

        <span class="cov0" title="0">result.check["exists"] = true
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                result.issues = append(result.issues, "Config file is not readable")
                result.check["readable"] = false
                return parsedConfig, false, result
        }</span>

        <span class="cov0" title="0">result.check["readable"] = true
        if err := json.Unmarshal(data, &amp;parsedConfig); err != nil </span><span class="cov0" title="0">{
                result.issues = append(result.issues, "Config file contains invalid JSON")
                result.check["valid"] = false
                return parsedConfig, false, result
        }</span>

        <span class="cov0" title="0">result.check["valid"] = true
        return parsedConfig, true, result</span>
}

func (c *CLI) configDoctor(_ *cobra.Command) error <span class="cov0" title="0">{
        paths := config.GetPaths()
        issues := []string{}
        checks := map[string]interface{}{}

        // Check config directory
        if _, err := os.Stat(paths.ConfigDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                issues = append(issues, "Config directory does not exist")
                checks["configDir"] = map[string]interface{}{"exists": false, "path": paths.ConfigDir}
        }</span> else<span class="cov0" title="0"> {
                checks["configDir"] = map[string]interface{}{"exists": true, "path": paths.ConfigDir}
        }</span>

        // Check config file
        <span class="cov0" title="0">parsedConfig, configLoaded, configFileIssues := checkConfigFile(paths.ConfigFile)
        issues = append(issues, configFileIssues.issues...)
        checks["configFile"] = configFileIssues.check

        // Check cache directory
        if _, err := os.Stat(paths.CacheDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                checks["cacheDir"] = map[string]interface{}{"exists": false, "path": paths.CacheDir}
        }</span> else<span class="cov0" title="0"> {
                checks["cacheDir"] = map[string]interface{}{"exists": true, "path": paths.CacheDir}
        }</span>

        // Check secure storage
        <span class="cov0" title="0">secureStorage := storage.New()
        checks["secureStorage"] = map[string]interface{}{
                "available": secureStorage.Available(),
                "platform":  storage.Platform(),
        }
        if !secureStorage.Available() </span><span class="cov0" title="0">{
                issues = append(issues, "Secure storage not available on this platform")
        }</span>

        <span class="cov0" title="0">storeTokensValue := config.GetEnvStoreTokens()
        if storeTokensValue == "" &amp;&amp; configLoaded </span><span class="cov0" title="0">{
                storeTokensValue = parsedConfig.StoreTokens
        }</span>
        <span class="cov0" title="0">if storeTokensValue != "" </span><span class="cov0" title="0">{
                checks["storeTokens"] = map[string]interface{}{
                        "value":                  storeTokensValue,
                        "secureStorageAvailable": secureStorage.Available(),
                }
                if storeTokensValue == "secure" &amp;&amp; !secureStorage.Available() </span><span class="cov0" title="0">{
                        issues = append(issues, "Store tokens is set to secure but secure storage is unavailable")
                }</span>
        }

        // Check environment variables
        <span class="cov0" title="0">envChecks := map[string]interface{}{}
        envKey := config.GetEnvServiceAccountKey()
        if envKey != "" </span><span class="cov0" title="0">{
                envChecks["GPD_SERVICE_ACCOUNT_KEY"] = "set (value hidden)"
        }</span> else<span class="cov0" title="0"> {
                envChecks["GPD_SERVICE_ACCOUNT_KEY"] = "not set"
        }</span>
        <span class="cov0" title="0">if pkg := config.GetEnvPackage(); pkg != "" </span><span class="cov0" title="0">{
                envChecks["GPD_PACKAGE"] = pkg
        }</span> else<span class="cov0" title="0"> {
                envChecks["GPD_PACKAGE"] = "not set"
        }</span>
        <span class="cov0" title="0">gacPath := os.Getenv("GOOGLE_APPLICATION_CREDENTIALS")
        envChecks["GOOGLE_APPLICATION_CREDENTIALS"] = gacPath
        checks["environment"] = envChecks

        credentialsResult := checkCredentials(envKey, gacPath, &amp;parsedConfig, configLoaded)
        issues = append(issues, credentialsResult.issues...)
        checks["credentials"] = credentialsResult.check

        // Check CI detection
        checks["ci"] = map[string]interface{}{
                "detected": config.DetectCI(),
        }

        // Check for multiple gpd binaries
        binaries := findGPDBinaries()
        checks["binaries"] = binaries
        if len(binaries) &gt; 1 </span><span class="cov0" title="0">{
                issues = append(issues, fmt.Sprintf("Multiple gpd binaries found in PATH: %v", binaries))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "healthy": len(issues) == 0,
                "issues":  issues,
                "checks":  checks,
        })
        return c.Output(result.WithServices("config"))</span>
}

func findGPDBinaries() []string <span class="cov0" title="0">{
        binaries := []string{}
        pathEnv := os.Getenv("PATH")
        var separator string
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                separator = ";"
        }</span> else<span class="cov0" title="0"> {
                separator = ":"
        }</span>

        <span class="cov0" title="0">for _, dir := range strings.Split(pathEnv, separator) </span><span class="cov0" title="0">{
                gpdPath := filepath.Join(dir, "gpd")
                if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                        gpdPath = filepath.Join(dir, "gpd.exe")
                }</span>
                <span class="cov0" title="0">if _, err := os.Stat(gpdPath); err == nil </span><span class="cov0" title="0">{
                        binaries = append(binaries, gpdPath)
                }</span>
        }
        <span class="cov0" title="0">return binaries</span>
}

func validateServiceAccountJSON(data []byte) (valid bool, email string, scopes []string) <span class="cov0" title="0">{
        var keyData struct {
                Type        string `json:"type"`
                ClientEmail string `json:"client_email"`
                ClientID    string `json:"client_id"`
                PrivateKey  string `json:"private_key"`
                TokenURI    string `json:"token_uri"`
        }
        if err := json.Unmarshal(data, &amp;keyData); err != nil </span><span class="cov0" title="0">{
                return false, "invalid_json", nil
        }</span>
        <span class="cov0" title="0">if keyData.Type != "service_account" </span><span class="cov0" title="0">{
                return false, "invalid_type", nil
        }</span>
        <span class="cov0" title="0">missing := []string{}
        if keyData.ClientEmail == "" </span><span class="cov0" title="0">{
                missing = append(missing, "client_email")
        }</span>
        <span class="cov0" title="0">if keyData.ClientID == "" </span><span class="cov0" title="0">{
                missing = append(missing, "client_id")
        }</span>
        <span class="cov0" title="0">if keyData.PrivateKey == "" </span><span class="cov0" title="0">{
                missing = append(missing, "private_key")
        }</span>
        <span class="cov0" title="0">if keyData.TokenURI == "" </span><span class="cov0" title="0">{
                missing = append(missing, "token_uri")
        }</span>
        <span class="cov0" title="0">if len(missing) &gt; 0 </span><span class="cov0" title="0">{
                return false, "missing_fields", missing
        }</span>
        <span class="cov0" title="0">return true, "", nil</span>
}

func (c *CLI) configPath(_ *cobra.Command) error <span class="cov0" title="0">{
        paths := config.GetPaths()
        result := output.NewResult(map[string]interface{}{
                "configDir":  paths.ConfigDir,
                "cacheDir":   paths.CacheDir,
                "configFile": paths.ConfigFile,
                "legacyDir":  config.GetLegacyConfigDir(),
        })
        return c.Output(result.WithServices("config"))
}</span>

func (c *CLI) configGet(_ *cobra.Command, key string) error <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        // Convert config to map for key lookup
        <span class="cov0" title="0">data, _ := json.Marshal(cfg)
        var cfgMap map[string]interface{}
        if err := json.Unmarshal(data, &amp;cfgMap); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">value, ok := cfgMap[key]
        if !ok </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeNotFound, fmt.Sprintf("key not found: %s", key)))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "key":   key,
                "value": value,
        })
        return c.Output(result.WithServices("config"))</span>
}

func (c *CLI) configSet(_ *cobra.Command, key, value string) error <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                cfg = config.DefaultConfig()
        }</span>

        // Convert config to map for key setting
        <span class="cov0" title="0">data, _ := json.Marshal(cfg)
        var cfgMap map[string]interface{}
        if err := json.Unmarshal(data, &amp;cfgMap); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">cfgMap[key] = value

        // Convert back to config
        newData, _ := json.Marshal(cfgMap)
        if err := json.Unmarshal(newData, cfg); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">if err := cfg.Save(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "key":   key,
                "value": value,
                "saved": true,
        })
        return c.Output(result.WithServices("config"))</span>
}

func (c *CLI) configPrint(_ *cobra.Command, resolved bool) error <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                cfg = config.DefaultConfig()
        }</span>

        <span class="cov0" title="0">if resolved </span><span class="cov0" title="0">{
                // Show precedence resolution
                result := output.NewResult(map[string]interface{}{
                        "config": cfg,
                        "precedence": map[string]interface{}{
                                "1_flags":       "command-line flags",
                                "2_environment": "environment variables",
                                "3_config":      "configuration file",
                                "4_defaults":    "built-in defaults",
                        },
                        "resolved": map[string]interface{}{
                                "package":     c.packageName,
                                "output":      c.outputFormat,
                                "timeout":     c.timeout.String(),
                                "storeTokens": c.storeTokens,
                        },
                })
                return c.Output(result.WithServices("config"))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(cfg)
        return c.Output(result.WithServices("config"))</span>
}

func (c *CLI) configCompletion(_ *cobra.Command, shell string) error <span class="cov0" title="0">{
        var err error
        switch shell </span>{
        case "bash":<span class="cov0" title="0">
                err = c.rootCmd.GenBashCompletion(c.stdout)</span>
        case "zsh":<span class="cov0" title="0">
                err = c.rootCmd.GenZshCompletion(c.stdout)</span>
        case "fish":<span class="cov0" title="0">
                err = c.rootCmd.GenFishCompletion(c.stdout, true)</span>
        default:<span class="cov0" title="0">
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError,
                        fmt.Sprintf("unsupported shell: %s", shell)).
                        WithHint("Supported shells: bash, zsh, fish"))</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ConfigExport struct {
        Version    string                 `json:"version"`
        ExportedAt string                 `json:"exportedAt"`
        Config     map[string]interface{} `json:"config"`
        Metadata   map[string]interface{} `json:"metadata"`
}

func (c *CLI) configExport(_ *cobra.Command, outputPath string, includePaths bool) error <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to load config: %v", err)))
        }</span>

        <span class="cov0" title="0">exportData := map[string]interface{}{}
        warnings := []string{}

        if cfg.DefaultPackage != "" </span><span class="cov0" title="0">{
                exportData["defaultPackage"] = cfg.DefaultPackage
        }</span>
        <span class="cov0" title="0">if cfg.OutputFormat != "" </span><span class="cov0" title="0">{
                exportData["outputFormat"] = cfg.OutputFormat
        }</span>
        <span class="cov0" title="0">if cfg.TimeoutSeconds &gt; 0 </span><span class="cov0" title="0">{
                exportData["timeoutSeconds"] = cfg.TimeoutSeconds
        }</span>
        <span class="cov0" title="0">if cfg.StoreTokens != "" </span><span class="cov0" title="0">{
                exportData["storeTokens"] = cfg.StoreTokens
        }</span>
        <span class="cov0" title="0">if len(cfg.RateLimits) &gt; 0 </span><span class="cov0" title="0">{
                exportData["rateLimits"] = cfg.RateLimits
        }</span>
        <span class="cov0" title="0">if cfg.TesterLimits != nil </span><span class="cov0" title="0">{
                exportData["testerLimits"] = cfg.TesterLimits
        }</span>

        <span class="cov0" title="0">if cfg.ServiceAccountKeyPath != "" </span><span class="cov0" title="0">{
                if includePaths </span><span class="cov0" title="0">{
                        exportData["serviceAccountKeyPath"] = cfg.ServiceAccountKeyPath
                        warnings = append(warnings, "serviceAccountKeyPath included - may be machine-specific")
                }</span> else<span class="cov0" title="0"> {
                        warnings = append(warnings, "serviceAccountKeyPath not included - use --include-paths to export")
                }</span>
        }

        <span class="cov0" title="0">export := ConfigExport{
                Version:    "1.0",
                ExportedAt: time.Now().UTC().Format(time.RFC3339),
                Config:     exportData,
                Metadata: map[string]interface{}{
                        "platform":         runtime.GOOS,
                        "credentialOrigin": cfg.CredentialOrigin,
                        "warnings":         warnings,
                },
        }

        data, err := json.MarshalIndent(export, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to marshal config: %v", err)))
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(outputPath, data, 0600); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to write file: %v", err)))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":    true,
                "exported":   len(exportData),
                "outputPath": outputPath,
                "warnings":   warnings,
        })
        return c.Output(result)</span>
}

func (c *CLI) configImport(_ *cobra.Command, inputPath string, merge bool) error <span class="cov0" title="0">{
        data, err := os.ReadFile(inputPath)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError,
                        fmt.Sprintf("failed to read file: %v", err)))
        }</span>

        <span class="cov0" title="0">var importData ConfigExport
        if err := json.Unmarshal(data, &amp;importData); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError,
                        fmt.Sprintf("invalid config file: %v", err)).
                        WithHint("Expected JSON format from 'gpd config export'"))
        }</span>

        <span class="cov0" title="0">cfg := c.loadOrCreateConfig(merge)
        imported := c.applyImportedConfig(cfg, importData.Config)

        if err := cfg.Save(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to save config: %v", err)))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":  true,
                "imported": imported,
                "merge":    merge,
                "version":  importData.Version,
        })
        return c.Output(result)</span>
}

func (c *CLI) loadOrCreateConfig(merge bool) *config.Config <span class="cov0" title="0">{
        if merge </span><span class="cov0" title="0">{
                cfg, err := config.Load()
                if err == nil </span><span class="cov0" title="0">{
                        return cfg
                }</span>
        }
        <span class="cov0" title="0">return &amp;config.Config{}</span>
}

func (c *CLI) applyImportedConfig(cfg *config.Config, data map[string]interface{}) []string <span class="cov0" title="0">{
        imported := []string{}

        if val, ok := data["defaultPackage"].(string); ok &amp;&amp; val != "" </span><span class="cov0" title="0">{
                cfg.DefaultPackage = val
                imported = append(imported, "defaultPackage")
        }</span>
        <span class="cov0" title="0">if val, ok := data["outputFormat"].(string); ok &amp;&amp; val != "" </span><span class="cov0" title="0">{
                cfg.OutputFormat = val
                imported = append(imported, "outputFormat")
        }</span>
        <span class="cov0" title="0">if val, ok := data["timeoutSeconds"].(float64); ok &amp;&amp; val &gt; 0 </span><span class="cov0" title="0">{
                cfg.TimeoutSeconds = int(val)
                imported = append(imported, "timeoutSeconds")
        }</span>
        <span class="cov0" title="0">if val, ok := data["storeTokens"].(string); ok &amp;&amp; val != "" </span><span class="cov0" title="0">{
                cfg.StoreTokens = val
                imported = append(imported, "storeTokens")
        }</span>
        <span class="cov0" title="0">if val, ok := data["rateLimits"].(map[string]interface{}); ok &amp;&amp; len(val) &gt; 0 </span><span class="cov0" title="0">{
                cfg.RateLimits = c.parseRateLimits(val)
                imported = append(imported, "rateLimits")
        }</span>
        <span class="cov0" title="0">if val, ok := data["testerLimits"].(map[string]interface{}); ok &amp;&amp; len(val) &gt; 0 </span><span class="cov0" title="0">{
                cfg.TesterLimits = c.parseTesterLimits(val)
                imported = append(imported, "testerLimits")
        }</span>
        <span class="cov0" title="0">if val, ok := data["serviceAccountKeyPath"].(string); ok &amp;&amp; val != "" </span><span class="cov0" title="0">{
                cfg.ServiceAccountKeyPath = val
                imported = append(imported, "serviceAccountKeyPath")
        }</span>

        <span class="cov0" title="0">return imported</span>
}

func (c *CLI) parseRateLimits(val map[string]interface{}) map[string]string <span class="cov0" title="0">{
        rateLimits := make(map[string]string)
        for k, v := range val </span><span class="cov0" title="0">{
                if strVal, ok := v.(string); ok </span><span class="cov0" title="0">{
                        rateLimits[k] = strVal
                }</span>
        }
        <span class="cov0" title="0">return rateLimits</span>
}

func (c *CLI) parseTesterLimits(val map[string]interface{}) *config.TesterLimits <span class="cov0" title="0">{
        limits := config.DefaultTesterLimits()
        if internal, ok := val["internal"].(float64); ok </span><span class="cov0" title="0">{
                limits.Internal = int(internal)
        }</span>
        <span class="cov0" title="0">if alpha, ok := val["alpha"].(float64); ok </span><span class="cov0" title="0">{
                limits.Alpha = int(alpha)
        }</span>
        <span class="cov0" title="0">if beta, ok := val["beta"].(float64); ok </span><span class="cov0" title="0">{
                limits.Beta = int(beta)
        }</span>
        <span class="cov0" title="0">return limits</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package cli

import (
        "context"
        "os"
        "path/filepath"
        "strings"

        "github.com/spf13/cobra"
        "google.golang.org/api/playcustomapp/v1"

        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

func (c *CLI) addCustomAppCommands() <span class="cov10" title="18">{
        customAppCmd := &amp;cobra.Command{
                Use:   "customapp",
                Short: "Custom app publishing commands",
                Long:  "Create and publish custom apps via the Play Custom App Publishing API.",
        }

        var (
                accountID int64
                title     string
                language  string
                apkPath   string
                orgIDs    []string
        )

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "Create a custom app",
                Long:  "Create a custom app and upload an APK to publish it.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if accountID == 0 </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError, "--account is required")).
                                        WithServices("playcustomapp")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">if strings.TrimSpace(title) == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError, "--title is required")).
                                        WithServices("playcustomapp")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">if strings.TrimSpace(language) == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError, "--language is required")).
                                        WithServices("playcustomapp")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">if strings.TrimSpace(apkPath) == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError, "--apk is required")).
                                        WithServices("playcustomapp")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">if err := validateCustomAppAPK(apkPath); err != nil </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(err).WithServices("playcustomapp")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.customAppCreate(cmd.Context(), accountID, title, language, apkPath, orgIDs)</span>
                },
        }

        <span class="cov10" title="18">createCmd.Flags().Int64Var(&amp;accountID, "account", 0, "Developer account ID (required)")
        createCmd.Flags().StringVar(&amp;title, "title", "", "App title (required)")
        createCmd.Flags().StringVar(&amp;language, "language", "", "Default listing language (BCP 47, required)")
        createCmd.Flags().StringVar(&amp;apkPath, "apk", "", "Path to APK to upload (required)")
        createCmd.Flags().StringSliceVar(&amp;orgIDs, "org-id", nil, "Organization IDs to grant access")

        customAppCmd.AddCommand(createCmd)
        c.rootCmd.AddCommand(customAppCmd)</span>
}

func validateCustomAppAPK(filePath string) *errors.APIError <span class="cov5" title="4">{
        info, err := os.Stat(filePath)
        if err != nil </span><span class="cov1" title="1">{
                return errors.NewAPIError(errors.CodeValidationError, "file not found").
                        WithDetails(map[string]interface{}{"path": filePath})
        }</span>
        <span class="cov4" title="3">if info.IsDir() </span><span class="cov1" title="1">{
                return errors.NewAPIError(errors.CodeValidationError, "APK path is a directory").
                        WithDetails(map[string]interface{}{"path": filePath})
        }</span>
        <span class="cov3" title="2">if strings.ToLower(filepath.Ext(filePath)) != ".apk" </span><span class="cov1" title="1">{
                return errors.NewAPIError(errors.CodeValidationError, "custom app upload must be an APK").
                        WithHint("Provide a .apk file for --apk")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (c *CLI) getPlayCustomAppService(ctx context.Context) (*playcustomapp.Service, error) <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">svc, svcErr := client.PlayCustomApp()
        if svcErr != nil </span><span class="cov0" title="0">{
                return nil, errors.NewAPIError(errors.CodeGeneralError, svcErr.Error())
        }</span>
        <span class="cov0" title="0">return svc, nil</span>
}

func (c *CLI) customAppCreate(ctx context.Context, accountID int64, title, language, apkPath string, orgIDs []string) error <span class="cov0" title="0">{
        svc, err := c.getPlayCustomAppService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("playcustomapp")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">f, err := os.Open(apkPath)
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeGeneralError, err.Error())).
                        WithServices("playcustomapp")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">orgs := make([]*playcustomapp.Organization, 0, len(orgIDs))
        for _, orgID := range orgIDs </span><span class="cov0" title="0">{
                if strings.TrimSpace(orgID) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">orgs = append(orgs, &amp;playcustomapp.Organization{OrganizationId: orgID})</span>
        }

        <span class="cov0" title="0">customApp := &amp;playcustomapp.CustomApp{
                Title:        title,
                LanguageCode: language,
        }
        if len(orgs) &gt; 0 </span><span class="cov0" title="0">{
                customApp.Organizations = orgs
        }</span>

        <span class="cov0" title="0">resp, uploadErr := svc.Accounts.CustomApps.Create(accountID, customApp).Media(f).Context(ctx).Do()
        closeErr := f.Close()
        if uploadErr != nil </span><span class="cov0" title="0">{
                if closeErr != nil </span><span class="cov0" title="0">{
                        result := output.NewErrorResult(errors.NewAPIError(errors.CodeGeneralError, uploadErr.Error()).
                                WithDetails(map[string]interface{}{"closeError": closeErr.Error()})).
                                WithServices("playcustomapp")
                        return c.Output(result)
                }</span>
                <span class="cov0" title="0">result := output.NewErrorResult(errors.NewAPIError(errors.CodeGeneralError, uploadErr.Error())).
                        WithServices("playcustomapp")
                return c.Output(result)</span>
        }
        <span class="cov0" title="0">if closeErr != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeGeneralError, closeErr.Error())).
                        WithServices("playcustomapp")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">return c.Output(output.NewResult(resp).WithServices("playcustomapp"))</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package cli

import (
        "context"
        "fmt"
        "time"

        "github.com/spf13/cobra"

        "github.com/dl-alexandre/gpd/internal/edits"
        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

func (c *CLI) addEditCommands(publishCmd *cobra.Command) <span class="cov10" title="18">{
        editCmd := &amp;cobra.Command{
                Use:   "edit",
                Short: "Manage edit transactions",
                Long:  "Create, inspect, validate, commit, and delete edit transactions.",
        }

        editCreateCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "Create a new edit",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishEditCreate(cmd.Context())
                }</span>,
        }

        <span class="cov10" title="18">editListCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List cached edits",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishEditList(cmd.Context())
                }</span>,
        }

        <span class="cov10" title="18">editGetCmd := &amp;cobra.Command{
                Use:   "get &lt;edit-id&gt;",
                Short: "Get edit details",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishEditGet(cmd.Context(), args[0])
                }</span>,
        }

        <span class="cov10" title="18">var changesNotSentForReview bool
        editCommitCmd := &amp;cobra.Command{
                Use:   "commit &lt;edit-id&gt;",
                Short: "Commit an edit",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishEditCommit(cmd.Context(), args[0], changesNotSentForReview)
                }</span>,
        }
        <span class="cov10" title="18">editCommitCmd.Flags().BoolVar(&amp;changesNotSentForReview, "changes-not-sent-for-review", false, "Do not send changes for review")

        editValidateCmd := &amp;cobra.Command{
                Use:   "validate &lt;edit-id&gt;",
                Short: "Validate an edit",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishEditValidate(cmd.Context(), args[0])
                }</span>,
        }

        <span class="cov10" title="18">editDeleteCmd := &amp;cobra.Command{
                Use:   "delete &lt;edit-id&gt;",
                Short: "Delete an edit",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishEditDelete(cmd.Context(), args[0])
                }</span>,
        }

        <span class="cov10" title="18">editCmd.AddCommand(editCreateCmd, editListCmd, editGetCmd, editCommitCmd, editValidateCmd, editDeleteCmd)
        publishCmd.AddCommand(editCmd)</span>
}

func (c *CLI) publishEditCreate(ctx context.Context) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr := edits.NewManager()
        if err := editMgr.AcquireLock(ctx, c.packageName); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = editMgr.ReleaseLock(c.packageName) }</span>()

        <span class="cov0" title="0">apiEdit, err := publisher.Edits.Insert(c.packageName, nil).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to create edit: %v", err)))
        }</span>

        <span class="cov0" title="0">edit := &amp;edits.Edit{
                Handle:      apiEdit.Id,
                ServerID:    apiEdit.Id,
                PackageName: c.packageName,
                CreatedAt:   time.Now(),
                LastUsedAt:  time.Now(),
                State:       edits.StateDraft,
        }
        if err := editMgr.SaveEdit(edit); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "editId":     edit.ServerID,
                "package":    edit.PackageName,
                "createdAt":  edit.CreatedAt,
                "lastUsedAt": edit.LastUsedAt,
                "state":      edit.State,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) publishEditList(_ context.Context) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">editMgr := edits.NewManager()
        editsList, err := editMgr.ListEdits(c.packageName)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">now := time.Now()
        var results []map[string]interface{}
        for _, edit := range editsList </span><span class="cov0" title="0">{
                results = append(results, map[string]interface{}{
                        "editId":     edit.ServerID,
                        "handle":     edit.Handle,
                        "package":    edit.PackageName,
                        "createdAt":  edit.CreatedAt,
                        "lastUsedAt": edit.LastUsedAt,
                        "state":      edit.State,
                        "expired":    editMgr.IsEditExpired(edit, now),
                })
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "edits":   results,
                "count":   len(results),
                "package": c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) publishEditGet(ctx context.Context, editID string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr := edits.NewManager()
        serverID, local, err := c.resolveEdit(editMgr, editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">remote, err := publisher.Edits.Get(c.packageName, serverID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to get edit: %v", err)))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "editId":  serverID,
                "local":   local,
                "remote":  remote,
                "package": c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) publishEditCommit(ctx context.Context, editID string, changesNotSentForReview bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">editMgr := edits.NewManager()
        serverID, local, err := c.resolveEdit(editMgr, editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">contentID := serverID
        if local != nil </span><span class="cov0" title="0">{
                contentID = fmt.Sprintf("%s:%d", serverID, local.CreatedAt.Unix())
        }</span>
        <span class="cov0" title="0">idempotencyResult, idempotencyKey, _ := editMgr.Idempotent.CheckCommit(c.packageName, serverID, contentID)
        if idempotencyResult != nil &amp;&amp; idempotencyResult.Found </span><span class="cov0" title="0">{
                result := output.NewResult(map[string]interface{}{
                        "idempotent": true,
                        "editId":     serverID,
                        "package":    c.packageName,
                        "recordedAt": idempotencyResult.Timestamp,
                })
                return c.Output(result.WithNoOp("commit already completed").WithServices("androidpublisher"))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">commitCall := publisher.Edits.Commit(c.packageName, serverID).Context(ctx)
        if changesNotSentForReview </span><span class="cov0" title="0">{
                commitCall = commitCall.ChangesNotSentForReview(true)
        }</span>
        <span class="cov0" title="0">_, err = commitCall.Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to commit edit: %v", err)))
        }</span>

        <span class="cov0" title="0">_ = editMgr.Idempotent.RecordCommit(idempotencyKey, c.packageName, serverID)

        if local != nil </span><span class="cov0" title="0">{
                _, _ = editMgr.UpdateEditState(c.packageName, local.Handle, edits.StateCommitted)
                _ = editMgr.DeleteEdit(c.packageName, local.Handle)
        }</span>

        <span class="cov0" title="0">resultData := map[string]interface{}{
                "success": true,
                "editId":  serverID,
                "package": c.packageName,
        }
        if changesNotSentForReview </span><span class="cov0" title="0">{
                resultData["changesNotSentForReview"] = true
        }</span>
        <span class="cov0" title="0">result := output.NewResult(resultData)
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) publishEditValidate(ctx context.Context, editID string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr := edits.NewManager()
        serverID, local, err := c.resolveEdit(editMgr, editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">if local != nil </span><span class="cov0" title="0">{
                _, _ = editMgr.UpdateEditState(c.packageName, local.Handle, edits.StateValidating)
        }</span>

        <span class="cov0" title="0">_, err = publisher.Edits.Validate(c.packageName, serverID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to validate edit: %v", err)))
        }</span>

        <span class="cov0" title="0">if local != nil </span><span class="cov0" title="0">{
                _, _ = editMgr.UpdateEditState(c.packageName, local.Handle, edits.StateDraft)
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success": true,
                "editId":  serverID,
                "package": c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) publishEditDelete(ctx context.Context, editID string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr := edits.NewManager()
        serverID, local, err := c.resolveEdit(editMgr, editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">err = publisher.Edits.Delete(c.packageName, serverID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to delete edit: %v", err)))
        }</span>

        <span class="cov0" title="0">if local != nil </span><span class="cov0" title="0">{
                _, _ = editMgr.UpdateEditState(c.packageName, local.Handle, edits.StateAborted)
                _ = editMgr.DeleteEdit(c.packageName, local.Handle)
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success": true,
                "editId":  serverID,
                "package": c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) resolveEdit(editMgr *edits.Manager, editID string) (string, *edits.Edit, error) <span class="cov0" title="0">{
        local, err := editMgr.LoadEdit(c.packageName, editID)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, err
        }</span>
        <span class="cov0" title="0">if local != nil </span><span class="cov0" title="0">{
                if editMgr.IsEditExpired(local, time.Now()) </span><span class="cov0" title="0">{
                        return "", nil, errors.NewAPIError(errors.CodeConflict, "edit has expired")
                }</span>
                <span class="cov0" title="0">if local.ServerID != "" </span><span class="cov0" title="0">{
                        return local.ServerID, local, nil
                }</span>
        }
        <span class="cov0" title="0">return editID, local, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package cli

import (
        "context"
        "strings"

        "github.com/spf13/cobra"
        gamesmanagement "google.golang.org/api/gamesmanagement/v1management"

        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

func (c *CLI) addGamesCommands() <span class="cov10" title="18">{
        gamesCmd := &amp;cobra.Command{
                Use:   "games",
                Short: "Play Games Services management commands",
                Long:  "Manage Play Games Services including achievements, scores, events, and players.",
        }

        c.addAchievementsCommands(gamesCmd)
        c.addScoresCommands(gamesCmd)
        c.addEventsCommands(gamesCmd)
        c.addPlayersCommands(gamesCmd)
        c.addApplicationsCommands(gamesCmd)
        c.addGamesCapabilitiesCommand(gamesCmd)

        c.rootCmd.AddCommand(gamesCmd)
}</span>

func (c *CLI) addAchievementsCommands(parent *cobra.Command) <span class="cov10" title="18">{
        achievementsCmd := &amp;cobra.Command{
                Use:   "achievements",
                Short: "Manage game achievements",
                Long:  "Reset achievements for testing purposes. Requires Games scope.",
        }

        var (
                allPlayers     bool
                achievementIDs []string
        )

        resetCmd := &amp;cobra.Command{
                Use:   "reset [achievementId]",
                Short: "Reset an achievement",
                Long:  "Reset achievement progress for the currently authenticated player or all players.",
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if len(args) == 0 &amp;&amp; !allPlayers &amp;&amp; len(achievementIDs) == 0 </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "achievement ID required or use --all-players with no args to reset all")).
                                        WithServices("gamesmanagement")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">if len(achievementIDs) &gt; 0 &amp;&amp; allPlayers </span><span class="cov0" title="0">{
                                return c.gamesAchievementsResetMultipleForAllPlayers(cmd.Context(), achievementIDs)
                        }</span>
                        <span class="cov0" title="0">if len(args) &gt; 0 &amp;&amp; allPlayers </span><span class="cov0" title="0">{
                                return c.gamesAchievementsResetForAllPlayers(cmd.Context(), args[0])
                        }</span>
                        <span class="cov0" title="0">if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                return c.gamesAchievementsReset(cmd.Context(), args[0])
                        }</span>
                        <span class="cov0" title="0">return c.gamesAchievementsResetAll(cmd.Context(), allPlayers)</span>
                },
        }
        <span class="cov10" title="18">resetCmd.Flags().BoolVar(&amp;allPlayers, "all-players", false, "Reset for all players (requires admin)")
        resetCmd.Flags().StringSliceVar(&amp;achievementIDs, "ids", nil, "Multiple achievement IDs to reset (comma-separated)")

        achievementsCmd.AddCommand(resetCmd)
        parent.AddCommand(achievementsCmd)</span>
}

func (c *CLI) addScoresCommands(parent *cobra.Command) <span class="cov10" title="18">{
        scoresCmd := &amp;cobra.Command{
                Use:   "scores",
                Short: "Manage leaderboard scores",
                Long:  "Reset leaderboard scores for testing purposes. Requires Games scope.",
        }

        var (
                allPlayers     bool
                leaderboardIDs []string
        )

        resetCmd := &amp;cobra.Command{
                Use:   "reset [leaderboardId]",
                Short: "Reset scores on a leaderboard",
                Long:  "Reset scores for the currently authenticated player or all players.",
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if len(args) == 0 &amp;&amp; !allPlayers &amp;&amp; len(leaderboardIDs) == 0 </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "leaderboard ID required or use --all-players with no args to reset all")).
                                        WithServices("gamesmanagement")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">if len(leaderboardIDs) &gt; 0 &amp;&amp; allPlayers </span><span class="cov0" title="0">{
                                return c.gamesScoresResetMultipleForAllPlayers(cmd.Context(), leaderboardIDs)
                        }</span>
                        <span class="cov0" title="0">if len(args) &gt; 0 &amp;&amp; allPlayers </span><span class="cov0" title="0">{
                                return c.gamesScoresResetForAllPlayers(cmd.Context(), args[0])
                        }</span>
                        <span class="cov0" title="0">if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                return c.gamesScoresReset(cmd.Context(), args[0])
                        }</span>
                        <span class="cov0" title="0">return c.gamesScoresResetAll(cmd.Context(), allPlayers)</span>
                },
        }
        <span class="cov10" title="18">resetCmd.Flags().BoolVar(&amp;allPlayers, "all-players", false, "Reset for all players (requires admin)")
        resetCmd.Flags().StringSliceVar(&amp;leaderboardIDs, "ids", nil, "Multiple leaderboard IDs to reset (comma-separated)")

        scoresCmd.AddCommand(resetCmd)
        parent.AddCommand(scoresCmd)</span>
}

func (c *CLI) addEventsCommands(parent *cobra.Command) <span class="cov10" title="18">{
        eventsCmd := &amp;cobra.Command{
                Use:   "events",
                Short: "Manage game events",
                Long:  "Reset game events for testing purposes. Requires Games scope.",
        }

        var (
                allPlayers bool
                eventIDs   []string
        )

        resetCmd := &amp;cobra.Command{
                Use:   "reset [eventId]",
                Short: "Reset an event",
                Long:  "Reset event progress for the currently authenticated player or all players.",
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if len(args) == 0 &amp;&amp; !allPlayers &amp;&amp; len(eventIDs) == 0 </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "event ID required or use --all-players with no args to reset all")).
                                        WithServices("gamesmanagement")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">if len(eventIDs) &gt; 0 &amp;&amp; allPlayers </span><span class="cov0" title="0">{
                                return c.gamesEventsResetMultipleForAllPlayers(cmd.Context(), eventIDs)
                        }</span>
                        <span class="cov0" title="0">if len(args) &gt; 0 &amp;&amp; allPlayers </span><span class="cov0" title="0">{
                                return c.gamesEventsResetForAllPlayers(cmd.Context(), args[0])
                        }</span>
                        <span class="cov0" title="0">if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                return c.gamesEventsReset(cmd.Context(), args[0])
                        }</span>
                        <span class="cov0" title="0">return c.gamesEventsResetAll(cmd.Context(), allPlayers)</span>
                },
        }
        <span class="cov10" title="18">resetCmd.Flags().BoolVar(&amp;allPlayers, "all-players", false, "Reset for all players (requires admin)")
        resetCmd.Flags().StringSliceVar(&amp;eventIDs, "ids", nil, "Multiple event IDs to reset (comma-separated)")

        eventsCmd.AddCommand(resetCmd)
        parent.AddCommand(eventsCmd)</span>
}

func (c *CLI) addPlayersCommands(parent *cobra.Command) <span class="cov10" title="18">{
        playersCmd := &amp;cobra.Command{
                Use:   "players",
                Short: "Manage player visibility",
                Long:  "Hide or unhide players from leaderboards and social features.",
        }

        var applicationID string

        hideCmd := &amp;cobra.Command{
                Use:   "hide [playerId]",
                Short: "Hide a player",
                Long:  "Hide the given player's leaderboard scores from other players.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "playerId is required").WithHint("Usage: gpd games players hide &lt;playerId&gt;")).
                                        WithServices("gamesmanagement")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">if applicationID == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--application-id is required")).WithServices("gamesmanagement")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.gamesPlayersHide(cmd.Context(), applicationID, args[0])</span>
                },
        }
        <span class="cov10" title="18">hideCmd.Flags().StringVar(&amp;applicationID, "application-id", "", "Game application ID (required)")

        unhideCmd := &amp;cobra.Command{
                Use:   "unhide [playerId]",
                Short: "Unhide a player",
                Long:  "Unhide the given player's leaderboard scores from other players.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "playerId is required").WithHint("Usage: gpd games players unhide &lt;playerId&gt;")).
                                        WithServices("gamesmanagement")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">if applicationID == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--application-id is required")).WithServices("gamesmanagement")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.gamesPlayersUnhide(cmd.Context(), applicationID, args[0])</span>
                },
        }
        <span class="cov10" title="18">unhideCmd.Flags().StringVar(&amp;applicationID, "application-id", "", "Game application ID (required)")

        playersCmd.AddCommand(hideCmd, unhideCmd)
        parent.AddCommand(playersCmd)</span>
}

func (c *CLI) addApplicationsCommands(parent *cobra.Command) <span class="cov10" title="18">{
        applicationsCmd := &amp;cobra.Command{
                Use:   "applications",
                Short: "Manage game applications",
                Long:  "List hidden players for a game application.",
        }

        var (
                pageSize  int64
                pageToken string
                all       bool
        )

        listHiddenCmd := &amp;cobra.Command{
                Use:   "list-hidden [applicationId]",
                Short: "List hidden players",
                Long:  "Get the list of players hidden from the given game application.",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.gamesApplicationsListHidden(cmd.Context(), args[0], pageSize, pageToken, all)
                }</span>,
        }
        <span class="cov10" title="18">listHiddenCmd.Flags().Int64Var(&amp;pageSize, "page-size", 100, "Results per page")
        listHiddenCmd.Flags().StringVar(&amp;pageToken, "page-token", "", "Pagination token")
        addPaginationFlags(listHiddenCmd, &amp;all)

        applicationsCmd.AddCommand(listHiddenCmd)
        parent.AddCommand(applicationsCmd)</span>
}

func (c *CLI) addGamesCapabilitiesCommand(parent *cobra.Command) <span class="cov10" title="18">{
        capabilitiesCmd := &amp;cobra.Command{
                Use:   "capabilities",
                Short: "List Games management capabilities",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.gamesCapabilities(cmd.Context())
                }</span>,
        }
        <span class="cov10" title="18">parent.AddCommand(capabilitiesCmd)</span>
}

func (c *CLI) getGamesManagementService(ctx context.Context) (*gamesmanagement.Service, error) <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return client.GamesManagement()</span>
}

func (c *CLI) gamesAchievementsReset(ctx context.Context, achievementID string) error <span class="cov0" title="0">{
        svc, err := c.getGamesManagementService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("gamesmanagement")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">resp, err := svc.Achievements.Reset(achievementID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                apiErr := errors.ClassifyAuthError(err)
                if apiErr == nil </span><span class="cov0" title="0">{
                        apiErr = errors.NewAPIError(errors.CodeGeneralError, err.Error())
                }</span>
                <span class="cov0" title="0">if strings.Contains(apiErr.Message, "has not been used") || strings.Contains(apiErr.Message, "disabled") </span><span class="cov0" title="0">{
                        apiErr = apiErr.WithHint("Enable the Google Play Games Services Management API in Google Cloud Console and retry.")
                }</span>
                <span class="cov0" title="0">result := output.NewErrorResult(apiErr).WithServices("gamesmanagement")
                return c.Output(result)</span>
        }

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":        true,
                "achievementId":  achievementID,
                "kind":           resp.Kind,
                "currentState":   resp.CurrentState,
                "definitionId":   resp.DefinitionId,
                "updateOccurred": resp.UpdateOccurred,
        })
        return c.Output(result.WithServices("gamesmanagement"))</span>
}

func (c *CLI) gamesAchievementsResetAll(ctx context.Context, allPlayers bool) error <span class="cov0" title="0">{
        svc, err := c.getGamesManagementService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">if allPlayers </span><span class="cov0" title="0">{
                err := svc.Achievements.ResetAllForAllPlayers().Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
                }</span>
                <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                        "success":    true,
                        "operation":  "resetAllForAllPlayers",
                        "allPlayers": true,
                })
                return c.Output(result.WithServices("gamesmanagement"))</span>
        }

        <span class="cov0" title="0">resp, err := svc.Achievements.ResetAll().Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">var achievements []map[string]interface{}
        for _, a := range resp.Results </span><span class="cov0" title="0">{
                achievements = append(achievements, map[string]interface{}{
                        "kind":           a.Kind,
                        "currentState":   a.CurrentState,
                        "definitionId":   a.DefinitionId,
                        "updateOccurred": a.UpdateOccurred,
                })
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":      true,
                "kind":         resp.Kind,
                "achievements": achievements,
        })
        return c.Output(result.WithServices("gamesmanagement"))</span>
}

func (c *CLI) gamesAchievementsResetForAllPlayers(ctx context.Context, achievementID string) error <span class="cov0" title="0">{
        svc, err := c.getGamesManagementService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">err = svc.Achievements.ResetForAllPlayers(achievementID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":       true,
                "achievementId": achievementID,
                "allPlayers":    true,
        })
        return c.Output(result.WithServices("gamesmanagement"))</span>
}

func (c *CLI) gamesAchievementsResetMultipleForAllPlayers(ctx context.Context, achievementIDs []string) error <span class="cov0" title="0">{
        svc, err := c.getGamesManagementService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">req := &amp;gamesmanagement.AchievementResetMultipleForAllRequest{
                AchievementIds: achievementIDs,
        }

        err = svc.Achievements.ResetMultipleForAllPlayers(req).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":        true,
                "achievementIds": achievementIDs,
                "allPlayers":     true,
        })
        return c.Output(result.WithServices("gamesmanagement"))</span>
}

func (c *CLI) gamesScoresReset(ctx context.Context, leaderboardID string) error <span class="cov0" title="0">{
        svc, err := c.getGamesManagementService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("gamesmanagement")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">resp, err := svc.Scores.Reset(leaderboardID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                apiErr := errors.ClassifyAuthError(err)
                if apiErr == nil </span><span class="cov0" title="0">{
                        apiErr = errors.NewAPIError(errors.CodeGeneralError, err.Error())
                }</span>
                <span class="cov0" title="0">if strings.Contains(apiErr.Message, "has not been used") || strings.Contains(apiErr.Message, "disabled") </span><span class="cov0" title="0">{
                        apiErr = apiErr.WithHint("Enable the Google Play Games Services Management API in Google Cloud Console and retry.")
                }</span>
                <span class="cov0" title="0">result := output.NewErrorResult(apiErr).WithServices("gamesmanagement")
                return c.Output(result)</span>
        }

        <span class="cov0" title="0">var resetScoreTimeSpans []map[string]interface{}
        for _, ts := range resp.ResetScoreTimeSpans </span><span class="cov0" title="0">{
                resetScoreTimeSpans = append(resetScoreTimeSpans, map[string]interface{}{
                        "timeSpan": ts,
                })
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":             true,
                "leaderboardId":       leaderboardID,
                "kind":                resp.Kind,
                "definitionId":        resp.DefinitionId,
                "resetScoreTimeSpans": resetScoreTimeSpans,
        })
        return c.Output(result.WithServices("gamesmanagement"))</span>
}

func (c *CLI) gamesScoresResetAll(ctx context.Context, allPlayers bool) error <span class="cov0" title="0">{
        svc, err := c.getGamesManagementService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">if allPlayers </span><span class="cov0" title="0">{
                err := svc.Scores.ResetAllForAllPlayers().Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
                }</span>
                <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                        "success":    true,
                        "operation":  "resetAllForAllPlayers",
                        "allPlayers": true,
                })
                return c.Output(result.WithServices("gamesmanagement"))</span>
        }

        <span class="cov0" title="0">resp, err := svc.Scores.ResetAll().Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">var leaderboards []map[string]interface{}
        for _, l := range resp.Results </span><span class="cov0" title="0">{
                leaderboards = append(leaderboards, map[string]interface{}{
                        "kind":                l.Kind,
                        "definitionId":        l.DefinitionId,
                        "resetScoreTimeSpans": l.ResetScoreTimeSpans,
                })
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":      true,
                "kind":         resp.Kind,
                "leaderboards": leaderboards,
        })
        return c.Output(result.WithServices("gamesmanagement"))</span>
}

func (c *CLI) gamesScoresResetForAllPlayers(ctx context.Context, leaderboardID string) error <span class="cov0" title="0">{
        svc, err := c.getGamesManagementService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">err = svc.Scores.ResetForAllPlayers(leaderboardID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":       true,
                "leaderboardId": leaderboardID,
                "allPlayers":    true,
        })
        return c.Output(result.WithServices("gamesmanagement"))</span>
}

func (c *CLI) gamesScoresResetMultipleForAllPlayers(ctx context.Context, leaderboardIDs []string) error <span class="cov0" title="0">{
        svc, err := c.getGamesManagementService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">req := &amp;gamesmanagement.ScoresResetMultipleForAllRequest{
                LeaderboardIds: leaderboardIDs,
        }

        err = svc.Scores.ResetMultipleForAllPlayers(req).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":        true,
                "leaderboardIds": leaderboardIDs,
                "allPlayers":     true,
        })
        return c.Output(result.WithServices("gamesmanagement"))</span>
}

func (c *CLI) gamesEventsReset(ctx context.Context, eventID string) error <span class="cov0" title="0">{
        svc, err := c.getGamesManagementService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("gamesmanagement")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">err = svc.Events.Reset(eventID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                apiErr := errors.ClassifyAuthError(err)
                if apiErr == nil </span><span class="cov0" title="0">{
                        apiErr = errors.NewAPIError(errors.CodeGeneralError, err.Error())
                }</span>
                <span class="cov0" title="0">if strings.Contains(apiErr.Message, "has not been used") || strings.Contains(apiErr.Message, "disabled") </span><span class="cov0" title="0">{
                        apiErr = apiErr.WithHint("Enable the Google Play Games Services Management API in Google Cloud Console and retry.")
                }</span>
                <span class="cov0" title="0">result := output.NewErrorResult(apiErr).WithServices("gamesmanagement")
                return c.Output(result)</span>
        }

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success": true,
                "eventId": eventID,
        })
        return c.Output(result.WithServices("gamesmanagement"))</span>
}

func (c *CLI) gamesEventsResetAll(ctx context.Context, allPlayers bool) error <span class="cov0" title="0">{
        svc, err := c.getGamesManagementService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">if allPlayers </span><span class="cov0" title="0">{
                err := svc.Events.ResetAllForAllPlayers().Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
                }</span>
                <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                        "success":    true,
                        "operation":  "resetAllForAllPlayers",
                        "allPlayers": true,
                })
                return c.Output(result.WithServices("gamesmanagement"))</span>
        }

        <span class="cov0" title="0">err = svc.Events.ResetAll().Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success": true,
        })
        return c.Output(result.WithServices("gamesmanagement"))</span>
}

func (c *CLI) gamesEventsResetForAllPlayers(ctx context.Context, eventID string) error <span class="cov0" title="0">{
        svc, err := c.getGamesManagementService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">err = svc.Events.ResetForAllPlayers(eventID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":    true,
                "eventId":    eventID,
                "allPlayers": true,
        })
        return c.Output(result.WithServices("gamesmanagement"))</span>
}

func (c *CLI) gamesEventsResetMultipleForAllPlayers(ctx context.Context, eventIDs []string) error <span class="cov0" title="0">{
        svc, err := c.getGamesManagementService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">req := &amp;gamesmanagement.EventsResetMultipleForAllRequest{
                EventIds: eventIDs,
        }

        err = svc.Events.ResetMultipleForAllPlayers(req).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":    true,
                "eventIds":   eventIDs,
                "allPlayers": true,
        })
        return c.Output(result.WithServices("gamesmanagement"))</span>
}

func (c *CLI) gamesPlayersHide(ctx context.Context, applicationID, playerID string) error <span class="cov0" title="0">{
        svc, err := c.getGamesManagementService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">err = svc.Players.Hide(applicationID, playerID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":       true,
                "applicationId": applicationID,
                "playerId":      playerID,
                "hidden":        true,
        })
        return c.Output(result.WithServices("gamesmanagement"))</span>
}

func (c *CLI) gamesPlayersUnhide(ctx context.Context, applicationID, playerID string) error <span class="cov0" title="0">{
        svc, err := c.getGamesManagementService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">err = svc.Players.Unhide(applicationID, playerID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":       true,
                "applicationId": applicationID,
                "playerId":      playerID,
                "hidden":        false,
        })
        return c.Output(result.WithServices("gamesmanagement"))</span>
}

func (c *CLI) gamesApplicationsListHidden(ctx context.Context, applicationID string, pageSize int64, pageToken string, all bool) error <span class="cov0" title="0">{
        svc, err := c.getGamesManagementService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("gamesmanagement")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">req := svc.Applications.ListHidden(applicationID)
        if pageSize &gt; 0 </span><span class="cov0" title="0">{
                req = req.MaxResults(pageSize)
        }</span>
        <span class="cov0" title="0">if pageToken != "" </span><span class="cov0" title="0">{
                req = req.PageToken(pageToken)
        }</span>

        <span class="cov0" title="0">startToken := pageToken
        nextToken := ""
        var allPlayers []interface{}
        for </span><span class="cov0" title="0">{
                resp, err := req.Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        apiErr := errors.ClassifyAuthError(err)
                        if apiErr == nil </span><span class="cov0" title="0">{
                                apiErr = errors.NewAPIError(errors.CodeGeneralError, err.Error())
                        }</span>
                        <span class="cov0" title="0">if strings.Contains(apiErr.Message, "has not been used") || strings.Contains(apiErr.Message, "disabled") </span><span class="cov0" title="0">{
                                apiErr = apiErr.WithHint("Enable the Google Play Games Services Management API in Google Cloud Console and retry.")
                        }</span>
                        <span class="cov0" title="0">result := output.NewErrorResult(apiErr).WithServices("gamesmanagement")
                        return c.Output(result)</span>
                }

                <span class="cov0" title="0">for _, item := range resp.Items </span><span class="cov0" title="0">{
                        player := map[string]interface{}{
                                "kind":             item.Kind,
                                "hiddenTimeMillis": item.HiddenTimeMillis,
                        }
                        if item.Player != nil </span><span class="cov0" title="0">{
                                player["playerId"] = item.Player.PlayerId
                                player["displayName"] = item.Player.DisplayName
                                player["avatarImageUrl"] = item.Player.AvatarImageUrl
                                player["bannerUrlPortrait"] = item.Player.BannerUrlPortrait
                                player["bannerUrlLandscape"] = item.Player.BannerUrlLandscape
                        }</span>
                        <span class="cov0" title="0">allPlayers = append(allPlayers, player)</span>
                }

                <span class="cov0" title="0">nextToken = resp.NextPageToken
                if nextToken == "" || !all </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">req = req.PageToken(nextToken)</span>
        }

        <span class="cov0" title="0">result := output.NewResult(allPlayers)
        result.WithPagination(startToken, nextToken)
        return c.Output(result.WithServices("gamesmanagement"))</span>
}

func (c *CLI) gamesCapabilities(_ context.Context) error <span class="cov0" title="0">{
        result := output.NewResult(map[string]interface{}{
                "achievements": map[string]interface{}{
                        "operations": []string{
                                "reset",
                                "resetAll",
                                "resetForAllPlayers",
                                "resetAllForAllPlayers",
                                "resetMultipleForAllPlayers",
                        },
                        "flags": []string{
                                "--all-players: Reset for all players (admin only)",
                                "--ids: Multiple achievement IDs (comma-separated)",
                        },
                },
                "scores": map[string]interface{}{
                        "operations": []string{
                                "reset",
                                "resetAll",
                                "resetForAllPlayers",
                                "resetAllForAllPlayers",
                                "resetMultipleForAllPlayers",
                        },
                        "flags": []string{
                                "--all-players: Reset for all players (admin only)",
                                "--ids: Multiple leaderboard IDs (comma-separated)",
                        },
                },
                "events": map[string]interface{}{
                        "operations": []string{
                                "reset",
                                "resetAll",
                                "resetForAllPlayers",
                                "resetAllForAllPlayers",
                                "resetMultipleForAllPlayers",
                        },
                        "flags": []string{
                                "--all-players: Reset for all players (admin only)",
                                "--ids: Multiple event IDs (comma-separated)",
                        },
                },
                "players": map[string]interface{}{
                        "operations": []string{"hide", "unhide"},
                        "flags": []string{
                                "--application-id: Game application ID (required)",
                        },
                },
                "applications": map[string]interface{}{
                        "operations": []string{"list-hidden"},
                        "flags": []string{
                                "--page-size: Results per page",
                                "--page-token: Pagination token",
                                "--all: Fetch all pages",
                        },
                },
                "scope": "https://www.googleapis.com/auth/games",
                "notes": []string{
                        "Games Management API is for testing purposes",
                        "Most operations require the Games OAuth scope",
                        "--all-players operations require admin privileges",
                        "Reset operations clear progress for testing",
                },
        })
        return c.Output(result.WithServices("gamesmanagement"))
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package cli

import (
        "context"
        "strings"

        "github.com/spf13/cobra"
        "google.golang.org/api/games/v1"

        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

func (c *CLI) addGroupingCommands() <span class="cov10" title="18">{
        groupingCmd := &amp;cobra.Command{
                Use:   "grouping",
                Short: "Play Grouping API commands",
                Long:  "Generate Play Grouping API tokens via Play Games Services.",
        }

        var persona string
        var recallSessionID string

        tokenCmd := &amp;cobra.Command{
                Use:   "token",
                Short: "Generate a Play Grouping API token",
                Long:  "Generate a Play Grouping API token for the configured package.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                                return c.OutputError(err.(*errors.APIError))
                        }</span>
                        <span class="cov0" title="0">if strings.TrimSpace(persona) == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError, "--persona is required")).
                                        WithServices("games")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.groupingToken(cmd.Context(), c.packageName, persona)</span>
                },
        }
        <span class="cov10" title="18">tokenCmd.Flags().StringVar(&amp;persona, "persona", "", "Persona identifier for the user (required)")

        tokenRecallCmd := &amp;cobra.Command{
                Use:   "token-recall",
                Short: "Generate a Play Grouping API token using Recall",
                Long:  "Generate a Play Grouping API token for a Recall session.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                                return c.OutputError(err.(*errors.APIError))
                        }</span>
                        <span class="cov0" title="0">if strings.TrimSpace(persona) == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError, "--persona is required")).
                                        WithServices("games")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">if strings.TrimSpace(recallSessionID) == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError, "--recall-session-id is required")).
                                        WithServices("games")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.groupingTokenRecall(cmd.Context(), c.packageName, persona, recallSessionID)</span>
                },
        }
        <span class="cov10" title="18">tokenRecallCmd.Flags().StringVar(&amp;persona, "persona", "", "Persona identifier for the user (required)")
        tokenRecallCmd.Flags().StringVar(&amp;recallSessionID, "recall-session-id", "", "Recall session ID (required)")

        groupingCmd.AddCommand(tokenCmd, tokenRecallCmd)
        c.rootCmd.AddCommand(groupingCmd)</span>
}

func (c *CLI) getGamesService(ctx context.Context) (*games.Service, error) <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">svc, svcErr := client.Games()
        if svcErr != nil </span><span class="cov0" title="0">{
                return nil, errors.NewAPIError(errors.CodeGeneralError, svcErr.Error())
        }</span>
        <span class="cov0" title="0">return svc, nil</span>
}

func (c *CLI) groupingToken(ctx context.Context, packageName, persona string) error <span class="cov0" title="0">{
        svc, err := c.getGamesService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("games")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">resp, err := svc.Accesstokens.GeneratePlayGroupingApiToken().
                PackageName(packageName).
                Persona(persona).
                Context(ctx).
                Do()
        if err != nil </span><span class="cov0" title="0">{
                apiErr := errors.ClassifyAuthError(err)
                if apiErr == nil </span><span class="cov0" title="0">{
                        apiErr = errors.NewAPIError(errors.CodeGeneralError, err.Error())
                }</span>
                <span class="cov0" title="0">if strings.Contains(apiErr.Message, "has not been used") || strings.Contains(apiErr.Message, "disabled") </span><span class="cov0" title="0">{
                        apiErr = apiErr.WithHint("Enable the Google Play Games Services API in Google Cloud Console and retry.")
                }</span>
                <span class="cov0" title="0">result := output.NewErrorResult(apiErr).WithServices("games")
                return c.Output(result)</span>
        }

        <span class="cov0" title="0">return c.Output(output.NewResult(resp).WithServices("games"))</span>
}

func (c *CLI) groupingTokenRecall(ctx context.Context, packageName, persona, recallSessionID string) error <span class="cov0" title="0">{
        svc, err := c.getGamesService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("games")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">resp, err := svc.Accesstokens.GenerateRecallPlayGroupingApiToken().
                PackageName(packageName).
                Persona(persona).
                RecallSessionId(recallSessionID).
                Context(ctx).
                Do()
        if err != nil </span><span class="cov0" title="0">{
                apiErr := errors.ClassifyAuthError(err)
                if apiErr == nil </span><span class="cov0" title="0">{
                        apiErr = errors.NewAPIError(errors.CodeGeneralError, err.Error())
                }</span>
                <span class="cov0" title="0">if strings.Contains(apiErr.Message, "has not been used") || strings.Contains(apiErr.Message, "disabled") </span><span class="cov0" title="0">{
                        apiErr = apiErr.WithHint("Enable the Google Play Games Services API in Google Cloud Console and retry.")
                }</span>
                <span class="cov0" title="0">result := output.NewErrorResult(apiErr).WithServices("games")
                return c.Output(result)</span>
        }

        <span class="cov0" title="0">return c.Output(output.NewResult(resp).WithServices("games"))</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package cli

import (
        "context"
        "os"
        "strings"

        "github.com/spf13/cobra"
        "google.golang.org/api/playintegrity/v1"

        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

func (c *CLI) addIntegrityCommands() <span class="cov10" title="18">{
        integrityCmd := &amp;cobra.Command{
                Use:   "integrity",
                Short: "Play Integrity API commands",
                Long:  "Decode Play Integrity tokens and inspect integrity payloads.",
        }

        var token string
        var tokenFile string

        decodeCmd := &amp;cobra.Command{
                Use:   "decode",
                Short: "Decode a Play Integrity token",
                Long:  "Decode a standard Play Integrity token for the configured package.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("playintegrity")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">tokenValue, err := resolveTokenInput(token, tokenFile)
                        if err != nil </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(err).WithServices("playintegrity")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.integrityDecode(cmd.Context(), c.packageName, tokenValue)</span>
                },
        }
        <span class="cov10" title="18">decodeCmd.Flags().StringVar(&amp;token, "token", "", "Integrity token value")
        decodeCmd.Flags().StringVar(&amp;tokenFile, "token-file", "", "File containing the integrity token")

        integrityCmd.AddCommand(decodeCmd)
        c.rootCmd.AddCommand(integrityCmd)</span>
}

func resolveTokenInput(token, tokenFile string) (string, *errors.APIError) <span class="cov6" title="6">{
        if token != "" &amp;&amp; tokenFile != "" </span><span class="cov1" title="1">{
                return "", errors.NewAPIError(errors.CodeValidationError, "provide --token or --token-file, not both")
        }</span>
        <span class="cov6" title="5">if token != "" </span><span class="cov3" title="2">{
                value := strings.TrimSpace(token)
                if value == "" </span><span class="cov1" title="1">{
                        return "", errors.NewAPIError(errors.CodeValidationError, "integrity token is required").
                                WithHint("Provide a non-empty value for --token")
                }</span>
                <span class="cov1" title="1">return value, nil</span>
        }
        <span class="cov4" title="3">if tokenFile == "" </span><span class="cov0" title="0">{
                return "", errors.NewAPIError(errors.CodeValidationError, "integrity token is required").
                        WithHint("Provide --token or --token-file")
        }</span>
        <span class="cov4" title="3">data, err := os.ReadFile(tokenFile)
        if err != nil </span><span class="cov1" title="1">{
                return "", errors.NewAPIError(errors.CodeValidationError, "failed to read token file").
                        WithDetails(map[string]interface{}{"path": tokenFile, "error": err.Error()})
        }</span>
        <span class="cov3" title="2">value := strings.TrimSpace(string(data))
        if value == "" </span><span class="cov1" title="1">{
                return "", errors.NewAPIError(errors.CodeValidationError, "token file is empty").
                        WithDetails(map[string]interface{}{"path": tokenFile})
        }</span>
        <span class="cov1" title="1">return value, nil</span>
}

func (c *CLI) getPlayIntegrityService(ctx context.Context) (*playintegrity.Service, error) <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">svc, svcErr := client.PlayIntegrity()
        if svcErr != nil </span><span class="cov0" title="0">{
                return nil, errors.NewAPIError(errors.CodeGeneralError, svcErr.Error())
        }</span>
        <span class="cov0" title="0">return svc, nil</span>
}

func (c *CLI) integrityDecode(ctx context.Context, packageName, token string) error <span class="cov0" title="0">{
        svc, err := c.getPlayIntegrityService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">resp, err := svc.V1.DecodeIntegrityToken(packageName, &amp;playintegrity.DecodeIntegrityTokenRequest{
                IntegrityToken: token,
        }).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                apiErr := errors.ClassifyAuthError(err)
                if apiErr == nil </span><span class="cov0" title="0">{
                        apiErr = errors.NewAPIError(errors.CodeGeneralError, err.Error())
                }</span>
                <span class="cov0" title="0">if strings.Contains(apiErr.Message, "SERVICE_DISABLED") || strings.Contains(apiErr.Message, "accessNotConfigured") ||
                        strings.Contains(apiErr.Message, "has not been used") || strings.Contains(apiErr.Message, "disabled") </span><span class="cov0" title="0">{
                        apiErr = apiErr.WithHint("Enable the Play Integrity API in Google Cloud Console and retry.")
                }</span>
                <span class="cov0" title="0">result := output.NewErrorResult(apiErr).WithServices("playintegrity")
                return c.Output(result)</span>
        }

        <span class="cov0" title="0">return c.Output(output.NewResult(resp).WithServices("playintegrity"))</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package cli

import "github.com/spf13/cobra"

func (c *CLI) addMigrateCommands() <span class="cov10" title="18">{
        migrateCmd := &amp;cobra.Command{
                Use:   "migrate",
                Short: "Migrate metadata between formats",
                Long:  "Migrate metadata between external CI/CD formats and Google Play.",
        }

        c.addMigrateFastlaneCommands(migrateCmd)
        c.rootCmd.AddCommand(migrateCmd)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package cli

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "os"
        "path"
        "path/filepath"
        "sort"
        "strconv"
        "strings"

        "google.golang.org/api/androidpublisher/v3"

        "github.com/spf13/cobra"

        "github.com/dl-alexandre/gpd/internal/config"
        "github.com/dl-alexandre/gpd/internal/edits"
        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/logging"
        "github.com/dl-alexandre/gpd/internal/migrate"
        "github.com/dl-alexandre/gpd/internal/migrate/fastlane"
        "github.com/dl-alexandre/gpd/internal/output"
)

var fastlaneImageTypes = []string{
        fastlaneImageIcon,
        fastlaneImageFeatureGraphic,
        fastlaneImagePromoGraphic,
        fastlaneImageTvBanner,
        fastlaneImagePhoneScreenshots,
        fastlaneImageTabletScreenshots,
        fastlaneImageSevenInchScreenshots,
        fastlaneImageTenInchScreenshots,
        fastlaneImageTvScreenshots,
        fastlaneImageWearScreenshots,
}

var fastlaneSingleImageTypes = map[string]bool{
        fastlaneImageIcon:           true,
        fastlaneImageFeatureGraphic: true,
        fastlaneImagePromoGraphic:   true,
        fastlaneImageTvBanner:       true,
}

var fastlaneImageTypeSet = map[string]bool{
        fastlaneImageIcon:                 true,
        fastlaneImageFeatureGraphic:       true,
        fastlaneImagePromoGraphic:         true,
        fastlaneImageTvBanner:             true,
        fastlaneImagePhoneScreenshots:     true,
        fastlaneImageTabletScreenshots:    true,
        fastlaneImageSevenInchScreenshots: true,
        fastlaneImageTenInchScreenshots:   true,
        fastlaneImageTvScreenshots:        true,
        fastlaneImageWearScreenshots:      true,
}

const (
        fastlaneMetadataDir               = "fastlane/metadata/android"
        fastlaneImageIcon                 = "icon"
        fastlaneImageFeatureGraphic       = "featureGraphic"
        fastlaneImagePromoGraphic         = "promoGraphic"
        fastlaneImageTvBanner             = "tvBanner"
        fastlaneImagePhoneScreenshots     = "phoneScreenshots"
        fastlaneImageTabletScreenshots    = "tabletScreenshots"
        fastlaneImageSevenInchScreenshots = "sevenInchScreenshots"
        fastlaneImageTenInchScreenshots   = "tenInchScreenshots"
        fastlaneImageTvScreenshots        = "tvScreenshots"
        fastlaneImageWearScreenshots      = "wearScreenshots"
)

type changelogSet struct {
        defaultText string
        hasDefault  bool
        byVersion   map[int64]string
}

func (c *CLI) addMigrateFastlaneCommands(migrateCmd *cobra.Command) <span class="cov10" title="18">{
        fastlaneCmd := &amp;cobra.Command{
                Use:   "fastlane",
                Short: "Fastlane supply format migration",
                Long:  "Migrate metadata between fastlane supply format and Google Play.",
        }

        var validateDir string
        validateCmd := &amp;cobra.Command{
                Use:   "validate",
                Short: "Validate fastlane metadata",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.migrateFastlaneValidate(cmd.Context(), validateDir)
                }</span>,
        }
        <span class="cov10" title="18">validateCmd.Flags().StringVar(&amp;validateDir, "dir", fastlaneMetadataDir, "Fastlane metadata directory")

        var (
                exportDir     string
                includeImages bool
                locales       []string
        )
        exportCmd := &amp;cobra.Command{
                Use:   "export",
                Short: "Export metadata to fastlane format",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.migrateFastlaneExport(cmd.Context(), exportDir, includeImages, locales)
                }</span>,
        }
        <span class="cov10" title="18">exportCmd.Flags().StringVar(&amp;exportDir, "output", fastlaneMetadataDir, "Output directory")
        exportCmd.Flags().BoolVar(&amp;includeImages, "include-images", false, "Download and write images")
        exportCmd.Flags().StringSliceVar(&amp;locales, "locales", nil, "Locales to export (comma-separated)")

        var (
                importDir     string
                skipImages    bool
                replaceImages bool
                syncImages    bool
                editID        string
                noAutoCommit  bool
                dryRun        bool
        )
        importCmd := &amp;cobra.Command{
                Use:   "import",
                Short: "Import metadata from fastlane format",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.migrateFastlaneImport(cmd.Context(), importDir, skipImages, replaceImages, syncImages, editID, noAutoCommit, dryRun)
                }</span>,
        }
        <span class="cov10" title="18">importCmd.Flags().StringVar(&amp;importDir, "dir", fastlaneMetadataDir, "Fastlane metadata directory")
        importCmd.Flags().BoolVar(&amp;skipImages, "skip-images", false, "Skip uploading images")
        importCmd.Flags().BoolVar(&amp;replaceImages, "replace-images", false, "Delete existing images before upload")
        importCmd.Flags().BoolVar(&amp;syncImages, "sync-images", false, "Skip uploading images that already exist")
        importCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")
        importCmd.Flags().BoolVar(&amp;noAutoCommit, "no-auto-commit", false, "Keep edit open for manual commit")
        importCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show intended actions without executing")

        fastlaneCmd.AddCommand(validateCmd, exportCmd, importCmd)
        migrateCmd.AddCommand(fastlaneCmd)</span>
}

func (c *CLI) migrateFastlaneValidate(_ context.Context, dir string) error <span class="cov0" title="0">{
        dir = strings.TrimSpace(dir)
        if dir == "" </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError, "dir is required").
                        WithHint("Provide --dir or use the default fastlane/metadata/android structure"))
                return c.Output(result.WithServices("migrate"))
        }</span>

        <span class="cov0" title="0">metadata, err := fastlane.ParseDirectory(dir)
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError, err.Error()).
                        WithHint("Ensure the fastlane metadata directory exists (fastlane/metadata/android) or use --dir"))
                return c.Output(result.WithServices("migrate"))
        }</span>
        <span class="cov0" title="0">if len(metadata) == 0 </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError, "no locale directories found").
                        WithHint("Fastlane metadata should include locale folders like fastlane/metadata/android/en-US"))
                return c.Output(result.WithServices("migrate"))
        }</span>

        <span class="cov0" title="0">var allErrors []migrate.ValidationError
        locales := make([]string, 0, len(metadata))
        for i := range metadata </span><span class="cov0" title="0">{
                meta := &amp;metadata[i]
                locales = append(locales, meta.Locale)
                errs := fastlane.ValidateLocale(meta)
                if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                        allErrors = append(allErrors, errs...)
                }</span>
        }
        <span class="cov0" title="0">sort.Strings(locales)

        result := output.NewResult(map[string]interface{}{
                "dir":         dir,
                "valid":       len(allErrors) == 0,
                "errors":      allErrors,
                "locales":     locales,
                "localeCount": len(locales),
        })
        return c.Output(result.WithServices("migrate"))</span>
}

func (c *CLI) migrateFastlaneExport(ctx context.Context, outputDir string, includeImages bool, locales []string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">outputDir = strings.TrimSpace(outputDir)
        if outputDir == "" </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError, "output directory is required"))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">edit, err := publisher.Edits.Insert(c.packageName, nil).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, fmt.Sprintf("failed to create edit: %v", err)))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := publisher.Edits.Delete(c.packageName, edit.Id).Context(ctx).Do(); err != nil </span><span class="cov0" title="0">{
                        logging.Warn("failed to delete edit", logging.String("package", c.packageName), logging.String("editId", edit.Id), logging.Err(err))
                }</span>
        }()

        <span class="cov0" title="0">listings, err := publisher.Edits.Listings.List(c.packageName, edit.Id).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">filter := normalizeLocaleFilter(locales)
        var metadata []fastlane.LocaleMetadata
        for _, listing := range listings.Listings </span><span class="cov0" title="0">{
                locale := config.NormalizeLocale(listing.Language)
                if filter != nil &amp;&amp; !filter[locale] </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">meta := fastlane.LocaleMetadata{
                        Locale:              locale,
                        Title:               listing.Title,
                        TitleSet:            true,
                        ShortDescription:    listing.ShortDescription,
                        ShortDescriptionSet: true,
                        FullDescription:     listing.FullDescription,
                        FullDescriptionSet:  true,
                }
                if listing.Video != "" </span><span class="cov0" title="0">{
                        meta.Video = listing.Video
                        meta.VideoSet = true
                }</span>
                <span class="cov0" title="0">metadata = append(metadata, meta)</span>
        }
        <span class="cov0" title="0">if len(metadata) == 0 </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError, "no listings found for export"))
        }</span>

        <span class="cov0" title="0">localeSet := map[string]bool{}
        for i := range metadata </span><span class="cov0" title="0">{
                localeSet[metadata[i].Locale] = true
        }</span>
        <span class="cov0" title="0">changelogs, apiErr := c.exportFastlaneChangelogs(ctx, publisher, edit.Id, localeSet)
        if apiErr != nil </span><span class="cov0" title="0">{
                return c.OutputError(apiErr)
        }</span>
        <span class="cov0" title="0">if len(changelogs) &gt; 0 </span><span class="cov0" title="0">{
                for i := range metadata </span><span class="cov0" title="0">{
                        if notes, ok := changelogs[metadata[i].Locale]; ok &amp;&amp; len(notes) &gt; 0 </span><span class="cov0" title="0">{
                                metadata[i].Changelogs = notes
                        }</span>
                }
        }

        <span class="cov0" title="0">if err := fastlane.WriteDirectory(outputDir, metadata); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">warnings := []string{}
        imagesOutput := map[string]map[string]int{}
        if includeImages </span><span class="cov0" title="0">{
                httpClient := &amp;http.Client{Timeout: c.timeout}
                for i := range metadata </span><span class="cov0" title="0">{
                        locale := metadata[i].Locale
                        counts, warns := c.exportFastlaneImages(ctx, publisher, edit.Id, outputDir, locale, httpClient)
                        if len(warns) &gt; 0 </span><span class="cov0" title="0">{
                                warnings = append(warnings, warns...)
                        }</span>
                        <span class="cov0" title="0">if len(counts) &gt; 0 </span><span class="cov0" title="0">{
                                imagesOutput[locale] = counts
                        }</span>
                }
        }

        <span class="cov0" title="0">localesList := make([]string, 0, len(metadata))
        for i := range metadata </span><span class="cov0" title="0">{
                localesList = append(localesList, metadata[i].Locale)
        }</span>
        <span class="cov0" title="0">sort.Strings(localesList)

        resultData := map[string]interface{}{
                "success":     true,
                "output":      outputDir,
                "package":     c.packageName,
                "locales":     localesList,
                "localeCount": len(localesList),
        }
        if includeImages </span><span class="cov0" title="0">{
                resultData["images"] = imagesOutput
        }</span>

        <span class="cov0" title="0">result := output.NewResult(resultData).WithServices("androidpublisher")
        if len(warnings) &gt; 0 </span><span class="cov0" title="0">{
                result.WithWarnings(warnings...)
        }</span>
        <span class="cov0" title="0">return c.Output(result)</span>
}

func (c *CLI) exportFastlaneImages(ctx context.Context, publisher *androidpublisher.Service, editID, outputDir, locale string, httpClient *http.Client) (counts map[string]int, warnings []string) <span class="cov0" title="0">{
        normalizedLocale := config.NormalizeLocale(locale)
        imagesDir := filepath.Join(outputDir, locale, "images")
        if err := os.MkdirAll(imagesDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return nil, []string{fmt.Sprintf("failed to create images dir for %s: %v", locale, err)}
        }</span>

        <span class="cov0" title="0">counts = map[string]int{}
        warnings = []string{}
        for _, imageType := range fastlaneImageTypes </span><span class="cov0" title="0">{
                images, err := publisher.Edits.Images.List(c.packageName, editID, normalizedLocale, imageType).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        warnings = append(warnings, fmt.Sprintf("failed to list images for %s/%s: %v", locale, imageType, err))
                        continue</span>
                }
                <span class="cov0" title="0">if images == nil || len(images.Images) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if fastlaneSingleImageTypes[imageType] </span><span class="cov0" title="0">{
                        image := images.Images[0]
                        if image.Url == "" </span><span class="cov0" title="0">{
                                warnings = append(warnings, fmt.Sprintf("missing image url for %s/%s", locale, imageType))
                                continue</span>
                        }
                        <span class="cov0" title="0">destBase := filepath.Join(imagesDir, imageType)
                        if err := downloadImage(ctx, httpClient, image.Url, destBase); err != nil </span><span class="cov0" title="0">{
                                warnings = append(warnings, fmt.Sprintf("failed to download %s/%s: %v", locale, imageType, err))
                                continue</span>
                        }
                        <span class="cov0" title="0">counts[imageType] = 1
                        if len(images.Images) &gt; 1 </span><span class="cov0" title="0">{
                                warnings = append(warnings, fmt.Sprintf("multiple images found for %s/%s, exported first only", locale, imageType))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">typeDir := filepath.Join(imagesDir, imageType)
                if err := os.MkdirAll(typeDir, 0o755); err != nil </span><span class="cov0" title="0">{
                        warnings = append(warnings, fmt.Sprintf("failed to create %s/%s dir: %v", locale, imageType, err))
                        continue</span>
                }
                <span class="cov0" title="0">for i, image := range images.Images </span><span class="cov0" title="0">{
                        if image.Url == "" </span><span class="cov0" title="0">{
                                warnings = append(warnings, fmt.Sprintf("missing image url for %s/%s index %d", locale, imageType, i+1))
                                continue</span>
                        }
                        <span class="cov0" title="0">destBase := filepath.Join(typeDir, fmt.Sprintf("%02d", i+1))
                        if err := downloadImage(ctx, httpClient, image.Url, destBase); err != nil </span><span class="cov0" title="0">{
                                warnings = append(warnings, fmt.Sprintf("failed to download %s/%s index %d: %v", locale, imageType, i+1, err))
                                continue</span>
                        }
                        <span class="cov0" title="0">counts[imageType]++</span>
                }
        }
        <span class="cov0" title="0">return counts, warnings</span>
}

func (c *CLI) migrateFastlaneImport(ctx context.Context, dir string, skipImages, replaceImages, syncImages bool, editID string, noAutoCommit, dryRun bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">dir = strings.TrimSpace(dir)
        if dir == "" </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError, "dir is required"))
        }</span>

        <span class="cov0" title="0">metadata, err := fastlane.ParseDirectory(dir)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError, err.Error()))
        }</span>
        <span class="cov0" title="0">if len(metadata) == 0 </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError, "no locale directories found"))
        }</span>

        <span class="cov0" title="0">changelogSets := buildChangelogSets(metadata)

        if dryRun </span><span class="cov0" title="0">{
                resultData := c.buildFastlaneImportDryRun(dir, metadata, skipImages)
                return c.Output(output.NewResult(resultData))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr, edit, created, err := c.prepareEdit(ctx, publisher, editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := editMgr.ReleaseLock(c.packageName); err != nil </span><span class="cov0" title="0">{
                        logging.Warn("failed to release edit lock", logging.String("package", c.packageName), logging.Err(err))
                }</span>
        }()

        <span class="cov0" title="0">updatedListings, imageOutput, skippedImageOutput, apiErr := c.applyFastlaneImportMetadata(ctx, publisher, edit.ServerID, metadata, skipImages, replaceImages, syncImages)
        if apiErr != nil </span><span class="cov0" title="0">{
                c.cleanupEditOnError(ctx, publisher, edit.ServerID, created)
                return c.OutputError(apiErr)
        }</span>

        <span class="cov0" title="0">updatedTracks := 0
        updatedReleases := 0
        if len(changelogSets) &gt; 0 </span><span class="cov0" title="0">{
                trackUpdates, releaseUpdates, apiErr := c.importFastlaneReleaseNotes(ctx, publisher, edit.ServerID, changelogSets)
                if apiErr != nil </span><span class="cov0" title="0">{
                        c.cleanupEditOnError(ctx, publisher, edit.ServerID, created)
                        return c.OutputError(apiErr)
                }</span>
                <span class="cov0" title="0">updatedTracks = trackUpdates
                updatedReleases = releaseUpdates</span>
        }

        <span class="cov0" title="0">if err := c.finalizeEdit(ctx, publisher, editMgr, edit, !noAutoCommit); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">localesList := make([]string, 0, len(metadata))
        for i := range metadata </span><span class="cov0" title="0">{
                localesList = append(localesList, metadata[i].Locale)
        }</span>
        <span class="cov0" title="0">sort.Strings(localesList)

        resultData := map[string]interface{}{
                "success":         true,
                "dir":             dir,
                "package":         c.packageName,
                "locales":         localesList,
                "localeCount":     len(localesList),
                "updatedListings": updatedListings,
                "updatedTracks":   updatedTracks,
                "updatedReleases": updatedReleases,
                "editId":          edit.ServerID,
                "committed":       !noAutoCommit,
        }
        if !skipImages </span><span class="cov0" title="0">{
                resultData["images"] = imageOutput
        }</span>
        <span class="cov0" title="0">if len(skippedImageOutput) &gt; 0 </span><span class="cov0" title="0">{
                resultData["skippedImages"] = skippedImageOutput
        }</span>

        <span class="cov0" title="0">result := output.NewResult(resultData).WithServices("androidpublisher")
        return c.Output(result)</span>
}

func (c *CLI) buildFastlaneImportDryRun(dir string, metadata []fastlane.LocaleMetadata, skipImages bool) map[string]interface{} <span class="cov0" title="0">{
        resultData := map[string]interface{}{
                "dryRun":      true,
                "action":      "migrate_fastlane_import",
                "dir":         dir,
                "package":     c.packageName,
                "localeCount": len(metadata),
        }
        localesList := make([]string, 0, len(metadata))
        imageCounts := map[string]map[string]int{}
        for i := range metadata </span><span class="cov0" title="0">{
                meta := &amp;metadata[i]
                localesList = append(localesList, meta.Locale)
                if skipImages </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if len(meta.Images) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">counts := map[string]int{}
                for imageType, paths := range meta.Images </span><span class="cov0" title="0">{
                        counts[imageType] = len(paths)
                }</span>
                <span class="cov0" title="0">imageCounts[meta.Locale] = counts</span>
        }
        <span class="cov0" title="0">sort.Strings(localesList)
        resultData["locales"] = localesList
        if !skipImages </span><span class="cov0" title="0">{
                resultData["images"] = imageCounts
        }</span>
        <span class="cov0" title="0">return resultData</span>
}

func (c *CLI) applyFastlaneImportMetadata(ctx context.Context, publisher *androidpublisher.Service, editID string, metadata []fastlane.LocaleMetadata, skipImages, replaceImages, syncImages bool) (updatedListings int, imageOutput, skippedImageOutput map[string]map[string]int, apiErr *errors.APIError) <span class="cov0" title="0">{
        imageOutput = map[string]map[string]int{}
        skippedImageOutput = map[string]map[string]int{}
        for i := range metadata </span><span class="cov0" title="0">{
                meta := &amp;metadata[i]
                locale := config.NormalizeLocale(meta.Locale)
                listing := &amp;androidpublisher.Listing{
                        Language: locale,
                }
                if meta.TitleSet </span><span class="cov0" title="0">{
                        listing.Title = meta.Title
                }</span>
                <span class="cov0" title="0">if meta.ShortDescriptionSet </span><span class="cov0" title="0">{
                        listing.ShortDescription = meta.ShortDescription
                }</span>
                <span class="cov0" title="0">if meta.FullDescriptionSet </span><span class="cov0" title="0">{
                        listing.FullDescription = meta.FullDescription
                }</span>
                <span class="cov0" title="0">if meta.VideoSet </span><span class="cov0" title="0">{
                        listing.Video = meta.Video
                }</span>

                <span class="cov0" title="0">_, err := publisher.Edits.Listings.Update(c.packageName, editID, locale, listing).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return updatedListings, imageOutput, skippedImageOutput, errors.NewAPIError(errors.CodeGeneralError, fmt.Sprintf("failed to update listing for %s: %v", locale, err))
                }</span>
                <span class="cov0" title="0">updatedListings++

                if skipImages || len(meta.Images) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">counts, skipped, apiErr := c.importFastlaneImages(ctx, publisher, editID, locale, meta.Images, replaceImages, syncImages)
                if apiErr != nil </span><span class="cov0" title="0">{
                        return updatedListings, imageOutput, skippedImageOutput, apiErr
                }</span>
                <span class="cov0" title="0">if len(counts) &gt; 0 </span><span class="cov0" title="0">{
                        imageOutput[meta.Locale] = counts
                }</span>
                <span class="cov0" title="0">if len(skipped) &gt; 0 </span><span class="cov0" title="0">{
                        skippedImageOutput[meta.Locale] = skipped
                }</span>
        }

        <span class="cov0" title="0">return updatedListings, imageOutput, skippedImageOutput, nil</span>
}

func (c *CLI) importFastlaneImages(ctx context.Context, publisher *androidpublisher.Service, editID, locale string, images map[string][]string, replaceImages, syncImages bool) (counts, skipped map[string]int, apiErr *errors.APIError) <span class="cov0" title="0">{
        counts = map[string]int{}
        skipped = map[string]int{}
        hashCache := map[string]string{}

        for imageType, paths := range images </span><span class="cov0" title="0">{
                if len(paths) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if !fastlaneImageTypeSet[imageType] </span><span class="cov0" title="0">{
                        return nil, nil, errors.NewAPIError(errors.CodeValidationError, fmt.Sprintf("unsupported image type: %s", imageType))
                }</span>
                <span class="cov0" title="0">if replaceImages </span><span class="cov0" title="0">{
                        if _, err := publisher.Edits.Images.Deleteall(c.packageName, editID, locale, imageType).Context(ctx).Do(); err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errors.NewAPIError(errors.CodeGeneralError, fmt.Sprintf("failed to delete images for %s/%s: %v", locale, imageType, err))
                        }</span>
                }
                <span class="cov0" title="0">existingHashes := map[string]bool{}
                if syncImages &amp;&amp; !replaceImages </span><span class="cov0" title="0">{
                        list, err := publisher.Edits.Images.List(c.packageName, editID, locale, imageType).Context(ctx).Do()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errors.NewAPIError(errors.CodeGeneralError, fmt.Sprintf("failed to list images for %s/%s: %v", locale, imageType, err))
                        }</span>
                        <span class="cov0" title="0">for _, image := range list.Images </span><span class="cov0" title="0">{
                                if image == nil || image.Sha256 == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">existingHashes[strings.ToLower(image.Sha256)] = true</span>
                        }
                }
                <span class="cov0" title="0">for _, filePath := range paths </span><span class="cov0" title="0">{
                        if syncImages &amp;&amp; !replaceImages &amp;&amp; len(existingHashes) &gt; 0 </span><span class="cov0" title="0">{
                                hash, ok := hashCache[filePath]
                                if !ok </span><span class="cov0" title="0">{
                                        var err error
                                        hash, err = edits.HashFile(filePath)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, nil, errors.NewAPIError(errors.CodeGeneralError, err.Error())
                                        }</span>
                                        <span class="cov0" title="0">hashCache[filePath] = hash</span>
                                }
                                <span class="cov0" title="0">if existingHashes[strings.ToLower(hash)] </span><span class="cov0" title="0">{
                                        skipped[imageType]++
                                        continue</span>
                                }
                        }
                        <span class="cov0" title="0">if _, _, _, apiErr := validateImageFile(filePath, imageType); apiErr != nil </span><span class="cov0" title="0">{
                                return nil, nil, apiErr
                        }</span>
                        <span class="cov0" title="0">f, err := os.Open(filePath)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errors.NewAPIError(errors.CodeGeneralError, err.Error())
                        }</span>
                        <span class="cov0" title="0">_, uploadErr := publisher.Edits.Images.Upload(c.packageName, editID, locale, imageType).Media(f).Context(ctx).Do()
                        closeErr := f.Close()
                        if uploadErr != nil </span><span class="cov0" title="0">{
                                if closeErr != nil </span><span class="cov0" title="0">{
                                        return nil, nil, errors.NewAPIError(errors.CodeGeneralError, fmt.Sprintf("%v; close error: %v", uploadErr, closeErr))
                                }</span>
                                <span class="cov0" title="0">return nil, nil, errors.NewAPIError(errors.CodeGeneralError, uploadErr.Error())</span>
                        }
                        <span class="cov0" title="0">if closeErr != nil </span><span class="cov0" title="0">{
                                return nil, nil, errors.NewAPIError(errors.CodeGeneralError, closeErr.Error())
                        }</span>
                        <span class="cov0" title="0">counts[imageType]++</span>
                }
        }

        <span class="cov0" title="0">if len(skipped) == 0 </span><span class="cov0" title="0">{
                skipped = nil
        }</span>
        <span class="cov0" title="0">return counts, skipped, nil</span>
}

func (c *CLI) exportFastlaneChangelogs(ctx context.Context, publisher *androidpublisher.Service, editID string, locales map[string]bool) (map[string]map[string]string, *errors.APIError) <span class="cov0" title="0">{
        tracks, err := publisher.Edits.Tracks.List(c.packageName, editID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewAPIError(errors.CodeGeneralError, fmt.Sprintf("failed to list tracks: %v", err))
        }</span>
        <span class="cov0" title="0">if tracks == nil || len(tracks.Tracks) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">sortTracksByPriority(tracks.Tracks)

        notesByLocale := map[string]map[string]string{}
        for _, track := range tracks.Tracks </span><span class="cov0" title="0">{
                if track == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for _, release := range track.Releases </span><span class="cov0" title="0">{
                        if release == nil || len(release.ReleaseNotes) == 0 || len(release.VersionCodes) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">for _, note := range release.ReleaseNotes </span><span class="cov0" title="0">{
                                if note == nil || note.Text == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">locale := config.NormalizeLocale(note.Language)
                                if locales != nil &amp;&amp; !locales[locale] </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">for _, code := range release.VersionCodes </span><span class="cov0" title="0">{
                                        key := strconv.FormatInt(code, 10)
                                        if notesByLocale[locale] == nil </span><span class="cov0" title="0">{
                                                notesByLocale[locale] = map[string]string{}
                                        }</span>
                                        <span class="cov0" title="0">if _, exists := notesByLocale[locale][key]; exists </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">notesByLocale[locale][key] = note.Text</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return notesByLocale, nil</span>
}

const defaultChangelogKey = "default"

func buildChangelogSets(metadata []fastlane.LocaleMetadata) map[string]changelogSet <span class="cov0" title="0">{
        sets := map[string]changelogSet{}
        for i := range metadata </span><span class="cov0" title="0">{
                meta := &amp;metadata[i]
                if len(meta.Changelogs) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">set := changelogSet{byVersion: map[int64]string{}}
                for key, text := range meta.Changelogs </span><span class="cov0" title="0">{
                        if key == defaultChangelogKey </span><span class="cov0" title="0">{
                                set.defaultText = text
                                set.hasDefault = true
                                continue</span>
                        }
                        <span class="cov0" title="0">versionCode, err := strconv.ParseInt(key, 10, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">set.byVersion[versionCode] = text</span>
                }
                <span class="cov0" title="0">if len(set.byVersion) == 0 &amp;&amp; !set.hasDefault </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">locale := config.NormalizeLocale(meta.Locale)
                sets[locale] = set</span>
        }
        <span class="cov0" title="0">return sets</span>
}

func (c *CLI) importFastlaneReleaseNotes(ctx context.Context, publisher *androidpublisher.Service, editID string, changelogSets map[string]changelogSet) (updatedTracks, updatedReleases int, apiErr *errors.APIError) <span class="cov0" title="0">{
        tracks, err := publisher.Edits.Tracks.List(c.packageName, editID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, errors.NewAPIError(errors.CodeGeneralError, fmt.Sprintf("failed to list tracks: %v", err))
        }</span>
        <span class="cov0" title="0">if tracks == nil || len(tracks.Tracks) == 0 </span><span class="cov0" title="0">{
                return 0, 0, nil
        }</span>
        <span class="cov0" title="0">for _, track := range tracks.Tracks </span><span class="cov0" title="0">{
                if track == nil || len(track.Releases) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">trackChanged := false
                for _, release := range track.Releases </span><span class="cov0" title="0">{
                        if release == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if applyReleaseNotes(release, changelogSets) </span><span class="cov0" title="0">{
                                trackChanged = true
                                updatedReleases++
                        }</span>
                }
                <span class="cov0" title="0">if !trackChanged </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">_, err := publisher.Edits.Tracks.Update(c.packageName, editID, track.Track, track).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return updatedTracks, updatedReleases, errors.NewAPIError(errors.CodeGeneralError, fmt.Sprintf("failed to update track %s: %v", track.Track, err))
                }</span>
                <span class="cov0" title="0">updatedTracks++</span>
        }
        <span class="cov0" title="0">return updatedTracks, updatedReleases, nil</span>
}

func applyReleaseNotes(release *androidpublisher.TrackRelease, changelogSets map[string]changelogSet) bool <span class="cov0" title="0">{
        if release == nil || len(changelogSets) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">existing := map[string]string{}
        for _, note := range release.ReleaseNotes </span><span class="cov0" title="0">{
                if note == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">locale := config.NormalizeLocale(note.Language)
                existing[locale] = note.Text</span>
        }
        <span class="cov0" title="0">changed := false
        for locale, set := range changelogSets </span><span class="cov0" title="0">{
                text, ok := selectChangelogText(set, release.VersionCodes)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if current, ok := existing[locale]; ok &amp;&amp; current == text </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">existing[locale] = text
                changed = true</span>
        }
        <span class="cov0" title="0">if !changed </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">locales := make([]string, 0, len(existing))
        for locale := range existing </span><span class="cov0" title="0">{
                locales = append(locales, locale)
        }</span>
        <span class="cov0" title="0">sort.Strings(locales)
        release.ReleaseNotes = make([]*androidpublisher.LocalizedText, 0, len(locales))
        for _, locale := range locales </span><span class="cov0" title="0">{
                release.ReleaseNotes = append(release.ReleaseNotes, &amp;androidpublisher.LocalizedText{
                        Language: locale,
                        Text:     existing[locale],
                })
        }</span>
        <span class="cov0" title="0">return true</span>
}

func selectChangelogText(set changelogSet, versionCodes []int64) (string, bool) <span class="cov0" title="0">{
        var selected string
        var selectedVersion int64
        found := false
        for _, code := range versionCodes </span><span class="cov0" title="0">{
                if text, ok := set.byVersion[code]; ok </span><span class="cov0" title="0">{
                        if !found || code &gt; selectedVersion </span><span class="cov0" title="0">{
                                selected = text
                                selectedVersion = code
                                found = true
                        }</span>
                }
        }
        <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                return selected, true
        }</span>
        <span class="cov0" title="0">if set.hasDefault </span><span class="cov0" title="0">{
                return set.defaultText, true
        }</span>
        <span class="cov0" title="0">return "", false</span>
}

func sortTracksByPriority(tracks []*androidpublisher.Track) <span class="cov0" title="0">{
        sort.SliceStable(tracks, func(i, j int) bool </span><span class="cov0" title="0">{
                if tracks[i] == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if tracks[j] == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">pi := trackPriority(tracks[i].Track)
                pj := trackPriority(tracks[j].Track)
                if pi != pj </span><span class="cov0" title="0">{
                        return pi &lt; pj
                }</span>
                <span class="cov0" title="0">return tracks[i].Track &lt; tracks[j].Track</span>
        })
}

func trackPriority(track string) int <span class="cov0" title="0">{
        switch track </span>{
        case "production":<span class="cov0" title="0">
                return 0</span>
        case "beta":<span class="cov0" title="0">
                return 1</span>
        case "alpha":<span class="cov0" title="0">
                return 2</span>
        case "internal":<span class="cov0" title="0">
                return 3</span>
        default:<span class="cov0" title="0">
                return 10</span>
        }
}

func normalizeLocaleFilter(locales []string) map[string]bool <span class="cov0" title="0">{
        if len(locales) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">filter := map[string]bool{}
        for _, locale := range locales </span><span class="cov0" title="0">{
                normalized := strings.TrimSpace(locale)
                if normalized == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">filter[config.NormalizeLocale(normalized)] = true</span>
        }
        <span class="cov0" title="0">if len(filter) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return filter</span>
}

func downloadImage(ctx context.Context, httpClient *http.Client, rawURL, destBase string) (err error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, http.MethodGet, rawURL, http.NoBody)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := resp.Body.Close(); closeErr != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        err = closeErr
                }</span>
        }()
        <span class="cov0" title="0">if resp.StatusCode &lt; http.StatusOK || resp.StatusCode &gt;= http.StatusMultipleChoices </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected status: %s", resp.Status)
        }</span>

        <span class="cov0" title="0">buf := make([]byte, 512)
        n, err := io.ReadFull(resp.Body, buf)
        if err != nil &amp;&amp; err != io.ErrUnexpectedEOF &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">contentType := http.DetectContentType(buf[:n])
        ext := extensionForContentType(contentType)
        if ext == "" </span><span class="cov0" title="0">{
                ext = extensionFromURL(rawURL)
        }</span>
        <span class="cov0" title="0">if ext == "" </span><span class="cov0" title="0">{
                ext = ".img"
        }</span>

        <span class="cov0" title="0">destPath := destBase + ext
        if err := os.MkdirAll(filepath.Dir(destPath), 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">tempPath := destPath + ".tmp"
        file, err := os.Create(tempPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cleanupTemp := func(copyErr error) error </span><span class="cov0" title="0">{
                closeErr := file.Close()
                removeErr := os.Remove(tempPath)
                if closeErr != nil &amp;&amp; removeErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%v; close error: %v; remove error: %v", copyErr, closeErr, removeErr)
                }</span>
                <span class="cov0" title="0">if closeErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%v; close error: %v", copyErr, closeErr)
                }</span>
                <span class="cov0" title="0">if removeErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%v; remove error: %v", copyErr, removeErr)
                }</span>
                <span class="cov0" title="0">return copyErr</span>
        }

        <span class="cov0" title="0">if n &gt; 0 </span><span class="cov0" title="0">{
                if _, err := io.Copy(file, bytes.NewReader(buf[:n])); err != nil </span><span class="cov0" title="0">{
                        return cleanupTemp(err)
                }</span>
        }
        <span class="cov0" title="0">if _, err := io.Copy(file, resp.Body); err != nil </span><span class="cov0" title="0">{
                return cleanupTemp(err)
        }</span>
        <span class="cov0" title="0">if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                removeErr := os.Remove(tempPath)
                if removeErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%v; remove error: %v", err, removeErr)
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">if err := os.Rename(tempPath, destPath); err != nil </span><span class="cov0" title="0">{
                removeErr := os.Remove(tempPath)
                if removeErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%v; remove error: %v", err, removeErr)
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func extensionForContentType(contentType string) string <span class="cov0" title="0">{
        switch contentType </span>{
        case "image/png":<span class="cov0" title="0">
                return ".png"</span>
        case "image/jpeg":<span class="cov0" title="0">
                return ".jpg"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func extensionFromURL(rawURL string) string <span class="cov0" title="0">{
        parsed, err := url.Parse(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">ext := path.Ext(parsed.Path)
        if ext == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">switch strings.ToLower(ext) </span>{
        case ".png", ".jpg", ".jpeg":<span class="cov0" title="0">
                return ext</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package cli

import (
        "context"

        "google.golang.org/api/androidpublisher/v3"

        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

func (c *CLI) monetizationBasePlansActivate(ctx context.Context, subscriptionID, basePlanID string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">resp, err := publisher.Monetization.Subscriptions.BasePlans.Activate(c.packageName, subscriptionID, basePlanID, &amp;androidpublisher.ActivateBasePlanRequest{}).
                Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">return c.Output(output.NewResult(resp).WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationBasePlansDeactivate(ctx context.Context, subscriptionID, basePlanID string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">resp, err := publisher.Monetization.Subscriptions.BasePlans.Deactivate(c.packageName, subscriptionID, basePlanID, &amp;androidpublisher.DeactivateBasePlanRequest{}).
                Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">return c.Output(output.NewResult(resp).WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationBasePlansDelete(ctx context.Context, subscriptionID, basePlanID string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">if err := publisher.Monetization.Subscriptions.BasePlans.Delete(c.packageName, subscriptionID, basePlanID).Context(ctx).Do(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":    true,
                "basePlanId": basePlanID,
                "productId":  subscriptionID,
                "package":    c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationBasePlansMigratePrices(ctx context.Context, subscriptionID, basePlanID, regionCode string, priceMicros int64) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">if priceMicros &lt;= 0 </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError, "price-micros must be greater than zero"))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">req := &amp;androidpublisher.MigrateBasePlanPricesRequest{
                RegionalPriceMigrations: []*androidpublisher.RegionalPriceMigrationConfig{
                        {
                                RegionCode:                    regionCode,
                                OldestAllowedPriceVersionTime: "1970-01-01T00:00:00Z",
                        },
                },
                RegionsVersion: &amp;androidpublisher.RegionsVersion{
                        Version: "2022/02",
                },
        }
        resp, err := publisher.Monetization.Subscriptions.BasePlans.MigratePrices(c.packageName, subscriptionID, basePlanID, req).
                Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">return c.Output(output.NewResult(resp).WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationBasePlansBatchMigratePrices(ctx context.Context, subscriptionID, filePath string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">var req androidpublisher.BatchMigrateBasePlanPricesRequest
        if err := loadJSONFile(filePath, &amp;req); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err)
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">resp, err := publisher.Monetization.Subscriptions.BasePlans.BatchMigratePrices(c.packageName, subscriptionID, &amp;req).
                Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">return c.Output(output.NewResult(resp).WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationBasePlansBatchUpdateStates(ctx context.Context, subscriptionID, filePath string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">var req androidpublisher.BatchUpdateBasePlanStatesRequest
        if err := loadJSONFile(filePath, &amp;req); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err)
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">resp, err := publisher.Monetization.Subscriptions.BasePlans.BatchUpdateStates(c.packageName, subscriptionID, &amp;req).
                Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">return c.Output(output.NewResult(resp).WithServices("androidpublisher"))</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package cli

import (
        "github.com/spf13/cobra"

        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

func (c *CLI) addMonetizationCommands() <span class="cov10" title="18">{
        monetizationCmd := &amp;cobra.Command{
                Use:   "monetization",
                Short: "Monetization commands",
                Long:  "Manage in-app products and subscriptions.",
        }

        c.addMonetizationProductsCommands(monetizationCmd)
        c.addMonetizationSubscriptionsCommands(monetizationCmd)
        c.addMonetizationBasePlansCommands(monetizationCmd)
        c.addMonetizationOffersCommands(monetizationCmd)
        c.addMonetizationOnetimeProductsCommands(monetizationCmd)
        c.addMonetizationUtilityCommands(monetizationCmd)

        c.rootCmd.AddCommand(monetizationCmd)
}</span>

func (c *CLI) addMonetizationProductsCommands(monetizationCmd *cobra.Command) <span class="cov10" title="18">{
        productsCmd := &amp;cobra.Command{
                Use:   "products",
                Short: "Manage in-app products",
                Long:  "List, create, and update in-app products.",
        }

        var (
                productID    string
                productType  string
                defaultPrice string
                status       string
                pageSize     int64
                pageToken    string
                all          bool
        )

        productsListCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List in-app products",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.monetizationProductsList(cmd.Context(), pageSize, pageToken, all)
                }</span>,
        }
        <span class="cov10" title="18">productsListCmd.Flags().Int64Var(&amp;pageSize, "page-size", 100, "Results per page")
        productsListCmd.Flags().StringVar(&amp;pageToken, "page-token", "", "Pagination token")
        addPaginationFlags(productsListCmd, &amp;all)

        productsGetCmd := &amp;cobra.Command{
                Use:   "get [product-id]",
                Short: "Get an in-app product",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.monetizationProductsGet(cmd.Context(), args[0])
                }</span>,
        }

        <span class="cov10" title="18">productsCreateCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "Create an in-app product",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if productID == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--product-id is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.monetizationProductsCreate(cmd.Context(), productID, productType, defaultPrice, status)</span>
                },
        }
        <span class="cov10" title="18">productsCreateCmd.Flags().StringVar(&amp;productID, "product-id", "", "Product SKU")
        productsCreateCmd.Flags().StringVar(&amp;productType, "type", "managed", "Product type: managed, consumable")
        productsCreateCmd.Flags().StringVar(&amp;defaultPrice, "default-price", "", "Default price in micros (e.g., 990000 for $0.99)")
        productsCreateCmd.Flags().StringVar(&amp;status, "status", "active", "Product status: active, inactive")

        productsUpdateCmd := &amp;cobra.Command{
                Use:   "update [product-id]",
                Short: "Update an in-app product",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.monetizationProductsUpdate(cmd.Context(), args[0], defaultPrice, status)
                }</span>,
        }
        <span class="cov10" title="18">productsUpdateCmd.Flags().StringVar(&amp;defaultPrice, "default-price", "", "Default price in micros")
        productsUpdateCmd.Flags().StringVar(&amp;status, "status", "", "Product status: active, inactive")

        productsDeleteCmd := &amp;cobra.Command{
                Use:   "delete [product-id]",
                Short: "Delete an in-app product",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.monetizationProductsDelete(cmd.Context(), args[0])
                }</span>,
        }

        <span class="cov10" title="18">productsCmd.AddCommand(productsListCmd, productsGetCmd, productsCreateCmd, productsUpdateCmd, productsDeleteCmd)
        monetizationCmd.AddCommand(productsCmd)</span>
}

func (c *CLI) addMonetizationSubscriptionsCommands(monetizationCmd *cobra.Command) <span class="cov10" title="18">{
        subscriptionsCmd := &amp;cobra.Command{
                Use:   "subscriptions",
                Short: "Manage subscriptions",
                Long:  "List, create, update, and archive subscription products.",
        }
        var (
                subscriptionID   string
                subscriptionFile string
                updateMask       string
                allowMissing     bool
                ids              []string
                batchFile        string
                confirm          bool
                showArchived     bool
                pageSize         int64
                pageToken        string
                all              bool
        )

        subscriptionsListCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List subscription products",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.monetizationSubscriptionsList(cmd.Context(), pageSize, pageToken, all, showArchived)
                }</span>,
        }
        <span class="cov10" title="18">subscriptionsListCmd.Flags().Int64Var(&amp;pageSize, "page-size", 100, "Results per page")
        subscriptionsListCmd.Flags().StringVar(&amp;pageToken, "page-token", "", "Pagination token")
        addPaginationFlags(subscriptionsListCmd, &amp;all)
        subscriptionsListCmd.Flags().BoolVar(&amp;showArchived, "show-archived", false, "Include archived subscriptions")

        subscriptionsGetCmd := &amp;cobra.Command{
                Use:   "get [subscription-id]",
                Short: "Get a subscription product",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.monetizationSubscriptionsGet(cmd.Context(), args[0])
                }</span>,
        }

        <span class="cov10" title="18">subscriptionsCreateCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "Create a subscription",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if subscriptionID == "" || subscriptionFile == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--product-id and --file are required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.monetizationSubscriptionsCreate(cmd.Context(), subscriptionID, subscriptionFile)</span>
                },
        }
        <span class="cov10" title="18">subscriptionsCreateCmd.Flags().StringVar(&amp;subscriptionID, "product-id", "", "Subscription product ID")
        subscriptionsCreateCmd.Flags().StringVar(&amp;subscriptionFile, "file", "", "Subscription JSON file")

        subscriptionsUpdateCmd := &amp;cobra.Command{
                Use:   "update [subscription-id]",
                Short: "Update a subscription",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if subscriptionFile == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--file is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.monetizationSubscriptionsUpdate(cmd.Context(), args[0], subscriptionFile)</span>
                },
        }
        <span class="cov10" title="18">subscriptionsUpdateCmd.Flags().StringVar(&amp;subscriptionFile, "file", "", "Subscription JSON file")

        subscriptionsPatchCmd := &amp;cobra.Command{
                Use:   "patch [subscription-id]",
                Short: "Patch a subscription",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if subscriptionFile == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--file is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.monetizationSubscriptionsPatch(cmd.Context(), args[0], subscriptionFile, updateMask, allowMissing)</span>
                },
        }
        <span class="cov10" title="18">subscriptionsPatchCmd.Flags().StringVar(&amp;subscriptionFile, "file", "", "Subscription JSON file")
        subscriptionsPatchCmd.Flags().StringVar(&amp;updateMask, "update-mask", "", "Fields to update (comma-separated)")
        subscriptionsPatchCmd.Flags().BoolVar(&amp;allowMissing, "allow-missing", false, "Create if missing")

        subscriptionsDeleteCmd := &amp;cobra.Command{
                Use:   "delete [subscription-id]",
                Short: "Delete a subscription",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if !confirm </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--confirm flag required for destructive operations")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.monetizationSubscriptionsDelete(cmd.Context(), args[0])</span>
                },
        }
        <span class="cov10" title="18">subscriptionsDeleteCmd.Flags().BoolVar(&amp;confirm, "confirm", false, "Confirm destructive operation")

        subscriptionsArchiveCmd := &amp;cobra.Command{
                Use:   "archive [subscription-id]",
                Short: "Archive a subscription",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.monetizationSubscriptionsArchive(cmd.Context(), args[0])
                }</span>,
        }

        <span class="cov10" title="18">subscriptionsBatchGetCmd := &amp;cobra.Command{
                Use:   "batchGet",
                Short: "Batch get subscriptions",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if len(ids) == 0 </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--ids is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.monetizationSubscriptionsBatchGet(cmd.Context(), ids)</span>
                },
        }
        <span class="cov10" title="18">subscriptionsBatchGetCmd.Flags().StringSliceVar(&amp;ids, "ids", nil, "Subscription IDs")

        subscriptionsBatchUpdateCmd := &amp;cobra.Command{
                Use:   "batchUpdate",
                Short: "Batch update subscriptions",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if batchFile == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--file is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.monetizationSubscriptionsBatchUpdate(cmd.Context(), batchFile)</span>
                },
        }
        <span class="cov10" title="18">subscriptionsBatchUpdateCmd.Flags().StringVar(&amp;batchFile, "file", "", "Batch update JSON file")

        subscriptionsCmd.AddCommand(subscriptionsListCmd, subscriptionsGetCmd, subscriptionsCreateCmd, subscriptionsUpdateCmd,
                subscriptionsPatchCmd, subscriptionsDeleteCmd, subscriptionsArchiveCmd, subscriptionsBatchGetCmd, subscriptionsBatchUpdateCmd)
        monetizationCmd.AddCommand(subscriptionsCmd)</span>
}

func (c *CLI) addMonetizationBasePlansCommands(monetizationCmd *cobra.Command) <span class="cov10" title="18">{
        basePlansCmd := &amp;cobra.Command{
                Use:   "baseplans",
                Short: "Manage subscription base plans",
        }
        var (
                basePlanFile        string
                basePlanRegion      string
                basePlanPriceMicros int64
                confirm             bool
        )

        basePlansActivateCmd := &amp;cobra.Command{
                Use:   "activate [subscription-id] [plan-id]",
                Short: "Activate a base plan",
                Args:  cobra.ExactArgs(2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.monetizationBasePlansActivate(cmd.Context(), args[0], args[1])
                }</span>,
        }
        <span class="cov10" title="18">basePlansDeactivateCmd := &amp;cobra.Command{
                Use:   "deactivate [subscription-id] [plan-id]",
                Short: "Deactivate a base plan",
                Args:  cobra.ExactArgs(2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.monetizationBasePlansDeactivate(cmd.Context(), args[0], args[1])
                }</span>,
        }
        <span class="cov10" title="18">basePlansDeleteCmd := &amp;cobra.Command{
                Use:   "delete [subscription-id] [plan-id]",
                Short: "Delete a base plan",
                Args:  cobra.ExactArgs(2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if !confirm </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--confirm flag required for destructive operations")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.monetizationBasePlansDelete(cmd.Context(), args[0], args[1])</span>
                },
        }
        <span class="cov10" title="18">basePlansDeleteCmd.Flags().BoolVar(&amp;confirm, "confirm", false, "Confirm destructive operation")

        basePlansMigratePricesCmd := &amp;cobra.Command{
                Use:   "migrate-prices [subscription-id] [plan-id]",
                Short: "Migrate base plan prices",
                Args:  cobra.ExactArgs(2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if basePlanRegion == "" || basePlanPriceMicros &lt;= 0 </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--region-code and --price-micros are required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.monetizationBasePlansMigratePrices(cmd.Context(), args[0], args[1], basePlanRegion, basePlanPriceMicros)</span>
                },
        }
        <span class="cov10" title="18">basePlansMigratePricesCmd.Flags().StringVar(&amp;basePlanRegion, "region-code", "", "Region code")
        basePlansMigratePricesCmd.Flags().Int64Var(&amp;basePlanPriceMicros, "price-micros", 0, "Price in micros")

        basePlansBatchMigrateCmd := &amp;cobra.Command{
                Use:   "batch-migrate-prices [subscription-id]",
                Short: "Batch migrate base plan prices",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if basePlanFile == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--file is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.monetizationBasePlansBatchMigratePrices(cmd.Context(), args[0], basePlanFile)</span>
                },
        }
        <span class="cov10" title="18">basePlansBatchMigrateCmd.Flags().StringVar(&amp;basePlanFile, "file", "", "Batch migrate JSON file")

        basePlansBatchUpdateStatesCmd := &amp;cobra.Command{
                Use:   "batch-update-states [subscription-id]",
                Short: "Batch update base plan states",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if basePlanFile == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--file is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.monetizationBasePlansBatchUpdateStates(cmd.Context(), args[0], basePlanFile)</span>
                },
        }
        <span class="cov10" title="18">basePlansBatchUpdateStatesCmd.Flags().StringVar(&amp;basePlanFile, "file", "", "Batch update JSON file")

        basePlansCmd.AddCommand(basePlansActivateCmd, basePlansDeactivateCmd, basePlansDeleteCmd, basePlansMigratePricesCmd,
                basePlansBatchMigrateCmd, basePlansBatchUpdateStatesCmd)
        monetizationCmd.AddCommand(basePlansCmd)</span>
}

func (c *CLI) addMonetizationOffersCommands(monetizationCmd *cobra.Command) <span class="cov10" title="18">{
        offersCmd := &amp;cobra.Command{
                Use:   "offers",
                Short: "Manage subscription offers",
        }
        var (
                offerID   string
                offerFile string
                offerIDs  []string
                confirm   bool
                pageSize  int64
                pageToken string
                all       bool
        )

        offersCreateCmd := &amp;cobra.Command{
                Use:   "create [subscription-id] [plan-id]",
                Short: "Create an offer",
                Args:  cobra.ExactArgs(2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if offerID == "" || offerFile == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--offer-id and --file are required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.monetizationOffersCreate(cmd.Context(), args[0], args[1], offerID, offerFile)</span>
                },
        }
        <span class="cov10" title="18">offersCreateCmd.Flags().StringVar(&amp;offerID, "offer-id", "", "Offer ID")
        offersCreateCmd.Flags().StringVar(&amp;offerFile, "file", "", "Offer JSON file")

        offersGetCmd := &amp;cobra.Command{
                Use:   "get [subscription-id] [plan-id] [offer-id]",
                Short: "Get an offer",
                Args:  cobra.ExactArgs(3),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.monetizationOffersGet(cmd.Context(), args[0], args[1], args[2])
                }</span>,
        }

        <span class="cov10" title="18">offersListCmd := &amp;cobra.Command{
                Use:   "list [subscription-id] [plan-id]",
                Short: "List offers",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if len(args) != 2 </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "subscription-id and plan-id are required").
                                        WithHint("Usage: gpd monetization offers list &lt;subscription-id&gt; &lt;plan-id&gt;"))
                                return c.Output(result.WithServices("androidpublisher"))
                        }</span>
                        <span class="cov0" title="0">return c.monetizationOffersList(cmd.Context(), args[0], args[1], pageSize, pageToken, all)</span>
                },
        }
        <span class="cov10" title="18">offersListCmd.Flags().Int64Var(&amp;pageSize, "page-size", 100, "Results per page")
        offersListCmd.Flags().StringVar(&amp;pageToken, "page-token", "", "Pagination token")
        addPaginationFlags(offersListCmd, &amp;all)

        offersDeleteCmd := &amp;cobra.Command{
                Use:   "delete [subscription-id] [plan-id] [offer-id]",
                Short: "Delete an offer",
                Args:  cobra.ExactArgs(3),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if !confirm </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--confirm flag required for destructive operations")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.monetizationOffersDelete(cmd.Context(), args[0], args[1], args[2])</span>
                },
        }
        <span class="cov10" title="18">offersDeleteCmd.Flags().BoolVar(&amp;confirm, "confirm", false, "Confirm destructive operation")

        offersActivateCmd := &amp;cobra.Command{
                Use:   "activate [subscription-id] [plan-id] [offer-id]",
                Short: "Activate an offer",
                Args:  cobra.ExactArgs(3),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.monetizationOffersActivate(cmd.Context(), args[0], args[1], args[2])
                }</span>,
        }

        <span class="cov10" title="18">offersDeactivateCmd := &amp;cobra.Command{
                Use:   "deactivate [subscription-id] [plan-id] [offer-id]",
                Short: "Deactivate an offer",
                Args:  cobra.ExactArgs(3),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.monetizationOffersDeactivate(cmd.Context(), args[0], args[1], args[2])
                }</span>,
        }

        <span class="cov10" title="18">offersBatchGetCmd := &amp;cobra.Command{
                Use:   "batchGet [subscription-id] [plan-id]",
                Short: "Batch get offers",
                Args:  cobra.ExactArgs(2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if len(offerIDs) == 0 </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--offer-ids is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.monetizationOffersBatchGet(cmd.Context(), args[0], args[1], offerIDs)</span>
                },
        }
        <span class="cov10" title="18">offersBatchGetCmd.Flags().StringSliceVar(&amp;offerIDs, "offer-ids", nil, "Offer IDs")

        offersBatchUpdateCmd := &amp;cobra.Command{
                Use:   "batchUpdate [subscription-id] [plan-id]",
                Short: "Batch update offers",
                Args:  cobra.ExactArgs(2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if offerFile == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--file is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.monetizationOffersBatchUpdate(cmd.Context(), args[0], args[1], offerFile)</span>
                },
        }
        <span class="cov10" title="18">offersBatchUpdateCmd.Flags().StringVar(&amp;offerFile, "file", "", "Batch update JSON file")

        offersBatchUpdateStatesCmd := &amp;cobra.Command{
                Use:   "batchUpdateStates [subscription-id] [plan-id]",
                Short: "Batch update offer states",
                Args:  cobra.ExactArgs(2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if offerFile == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--file is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.monetizationOffersBatchUpdateStates(cmd.Context(), args[0], args[1], offerFile)</span>
                },
        }
        <span class="cov10" title="18">offersBatchUpdateStatesCmd.Flags().StringVar(&amp;offerFile, "file", "", "Batch update states JSON file")

        offersCmd.AddCommand(offersCreateCmd, offersGetCmd, offersListCmd, offersDeleteCmd, offersActivateCmd, offersDeactivateCmd,
                offersBatchGetCmd, offersBatchUpdateCmd, offersBatchUpdateStatesCmd)
        monetizationCmd.AddCommand(offersCmd)</span>
}

func (c *CLI) addMonetizationOnetimeProductsCommands(monetizationCmd *cobra.Command) <span class="cov10" title="18">{
        onetimeProductsCmd := &amp;cobra.Command{
                Use:   "onetimeproducts",
                Short: "Manage one-time products",
                Long:  "Alias of legacy in-app products for managed/consumable items.",
        }
        var (
                productID    string
                productType  string
                defaultPrice string
                status       string
                pageSize     int64
                pageToken    string
                all          bool
        )

        onetimeProductsListCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List one-time products",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.monetizationProductsList(cmd.Context(), pageSize, pageToken, all)
                }</span>,
        }
        <span class="cov10" title="18">onetimeProductsListCmd.Flags().Int64Var(&amp;pageSize, "page-size", 100, "Results per page")
        onetimeProductsListCmd.Flags().StringVar(&amp;pageToken, "page-token", "", "Pagination token")
        addPaginationFlags(onetimeProductsListCmd, &amp;all)

        onetimeProductsGetCmd := &amp;cobra.Command{
                Use:   "get [product-id]",
                Short: "Get a one-time product",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.monetizationProductsGet(cmd.Context(), args[0])
                }</span>,
        }

        <span class="cov10" title="18">onetimeProductsCreateCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "Create a one-time product",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if productID == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--product-id is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.monetizationProductsCreate(cmd.Context(), productID, productType, defaultPrice, status)</span>
                },
        }
        <span class="cov10" title="18">onetimeProductsCreateCmd.Flags().StringVar(&amp;productID, "product-id", "", "Product SKU")
        onetimeProductsCreateCmd.Flags().StringVar(&amp;productType, "type", "managed", "Product type: managed, consumable")
        onetimeProductsCreateCmd.Flags().StringVar(&amp;defaultPrice, "default-price", "", "Default price in micros (e.g., 990000 for $0.99)")
        onetimeProductsCreateCmd.Flags().StringVar(&amp;status, "status", "active", "Product status: active, inactive")

        onetimeProductsUpdateCmd := &amp;cobra.Command{
                Use:   "update [product-id]",
                Short: "Update a one-time product",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.monetizationProductsUpdate(cmd.Context(), args[0], defaultPrice, status)
                }</span>,
        }
        <span class="cov10" title="18">onetimeProductsUpdateCmd.Flags().StringVar(&amp;defaultPrice, "default-price", "", "Default price in micros")
        onetimeProductsUpdateCmd.Flags().StringVar(&amp;status, "status", "", "Product status: active, inactive")

        onetimeProductsDeleteCmd := &amp;cobra.Command{
                Use:   "delete [product-id]",
                Short: "Delete a one-time product",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.monetizationProductsDelete(cmd.Context(), args[0])
                }</span>,
        }

        <span class="cov10" title="18">onetimeProductsCmd.AddCommand(onetimeProductsListCmd, onetimeProductsGetCmd, onetimeProductsCreateCmd, onetimeProductsUpdateCmd, onetimeProductsDeleteCmd)
        monetizationCmd.AddCommand(onetimeProductsCmd)</span>
}

func (c *CLI) addMonetizationUtilityCommands(monetizationCmd *cobra.Command) <span class="cov10" title="18">{
        var (
                priceMicros  int64
                currencyCode string
                regionFilter []string
        )

        convertCmd := &amp;cobra.Command{
                Use:   "convert-region-prices",
                Short: "Convert region prices",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if priceMicros == 0 </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--price-micros is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.monetizationConvertRegionPrices(cmd.Context(), priceMicros, currencyCode, regionFilter)</span>
                },
        }
        <span class="cov10" title="18">convertCmd.Flags().Int64Var(&amp;priceMicros, "price-micros", 0, "Price in micros")
        convertCmd.Flags().StringVar(&amp;currencyCode, "currency", "USD", "Currency code")
        convertCmd.Flags().StringSliceVar(&amp;regionFilter, "to-regions", nil, "Region codes to include")

        capabilitiesCmd := &amp;cobra.Command{
                Use:   "capabilities",
                Short: "List monetization capabilities",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.monetizationCapabilities(cmd.Context())
                }</span>,
        }

        <span class="cov10" title="18">monetizationCmd.AddCommand(convertCmd, capabilitiesCmd)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package cli

import (
        "context"

        "google.golang.org/api/androidpublisher/v3"

        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

func (c *CLI) monetizationOffersCreate(ctx context.Context, subscriptionID, basePlanID, offerID, filePath string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">var offer androidpublisher.SubscriptionOffer
        if err := loadJSONFile(filePath, &amp;offer); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err)
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">resp, err := publisher.Monetization.Subscriptions.BasePlans.Offers.Create(c.packageName, subscriptionID, basePlanID, &amp;offer).
                OfferId(offerID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">return c.Output(output.NewResult(resp).WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationOffersGet(ctx context.Context, subscriptionID, basePlanID, offerID string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">resp, err := publisher.Monetization.Subscriptions.BasePlans.Offers.Get(c.packageName, subscriptionID, basePlanID, offerID).
                Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">return c.Output(output.NewResult(resp).WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationOffersList(ctx context.Context, subscriptionID, basePlanID string, pageSize int64, pageToken string, all bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">req := publisher.Monetization.Subscriptions.BasePlans.Offers.List(c.packageName, subscriptionID, basePlanID)
        if pageSize &gt; 0 </span><span class="cov0" title="0">{
                req = req.PageSize(pageSize)
        }</span>
        <span class="cov0" title="0">if pageToken != "" </span><span class="cov0" title="0">{
                req = req.PageToken(pageToken)
        }</span>
        <span class="cov0" title="0">startToken := pageToken
        nextToken := ""
        var offers []interface{}
        for </span><span class="cov0" title="0">{
                resp, err := req.Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
                }</span>
                <span class="cov0" title="0">for _, offer := range resp.SubscriptionOffers </span><span class="cov0" title="0">{
                        offers = append(offers, offer)
                }</span>
                <span class="cov0" title="0">nextToken = resp.NextPageToken
                if nextToken == "" || !all </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">req = req.PageToken(nextToken)</span>
        }
        <span class="cov0" title="0">result := output.NewResult(offers)
        result.WithPagination(startToken, nextToken)
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationOffersDelete(ctx context.Context, subscriptionID, basePlanID, offerID string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">if err := publisher.Monetization.Subscriptions.BasePlans.Offers.Delete(c.packageName, subscriptionID, basePlanID, offerID).
                Context(ctx).Do(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success": true,
                "offerId": offerID,
                "package": c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationOffersActivate(ctx context.Context, subscriptionID, basePlanID, offerID string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">resp, err := publisher.Monetization.Subscriptions.BasePlans.Offers.Activate(c.packageName, subscriptionID, basePlanID, offerID, &amp;androidpublisher.ActivateSubscriptionOfferRequest{}).
                Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">return c.Output(output.NewResult(resp).WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationOffersDeactivate(ctx context.Context, subscriptionID, basePlanID, offerID string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">resp, err := publisher.Monetization.Subscriptions.BasePlans.Offers.Deactivate(c.packageName, subscriptionID, basePlanID, offerID, &amp;androidpublisher.DeactivateSubscriptionOfferRequest{}).
                Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">return c.Output(output.NewResult(resp).WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationOffersBatchGet(ctx context.Context, subscriptionID, basePlanID string, offerIDs []string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">if len(offerIDs) == 0 </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError, "offer-ids are required"))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">requests := make([]*androidpublisher.GetSubscriptionOfferRequest, 0, len(offerIDs))
        for _, offerID := range offerIDs </span><span class="cov0" title="0">{
                requests = append(requests, &amp;androidpublisher.GetSubscriptionOfferRequest{
                        PackageName: c.packageName,
                        ProductId:   subscriptionID,
                        BasePlanId:  basePlanID,
                        OfferId:     offerID,
                })
        }</span>
        <span class="cov0" title="0">req := &amp;androidpublisher.BatchGetSubscriptionOffersRequest{
                Requests: requests,
        }
        resp, err := publisher.Monetization.Subscriptions.BasePlans.Offers.BatchGet(c.packageName, subscriptionID, basePlanID, req).
                Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">return c.Output(output.NewResult(resp).WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationOffersBatchUpdate(ctx context.Context, subscriptionID, basePlanID, filePath string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">var req androidpublisher.BatchUpdateSubscriptionOffersRequest
        if err := loadJSONFile(filePath, &amp;req); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err)
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">resp, err := publisher.Monetization.Subscriptions.BasePlans.Offers.BatchUpdate(c.packageName, subscriptionID, basePlanID, &amp;req).
                Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">return c.Output(output.NewResult(resp).WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationOffersBatchUpdateStates(ctx context.Context, subscriptionID, basePlanID, filePath string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">var req androidpublisher.BatchUpdateSubscriptionOfferStatesRequest
        if err := loadJSONFile(filePath, &amp;req); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err)
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">resp, err := publisher.Monetization.Subscriptions.BasePlans.Offers.BatchUpdateStates(c.packageName, subscriptionID, basePlanID, &amp;req).
                Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">return c.Output(output.NewResult(resp).WithServices("androidpublisher"))</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package cli

import (
        "context"
        stdErrors "errors"
        "net/http"
        "strconv"
        "strings"

        "google.golang.org/api/androidpublisher/v3"
        "google.golang.org/api/googleapi"

        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

func (c *CLI) monetizationProductsList(ctx context.Context, _ int64, pageToken string, all bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">req := publisher.Inappproducts.List(c.packageName)
        if pageToken != "" </span><span class="cov0" title="0">{
                req = req.Token(pageToken)
        }</span>

        <span class="cov0" title="0">startToken := pageToken
        nextToken := ""
        var allProducts []interface{}
        for </span><span class="cov0" title="0">{
                resp, err := req.Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        apiErr := errors.ClassifyAuthError(err)
                        if apiErr == nil </span><span class="cov0" title="0">{
                                apiErr = errors.NewAPIError(errors.CodeGeneralError, err.Error())
                        }</span>
                        <span class="cov0" title="0">var gapiErr *googleapi.Error
                        if stdErrors.As(err, &amp;gapiErr) &amp;&amp; gapiErr.Code == http.StatusForbidden &amp;&amp;
                                strings.Contains(gapiErr.Message, "Please migrate to the new publishing API") </span><span class="cov0" title="0">{
                                apiErr = apiErr.WithHint("This endpoint is legacy. Migrate to the new Play Publishing APIs or use monetization subscriptions/baseplans if applicable.")
                        }</span>
                        <span class="cov0" title="0">result := output.NewErrorResult(apiErr).WithServices("androidpublisher")
                        return c.Output(result)</span>
                }

                <span class="cov0" title="0">for _, product := range resp.Inappproduct </span><span class="cov0" title="0">{
                        allProducts = append(allProducts, map[string]interface{}{
                                "sku":             product.Sku,
                                "status":          product.Status,
                                "purchaseType":    product.PurchaseType,
                                "defaultPrice":    product.DefaultPrice,
                                "defaultLanguage": product.DefaultLanguage,
                        })
                }</span>

                <span class="cov0" title="0">nextToken = ""
                if resp.TokenPagination != nil </span><span class="cov0" title="0">{
                        nextToken = resp.TokenPagination.NextPageToken
                }</span>
                <span class="cov0" title="0">if nextToken == "" || !all </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">req = req.Token(nextToken)</span>
        }

        <span class="cov0" title="0">result := output.NewResult(allProducts)
        result.WithPagination(startToken, nextToken)
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationProductsGet(ctx context.Context, productID string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">product, err := publisher.Inappproducts.Get(c.packageName, productID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeNotFound, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "sku":             product.Sku,
                "status":          product.Status,
                "purchaseType":    product.PurchaseType,
                "defaultPrice":    product.DefaultPrice,
                "defaultLanguage": product.DefaultLanguage,
                "listings":        product.Listings,
                "prices":          product.Prices,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationProductsCreate(ctx context.Context, productID, _, defaultPrice, status string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">if productID == "" </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError,
                        "product ID is required"))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">product := &amp;androidpublisher.InAppProduct{
                PackageName:     c.packageName,
                Sku:             productID,
                Status:          status,
                DefaultLanguage: "en-US",
        }

        product.PurchaseType = "managedUser"

        if defaultPrice != "" </span><span class="cov0" title="0">{
                priceMicros, err := strconv.ParseInt(defaultPrice, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeValidationError,
                                "invalid price format - use micros (e.g., 990000 for $0.99)"))
                }</span>
                <span class="cov0" title="0">product.DefaultPrice = &amp;androidpublisher.Price{
                        Currency:    "USD",
                        PriceMicros: strconv.FormatInt(priceMicros, 10),
                }</span>
        }

        <span class="cov0" title="0">created, err := publisher.Inappproducts.Insert(c.packageName, product).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":      true,
                "productId":    created.Sku,
                "status":       created.Status,
                "purchaseType": created.PurchaseType,
                "defaultPrice": created.DefaultPrice,
                "package":      c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationProductsUpdate(ctx context.Context, productID, defaultPrice, status string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">existing, err := publisher.Inappproducts.Get(c.packageName, productID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeNotFound,
                        "product not found: "+productID))
        }</span>

        <span class="cov0" title="0">if status != "" </span><span class="cov0" title="0">{
                existing.Status = status
        }</span>
        <span class="cov0" title="0">if defaultPrice != "" </span><span class="cov0" title="0">{
                priceMicros, err := strconv.ParseInt(defaultPrice, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeValidationError,
                                "invalid price format - use micros (e.g., 990000 for $0.99)"))
                }</span>
                <span class="cov0" title="0">existing.DefaultPrice = &amp;androidpublisher.Price{
                        Currency:    "USD",
                        PriceMicros: strconv.FormatInt(priceMicros, 10),
                }</span>
        }

        <span class="cov0" title="0">updated, err := publisher.Inappproducts.Update(c.packageName, productID, existing).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":      true,
                "productId":    updated.Sku,
                "status":       updated.Status,
                "defaultPrice": updated.DefaultPrice,
                "package":      c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationProductsDelete(ctx context.Context, productID string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">err = publisher.Inappproducts.Delete(c.packageName, productID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":   true,
                "productId": productID,
                "deleted":   true,
                "package":   c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package cli

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "strings"

        "google.golang.org/api/androidpublisher/v3"

        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

func (c *CLI) monetizationSubscriptionsList(ctx context.Context, pageSize int64, pageToken string, all, showArchived bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">req := publisher.Monetization.Subscriptions.List(c.packageName)
        req = req.ShowArchived(showArchived)
        if pageSize &gt; 0 </span><span class="cov0" title="0">{
                req = req.PageSize(pageSize)
        }</span>
        <span class="cov0" title="0">if pageToken != "" </span><span class="cov0" title="0">{
                req = req.PageToken(pageToken)
        }</span>

        <span class="cov0" title="0">startToken := pageToken
        nextToken := ""
        var allSubscriptions []interface{}
        for </span><span class="cov0" title="0">{
                resp, err := req.Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
                }</span>

                <span class="cov0" title="0">for _, sub := range resp.Subscriptions </span><span class="cov0" title="0">{
                        allSubscriptions = append(allSubscriptions, map[string]interface{}{
                                "productId":   sub.ProductId,
                                "packageName": sub.PackageName,
                                "archived":    sub.Archived,
                        })
                }</span>

                <span class="cov0" title="0">nextToken = resp.NextPageToken
                if nextToken == "" || !all </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">req = req.PageToken(nextToken)</span>
        }

        <span class="cov0" title="0">result := output.NewResult(allSubscriptions)
        result.WithPagination(startToken, nextToken)
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationSubscriptionsGet(ctx context.Context, subscriptionID string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">sub, err := publisher.Monetization.Subscriptions.Get(c.packageName, subscriptionID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeNotFound, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "productId":   sub.ProductId,
                "packageName": sub.PackageName,
                "archived":    sub.Archived,
                "basePlans":   sub.BasePlans,
                "listings":    sub.Listings,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationSubscriptionsCreate(ctx context.Context, subscriptionID, filePath string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">var sub androidpublisher.Subscription
        if err := loadJSONFile(filePath, &amp;sub); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err)
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">created, err := publisher.Monetization.Subscriptions.Create(c.packageName, &amp;sub).
                ProductId(subscriptionID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(created)
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationSubscriptionsUpdate(ctx context.Context, subscriptionID, filePath string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">var sub androidpublisher.Subscription
        if err := loadJSONFile(filePath, &amp;sub); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err)
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">updated, err := publisher.Monetization.Subscriptions.Patch(c.packageName, subscriptionID, &amp;sub).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(updated)
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationSubscriptionsPatch(ctx context.Context, subscriptionID, filePath, updateMask string, allowMissing bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">var sub androidpublisher.Subscription
        if err := loadJSONFile(filePath, &amp;sub); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err)
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">call := publisher.Monetization.Subscriptions.Patch(c.packageName, subscriptionID, &amp;sub).
                AllowMissing(allowMissing)
        if updateMask != "" </span><span class="cov0" title="0">{
                call = call.UpdateMask(updateMask)
        }</span>

        <span class="cov0" title="0">updated, err := call.Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(updated)
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationSubscriptionsDelete(ctx context.Context, subscriptionID string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">if err := publisher.Monetization.Subscriptions.Delete(c.packageName, subscriptionID).Context(ctx).Do(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":   true,
                "productId": subscriptionID,
                "package":   c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationSubscriptionsArchive(ctx context.Context, subscriptionID string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">resp, err := publisher.Monetization.Subscriptions.Archive(c.packageName, subscriptionID, &amp;androidpublisher.ArchiveSubscriptionRequest{}).
                Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(resp)
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationSubscriptionsBatchGet(ctx context.Context, ids []string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError, "ids are required"))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">resp, err := publisher.Monetization.Subscriptions.BatchGet(c.packageName).ProductIds(ids...).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(resp)
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationSubscriptionsBatchUpdate(ctx context.Context, filePath string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">var req androidpublisher.BatchUpdateSubscriptionsRequest
        if err := loadJSONFile(filePath, &amp;req); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err)
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">resp, err := publisher.Monetization.Subscriptions.BatchUpdate(c.packageName, &amp;req).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(resp)
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationConvertRegionPrices(ctx context.Context, priceMicros int64, currencyCode string, regionFilter []string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">if priceMicros &lt;= 0 </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError, "price-micros must be greater than zero"))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">units := priceMicros / 1_000_000
        nanos := (priceMicros % 1_000_000) * 1000
        req := &amp;androidpublisher.ConvertRegionPricesRequest{
                Price: &amp;androidpublisher.Money{
                        CurrencyCode: strings.ToUpper(currencyCode),
                        Units:        units,
                        Nanos:        nanos,
                },
        }
        resp, err := publisher.Monetization.ConvertRegionPrices(c.packageName, req).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">if len(regionFilter) &gt; 0 &amp;&amp; resp.ConvertedRegionPrices != nil </span><span class="cov0" title="0">{
                filtered := make(map[string]androidpublisher.ConvertedRegionPrice)
                for _, code := range regionFilter </span><span class="cov0" title="0">{
                        if val, ok := resp.ConvertedRegionPrices[strings.ToUpper(code)]; ok </span><span class="cov0" title="0">{
                                filtered[strings.ToUpper(code)] = val
                        }</span>
                }
                <span class="cov0" title="0">resp.ConvertedRegionPrices = filtered</span>
        }

        <span class="cov0" title="0">return c.Output(output.NewResult(resp).WithServices("androidpublisher"))</span>
}

func (c *CLI) monetizationCapabilities(_ context.Context) error <span class="cov0" title="0">{
        result := output.NewResult(map[string]interface{}{
                "products": map[string]interface{}{
                        "supportedTypes": []string{"managed", "consumable"},
                        "operations":     []string{"list", "get", "create", "update", "delete"},
                },
                "subscriptions": map[string]interface{}{
                        "operations": []string{"list", "get", "create", "update", "patch", "delete", "archive", "batchGet", "batchUpdate"},
                },
                "basePlans": map[string]interface{}{
                        "operations": []string{"activate", "deactivate", "delete", "migrate-prices", "batch-migrate-prices", "batch-update-states"},
                },
                "offers": map[string]interface{}{
                        "operations": []string{"create", "get", "list", "delete", "activate", "deactivate", "batchGet", "batchUpdate", "batchUpdateStates"},
                },
                "regionalPricing": map[string]interface{}{
                        "operations": []string{"convert-region-prices"},
                },
                "apiLimitations": []string{
                        "Offer updates use batch update endpoint",
                },
        })
        return c.Output(result.WithServices("androidpublisher"))
}</span>

func loadJSONFile(path string, out interface{}) *errors.APIError <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return errors.NewAPIError(errors.CodeValidationError, fmt.Sprintf("failed to read file: %s", path))
        }</span>
        <span class="cov0" title="0">if err := json.Unmarshal(data, out); err != nil </span><span class="cov0" title="0">{
                return errors.NewAPIError(errors.CodeValidationError, "invalid JSON file")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package cli

import "github.com/spf13/cobra"

func addPaginationFlags(cmd *cobra.Command, all *bool) <span class="cov10" title="396">{
        cmd.Flags().BoolVar(all, "all", false, "Fetch all pages")
        cmd.Flags().BoolVar(all, "paginate", false, "Fetch all pages")
        _ = cmd.Flags().MarkDeprecated("paginate", "use --all instead")
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package cli

import (
        "context"
        "encoding/json"
        stdErrors "errors"
        "net/http"
        "os"
        "strings"

        "github.com/spf13/cobra"
        "google.golang.org/api/androidpublisher/v3"
        "google.golang.org/api/googleapi"

        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

var validDeveloperPermissions = []string{
        "CAN_VIEW_FINANCIAL_DATA_GLOBAL",
        "CAN_MANAGE_PERMISSIONS_GLOBAL",
        "CAN_EDIT_GAMES_GLOBAL",
        "CAN_PUBLISH_GAMES_GLOBAL",
        "CAN_REPLY_TO_REVIEWS_GLOBAL",
        "CAN_MANAGE_PUBLIC_APKS_GLOBAL",
        "CAN_MANAGE_TRACK_APKS_GLOBAL",
        "CAN_MANAGE_TRACK_USERS_GLOBAL",
        "CAN_MANAGE_PUBLIC_LISTING_GLOBAL",
        "CAN_MANAGE_DRAFT_APPS_GLOBAL",
        "CAN_CREATE_MANAGED_PLAY_APPS_GLOBAL",
        "CAN_CHANGE_MANAGED_PLAY_SETTING_GLOBAL",
        "CAN_MANAGE_ORDERS_GLOBAL",
        "CAN_MANAGE_APP_CONTENT_GLOBAL",
        "CAN_VIEW_NON_FINANCIAL_DATA_GLOBAL",
        "CAN_VIEW_APP_QUALITY_GLOBAL",
        "CAN_MANAGE_DEEPLINKS_GLOBAL",
}

func (c *CLI) addPermissionsCommands() <span class="cov10" title="18">{
        permissionsCmd := &amp;cobra.Command{
                Use:   "permissions",
                Short: "Permissions management commands",
                Long:  "Manage users and grants for developer accounts and apps.",
        }

        c.addUsersCommands(permissionsCmd)
        c.addGrantsCommands(permissionsCmd)
        c.addPermissionsCapabilitiesCommand(permissionsCmd)

        c.rootCmd.AddCommand(permissionsCmd)
}</span>

func (c *CLI) addUsersCommands(parent *cobra.Command) <span class="cov10" title="18">{
        usersCmd := &amp;cobra.Command{
                Use:   "users",
                Short: "Manage developer account users",
                Long:  "List, create, update, and delete users with access to the developer account.",
        }

        var (
                developerID          string
                email                string
                developerPermissions []string
                expirationTime       string
                pageSize             int64
                pageToken            string
                all                  bool
                userFile             string
        )

        usersCreateCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "Create a user in the developer account",
                Long:  "Grants access for a user to the developer account by email.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if developerID == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--developer-id is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">if email == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--email is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.permissionsUsersCreate(cmd.Context(), developerID, email, developerPermissions, expirationTime)</span>
                },
        }
        <span class="cov10" title="18">usersCreateCmd.Flags().StringVar(&amp;developerID, "developer-id", "", "Developer account ID (required)")
        usersCreateCmd.Flags().StringVar(&amp;email, "email", "", "User email address (required)")
        usersCreateCmd.Flags().StringSliceVar(&amp;developerPermissions, "developer-permissions", nil, "Developer-level permissions (comma-separated)")
        usersCreateCmd.Flags().StringVar(&amp;expirationTime, "expiration-time", "", "Access expiration time (RFC3339 format)")

        usersListCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List all users in the developer account",
                Long:  "Lists all users with access to the developer account with pagination support.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if developerID == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--developer-id is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.permissionsUsersList(cmd.Context(), developerID, pageSize, pageToken, all)</span>
                },
        }
        <span class="cov10" title="18">usersListCmd.Flags().StringVar(&amp;developerID, "developer-id", "", "Developer account ID (required)")
        usersListCmd.Flags().Int64Var(&amp;pageSize, "page-size", 100, "Results per page")
        usersListCmd.Flags().StringVar(&amp;pageToken, "page-token", "", "Pagination token")
        addPaginationFlags(usersListCmd, &amp;all)

        usersDeleteCmd := &amp;cobra.Command{
                Use:   "delete [name]",
                Short: "Remove a user from the developer account",
                Long:  "Removes all access for the user to the developer account. Name format: developers/{developer}/users/{email}",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.permissionsUsersDelete(cmd.Context(), args[0])
                }</span>,
        }

        <span class="cov10" title="18">usersPatchCmd := &amp;cobra.Command{
                Use:   "patch [name]",
                Short: "Update user permissions",
                Long:  "Updates access for the user to the developer account. Name format: developers/{developer}/users/{email}",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if userFile == "" &amp;&amp; len(developerPermissions) == 0 &amp;&amp; expirationTime == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "at least one of --developer-permissions, --expiration-time, or --file is required")).
                                        WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.permissionsUsersPatch(cmd.Context(), args[0], developerPermissions, expirationTime, userFile)</span>
                },
        }
        <span class="cov10" title="18">usersPatchCmd.Flags().StringSliceVar(&amp;developerPermissions, "developer-permissions", nil, "Developer-level permissions (comma-separated)")
        usersPatchCmd.Flags().StringVar(&amp;expirationTime, "expiration-time", "", "Access expiration time (RFC3339 format)")
        usersPatchCmd.Flags().StringVar(&amp;userFile, "file", "", "User JSON file for patch data")

        usersGetCmd := &amp;cobra.Command{
                Use:   "get [name]",
                Short: "Get a user's details",
                Long:  "Gets details for a specific user. Name format: developers/{developer}/users/{email}",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.permissionsUsersGet(cmd.Context(), args[0])
                }</span>,
        }

        <span class="cov10" title="18">usersCmd.AddCommand(usersCreateCmd, usersListCmd, usersDeleteCmd, usersPatchCmd, usersGetCmd)
        parent.AddCommand(usersCmd)</span>
}

func (c *CLI) addGrantsCommands(parent *cobra.Command) <span class="cov10" title="18">{
        grantsCmd := &amp;cobra.Command{
                Use:   "grants",
                Short: "Manage app-level permission grants",
                Long:  "Create, update, and delete app-level permission grants for users.",
        }

        var (
                email           string
                appPermissions  []string
                grantFile       string
                listPermissions bool
        )

        grantsCreateCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "Grant user access to an app",
                Long:  "Creates an app-level grant for a user. Requires --package flag.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if listPermissions </span><span class="cov0" title="0">{
                                return c.permissionsListAvailable(cmd.Context())
                        }</span>
                        <span class="cov0" title="0">if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">if email == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--email is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.permissionsGrantsCreate(cmd.Context(), email, appPermissions)</span>
                },
        }
        <span class="cov10" title="18">grantsCreateCmd.Flags().StringVar(&amp;email, "email", "", "User email address (required)")
        grantsCreateCmd.Flags().StringSliceVar(&amp;appPermissions, "app-permissions", nil, "App-level permissions (comma-separated)")
        grantsCreateCmd.Flags().BoolVar(&amp;listPermissions, "list-permissions", false, "List available app-level permission names")

        grantsDeleteCmd := &amp;cobra.Command{
                Use:   "delete [name]",
                Short: "Revoke a user's grant",
                Long:  "Deletes an app-level grant. Name format: developers/{developer}/users/{email}/grants/{package_name}",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.permissionsGrantsDelete(cmd.Context(), args[0])
                }</span>,
        }

        <span class="cov10" title="18">grantsPatchCmd := &amp;cobra.Command{
                Use:   "patch [name]",
                Short: "Update a user's grant",
                Long:  "Updates an app-level grant. Name format: developers/{developer}/users/{email}/grants/{package_name}",
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if listPermissions </span><span class="cov0" title="0">{
                                return c.permissionsListAvailable(cmd.Context())
                        }</span>
                        <span class="cov0" title="0">if len(args) == 0 </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "grant name argument is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">if grantFile == "" &amp;&amp; len(appPermissions) == 0 </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "at least one of --app-permissions or --file is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.permissionsGrantsPatch(cmd.Context(), args[0], appPermissions, grantFile)</span>
                },
        }
        <span class="cov10" title="18">grantsPatchCmd.Flags().StringSliceVar(&amp;appPermissions, "app-permissions", nil, "App-level permissions (comma-separated)")
        grantsPatchCmd.Flags().StringVar(&amp;grantFile, "file", "", "Grant JSON file for patch data")
        grantsPatchCmd.Flags().BoolVar(&amp;listPermissions, "list-permissions", false, "List available app-level permission names")

        grantsCmd.AddCommand(grantsCreateCmd, grantsDeleteCmd, grantsPatchCmd)
        parent.AddCommand(grantsCmd)</span>
}

func (c *CLI) addPermissionsCapabilitiesCommand(parent *cobra.Command) <span class="cov10" title="18">{
        capabilitiesCmd := &amp;cobra.Command{
                Use:   "capabilities",
                Short: "List permissions management capabilities",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.permissionsCapabilities(cmd.Context())
                }</span>,
        }
        <span class="cov10" title="18">parent.AddCommand(capabilitiesCmd)</span>
}

func (c *CLI) permissionsUsersCreate(ctx context.Context, developerID, email string, permissions []string, expirationTime string) error <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">user := &amp;androidpublisher.User{
                Email: email,
        }

        if len(permissions) &gt; 0 </span><span class="cov0" title="0">{
                for _, perm := range permissions </span><span class="cov0" title="0">{
                        if !isValidDeveloperPermission(perm) </span><span class="cov0" title="0">{
                                return c.OutputError(errors.NewAPIError(errors.CodeValidationError,
                                        "invalid developer permission: "+perm).
                                        WithHint("Valid permissions: " + strings.Join(validDeveloperPermissions, ", ")))
                        }</span>
                }
                <span class="cov0" title="0">user.DeveloperAccountPermissions = permissions</span>
        }

        <span class="cov0" title="0">if expirationTime != "" </span><span class="cov0" title="0">{
                user.ExpirationTime = expirationTime
        }</span>

        <span class="cov0" title="0">parent := "developers/" + developerID
        created, err := publisher.Users.Create(parent, user).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":                     true,
                "name":                        created.Name,
                "email":                       created.Email,
                "accessState":                 created.AccessState,
                "developerAccountPermissions": created.DeveloperAccountPermissions,
                "expirationTime":              created.ExpirationTime,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) permissionsUsersList(ctx context.Context, developerID string, pageSize int64, pageToken string, all bool) error <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">parent := "developers/" + developerID
        req := publisher.Users.List(parent)
        if pageSize &gt; 0 </span><span class="cov0" title="0">{
                req = req.PageSize(pageSize)
        }</span>
        <span class="cov0" title="0">if pageToken != "" </span><span class="cov0" title="0">{
                req = req.PageToken(pageToken)
        }</span>

        <span class="cov0" title="0">startToken := pageToken
        nextToken := ""
        var allUsers []interface{}
        for </span><span class="cov0" title="0">{
                resp, err := req.Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        apiErr := errors.ClassifyAuthError(err)
                        if apiErr == nil </span><span class="cov0" title="0">{
                                apiErr = errors.NewAPIError(errors.CodeGeneralError, err.Error())
                        }</span>
                        <span class="cov0" title="0">var gapiErr *googleapi.Error
                        if stdErrors.As(err, &amp;gapiErr) &amp;&amp; gapiErr.Code == http.StatusBadRequest &amp;&amp;
                                strings.Contains(gapiErr.Message, "Invalid Developer ID") </span><span class="cov0" title="0">{
                                apiErr = apiErr.WithHint("Developer ID is in the Play Console URL: https://play.google.com/console/u/0/developers/&lt;id&gt;")
                        }</span>
                        <span class="cov0" title="0">result := output.NewErrorResult(apiErr).WithServices("androidpublisher")
                        return c.Output(result)</span>
                }

                <span class="cov0" title="0">for _, user := range resp.Users </span><span class="cov0" title="0">{
                        allUsers = append(allUsers, map[string]interface{}{
                                "name":                        user.Name,
                                "email":                       user.Email,
                                "accessState":                 user.AccessState,
                                "developerAccountPermissions": user.DeveloperAccountPermissions,
                                "expirationTime":              user.ExpirationTime,
                                "partial":                     user.Partial,
                        })
                }</span>

                <span class="cov0" title="0">nextToken = resp.NextPageToken
                if nextToken == "" || !all </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">req = req.PageToken(nextToken)</span>
        }

        <span class="cov0" title="0">result := output.NewResult(allUsers)
        result.WithPagination(startToken, nextToken)
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) permissionsUsersDelete(ctx context.Context, name string) error <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">err = publisher.Users.Delete(name).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success": true,
                "name":    name,
                "deleted": true,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) permissionsUsersPatch(ctx context.Context, name string, permissions []string, expirationTime, userFile string) error <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">var user androidpublisher.User
        var updateMask []string

        if userFile != "" </span><span class="cov0" title="0">{
                data, err := os.ReadFile(userFile)
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeValidationError,
                                "failed to read file: "+userFile))
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(data, &amp;user); err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeValidationError, "invalid JSON file"))
                }</span>
        }

        <span class="cov0" title="0">if len(permissions) &gt; 0 </span><span class="cov0" title="0">{
                for _, perm := range permissions </span><span class="cov0" title="0">{
                        if !isValidDeveloperPermission(perm) </span><span class="cov0" title="0">{
                                return c.OutputError(errors.NewAPIError(errors.CodeValidationError,
                                        "invalid developer permission: "+perm).
                                        WithHint("Valid permissions: " + strings.Join(validDeveloperPermissions, ", ")))
                        }</span>
                }
                <span class="cov0" title="0">user.DeveloperAccountPermissions = permissions
                updateMask = append(updateMask, "developerAccountPermissions")</span>
        }

        <span class="cov0" title="0">if expirationTime != "" </span><span class="cov0" title="0">{
                user.ExpirationTime = expirationTime
                updateMask = append(updateMask, "expirationTime")
        }</span>

        <span class="cov0" title="0">call := publisher.Users.Patch(name, &amp;user)
        if len(updateMask) &gt; 0 </span><span class="cov0" title="0">{
                call = call.UpdateMask(strings.Join(updateMask, ","))
        }</span>

        <span class="cov0" title="0">updated, err := call.Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":                     true,
                "name":                        updated.Name,
                "email":                       updated.Email,
                "accessState":                 updated.AccessState,
                "developerAccountPermissions": updated.DeveloperAccountPermissions,
                "expirationTime":              updated.ExpirationTime,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) permissionsUsersGet(ctx context.Context, name string) error <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">parts := strings.Split(name, "/")
        if len(parts) &lt; 4 || parts[0] != "developers" || parts[2] != "users" </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError,
                        "invalid user name format").
                        WithHint("Expected format: developers/{developer}/users/{email}"))
        }</span>

        <span class="cov0" title="0">developerID := parts[1]
        parent := "developers/" + developerID

        resp, err := publisher.Users.List(parent).PageSize(100).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">for _, user := range resp.Users </span><span class="cov0" title="0">{
                if user.Name == name </span><span class="cov0" title="0">{
                        result := output.NewResult(map[string]interface{}{
                                "name":                        user.Name,
                                "email":                       user.Email,
                                "accessState":                 user.AccessState,
                                "developerAccountPermissions": user.DeveloperAccountPermissions,
                                "expirationTime":              user.ExpirationTime,
                                "partial":                     user.Partial,
                                "grants":                      user.Grants,
                        })
                        return c.Output(result.WithServices("androidpublisher"))
                }</span>
        }

        <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeNotFound, "user not found: "+name))</span>
}

func (c *CLI) permissionsGrantsCreate(ctx context.Context, email string, permissions []string) error <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">grant := &amp;androidpublisher.Grant{
                PackageName: c.packageName,
        }

        if len(permissions) &gt; 0 </span><span class="cov0" title="0">{
                grant.AppLevelPermissions = permissions
        }</span>

        <span class="cov0" title="0">parent := "developers/-/users/" + email
        created, err := publisher.Grants.Create(parent, grant).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":             true,
                "name":                created.Name,
                "packageName":         created.PackageName,
                "appLevelPermissions": created.AppLevelPermissions,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) permissionsGrantsDelete(ctx context.Context, name string) error <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">err = publisher.Grants.Delete(name).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success": true,
                "name":    name,
                "deleted": true,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) permissionsGrantsPatch(ctx context.Context, name string, permissions []string, grantFile string) error <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">var grant androidpublisher.Grant
        var updateMask []string

        if grantFile != "" </span><span class="cov0" title="0">{
                data, err := os.ReadFile(grantFile)
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeValidationError,
                                "failed to read file: "+grantFile))
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(data, &amp;grant); err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeValidationError, "invalid JSON file"))
                }</span>
        }

        <span class="cov0" title="0">if len(permissions) &gt; 0 </span><span class="cov0" title="0">{
                grant.AppLevelPermissions = permissions
                updateMask = append(updateMask, "appLevelPermissions")
        }</span>

        <span class="cov0" title="0">call := publisher.Grants.Patch(name, &amp;grant)
        if len(updateMask) &gt; 0 </span><span class="cov0" title="0">{
                call = call.UpdateMask(strings.Join(updateMask, ","))
        }</span>

        <span class="cov0" title="0">updated, err := call.Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":             true,
                "name":                updated.Name,
                "packageName":         updated.PackageName,
                "appLevelPermissions": updated.AppLevelPermissions,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

var validAppLevelPermissions = []string{
        "CAN_VIEW_FINANCIAL_DATA",
        "CAN_MANAGE_PERMISSIONS",
        "CAN_REPLY_TO_REVIEWS",
        "CAN_MANAGE_PUBLIC_APKS",
        "CAN_MANAGE_TRACK_APKS",
        "CAN_MANAGE_TRACK_USERS",
        "CAN_MANAGE_PUBLIC_LISTING",
        "CAN_MANAGE_DRAFT_APPS",
        "CAN_MANAGE_ORDERS",
        "CAN_MANAGE_APP_CONTENT",
        "CAN_VIEW_NON_FINANCIAL_DATA",
        "CAN_VIEW_APP_QUALITY",
        "CAN_MANAGE_DEEPLINKS",
}

func (c *CLI) permissionsListAvailable(_ context.Context) error <span class="cov0" title="0">{
        appPermDescriptions := map[string]string{
                "CAN_VIEW_FINANCIAL_DATA":     "View financial data and reports",
                "CAN_MANAGE_PERMISSIONS":      "Admin - manage all permissions",
                "CAN_REPLY_TO_REVIEWS":        "Reply to user reviews",
                "CAN_MANAGE_PUBLIC_APKS":      "Release to production, manage app signing",
                "CAN_MANAGE_TRACK_APKS":       "Release to testing tracks",
                "CAN_MANAGE_TRACK_USERS":      "Manage testing tracks and tester lists",
                "CAN_MANAGE_PUBLIC_LISTING":   "Manage store listing and presence",
                "CAN_MANAGE_DRAFT_APPS":       "Edit and delete draft apps",
                "CAN_MANAGE_ORDERS":           "Manage orders and subscriptions",
                "CAN_MANAGE_APP_CONTENT":      "Manage policy-related pages",
                "CAN_VIEW_NON_FINANCIAL_DATA": "View app information (read-only)",
                "CAN_VIEW_APP_QUALITY":        "View app quality data (Vitals, Crashes)",
                "CAN_MANAGE_DEEPLINKS":        "Manage deep links setup",
        }

        devPermDescriptions := map[string]string{
                "CAN_VIEW_FINANCIAL_DATA_GLOBAL":         "View financial data globally",
                "CAN_MANAGE_PERMISSIONS_GLOBAL":          "Admin - manage all permissions globally",
                "CAN_EDIT_GAMES_GLOBAL":                  "Edit games globally",
                "CAN_PUBLISH_GAMES_GLOBAL":               "Publish games globally",
                "CAN_REPLY_TO_REVIEWS_GLOBAL":            "Reply to reviews globally",
                "CAN_MANAGE_PUBLIC_APKS_GLOBAL":          "Manage production releases globally",
                "CAN_MANAGE_TRACK_APKS_GLOBAL":           "Manage testing releases globally",
                "CAN_MANAGE_TRACK_USERS_GLOBAL":          "Manage track users globally",
                "CAN_MANAGE_PUBLIC_LISTING_GLOBAL":       "Manage store listings globally",
                "CAN_MANAGE_DRAFT_APPS_GLOBAL":           "Manage draft apps globally",
                "CAN_CREATE_MANAGED_PLAY_APPS_GLOBAL":    "Create managed Play apps globally",
                "CAN_CHANGE_MANAGED_PLAY_SETTING_GLOBAL": "Change managed Play settings globally",
                "CAN_MANAGE_ORDERS_GLOBAL":               "Manage orders globally",
                "CAN_MANAGE_APP_CONTENT_GLOBAL":          "Manage app content globally",
                "CAN_VIEW_NON_FINANCIAL_DATA_GLOBAL":     "View non-financial data globally",
                "CAN_VIEW_APP_QUALITY_GLOBAL":            "View app quality data globally",
                "CAN_MANAGE_DEEPLINKS_GLOBAL":            "Manage deep links globally",
        }

        appPerms := make([]map[string]interface{}, 0, len(validAppLevelPermissions))
        for _, perm := range validAppLevelPermissions </span><span class="cov0" title="0">{
                appPerms = append(appPerms, map[string]interface{}{
                        "name":        perm,
                        "description": appPermDescriptions[perm],
                })
        }</span>

        <span class="cov0" title="0">devPerms := make([]map[string]interface{}, 0, len(validDeveloperPermissions))
        for _, perm := range validDeveloperPermissions </span><span class="cov0" title="0">{
                devPerms = append(devPerms, map[string]interface{}{
                        "name":        perm,
                        "description": devPermDescriptions[perm],
                })
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "appLevelPermissions":  appPerms,
                "developerPermissions": devPerms,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) permissionsCapabilities(_ context.Context) error <span class="cov0" title="0">{
        result := output.NewResult(map[string]interface{}{
                "users": map[string]interface{}{
                        "operations":           []string{"create", "list", "get", "patch", "delete"},
                        "developerPermissions": validDeveloperPermissions,
                        "accessStates": []string{
                                "ACCESS_STATE_UNSPECIFIED",
                                "INVITED",
                                "INVITATION_EXPIRED",
                                "ACCESS_GRANTED",
                                "ACCESS_EXPIRED",
                        },
                },
                "grants": map[string]interface{}{
                        "operations":          []string{"create", "patch", "delete"},
                        "appLevelPermissions": validAppLevelPermissions,
                },
                "notes": []string{
                        "User name format: developers/{developer}/users/{email}",
                        "Grant name format: developers/{developer}/users/{email}/grants/{package_name}",
                        "Developer ID can be found in Play Console URL",
                        "Use --list-permissions flag to see detailed permission descriptions",
                },
        })
        return c.Output(result.WithServices("androidpublisher"))
}</span>

func isValidDeveloperPermission(perm string) bool <span class="cov0" title="0">{
        for _, valid := range validDeveloperPermissions </span><span class="cov0" title="0">{
                if valid == perm </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package cli

import (
        "context"
        "fmt"
        "strconv"
        "strings"

        "github.com/spf13/cobra"

        "google.golang.org/api/androidpublisher/v3"

        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/logging"
        "github.com/dl-alexandre/gpd/internal/output"
)

type buildType string

const (
        buildTypeAll    buildType = "all"
        buildTypeAPK    buildType = "apk"
        buildTypeBundle buildType = "bundle"
)

func (c *CLI) addPublishBuildsCommands(publishCmd *cobra.Command) <span class="cov10" title="18">{
        buildsCmd := &amp;cobra.Command{
                Use:   "builds",
                Short: "Manage uploaded builds",
                Long:  "List and inspect APKs and App Bundles uploaded in an edit.",
        }

        var (
                buildKind string
                editID    string
        )

        buildsListCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List uploaded builds",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishBuildsList(cmd.Context(), buildKind, editID)
                }</span>,
        }
        <span class="cov10" title="18">buildsListCmd.Flags().StringVar(&amp;buildKind, "type", "all", "Build type (apk, bundle, all)")
        buildsListCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")

        buildsGetCmd := &amp;cobra.Command{
                Use:     "get &lt;version-code&gt;",
                Aliases: []string{"info"},
                Short:   "Get build details",
                Args:    cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        versionCode, err := strconv.ParseInt(args[0], 10, 64)
                        if err != nil || versionCode &lt;= 0 </span><span class="cov0" title="0">{
                                return c.OutputError(errors.NewAPIError(errors.CodeValidationError,
                                        "version code must be a positive integer"))
                        }</span>
                        <span class="cov0" title="0">return c.publishBuildsGet(cmd.Context(), versionCode, buildKind, editID)</span>
                },
        }
        <span class="cov10" title="18">buildsGetCmd.Flags().StringVar(&amp;buildKind, "type", "all", "Build type (apk, bundle, all)")
        buildsGetCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")

        var (
                expireConfirm  bool
                expireDryRun   bool
                expireNoCommit bool
        )

        buildsExpireCmd := &amp;cobra.Command{
                Use:   "expire &lt;version-code&gt;",
                Short: "Expire a build from tracks",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        versionCode, err := strconv.ParseInt(args[0], 10, 64)
                        if err != nil || versionCode &lt;= 0 </span><span class="cov0" title="0">{
                                return c.OutputError(errors.NewAPIError(errors.CodeValidationError,
                                        "version code must be a positive integer"))
                        }</span>
                        <span class="cov0" title="0">return c.publishBuildsExpire(cmd.Context(), versionCode, editID, expireNoCommit, expireDryRun, expireConfirm)</span>
                },
        }
        <span class="cov10" title="18">buildsExpireCmd.Flags().BoolVar(&amp;expireConfirm, "confirm", false, "Confirm destructive operation")
        buildsExpireCmd.Flags().BoolVar(&amp;expireDryRun, "dry-run", false, "Show intended actions without executing")
        buildsExpireCmd.Flags().BoolVar(&amp;expireNoCommit, "no-auto-commit", false, "Keep edit open for manual commit")
        buildsExpireCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")

        buildsExpireAllCmd := &amp;cobra.Command{
                Use:   "expire-all",
                Short: "Expire all builds from tracks",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishBuildsExpireAll(cmd.Context(), editID, expireNoCommit, expireDryRun, expireConfirm)
                }</span>,
        }
        <span class="cov10" title="18">buildsExpireAllCmd.Flags().BoolVar(&amp;expireConfirm, "confirm", false, "Confirm destructive operation")
        buildsExpireAllCmd.Flags().BoolVar(&amp;expireDryRun, "dry-run", false, "Show intended actions without executing")
        buildsExpireAllCmd.Flags().BoolVar(&amp;expireNoCommit, "no-auto-commit", false, "Keep edit open for manual commit")
        buildsExpireAllCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")

        buildsCmd.AddCommand(buildsListCmd, buildsGetCmd, buildsExpireCmd, buildsExpireAllCmd)
        publishCmd.AddCommand(buildsCmd)</span>
}

func (c *CLI) publishBuildsList(ctx context.Context, buildKind, editID string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">kind, apiErr := normalizeBuildType(buildKind)
        if apiErr != nil </span><span class="cov0" title="0">{
                return c.OutputError(apiErr)
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">activeEditID := editID
        if activeEditID == "" </span><span class="cov0" title="0">{
                edit, err := publisher.Edits.Insert(c.packageName, nil).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                                fmt.Sprintf("failed to create edit: %v", err)))
                }</span>
                <span class="cov0" title="0">activeEditID = edit.Id
                defer func() </span><span class="cov0" title="0">{
                        if err := publisher.Edits.Delete(c.packageName, activeEditID).Context(ctx).Do(); err != nil </span><span class="cov0" title="0">{
                                logging.Warn("failed to delete edit", logging.String("package", c.packageName), logging.String("editId", activeEditID), logging.Err(err))
                        }</span>
                }()
        }

        <span class="cov0" title="0">result := map[string]interface{}{
                "package": c.packageName,
                "editId":  activeEditID,
        }

        if kind == buildTypeAll || kind == buildTypeBundle </span><span class="cov0" title="0">{
                bundles, err := publisher.Edits.Bundles.List(c.packageName, activeEditID).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
                }</span>
                <span class="cov0" title="0">result["bundles"] = bundles.Bundles</span>
        }
        <span class="cov0" title="0">if kind == buildTypeAll || kind == buildTypeAPK </span><span class="cov0" title="0">{
                apks, err := publisher.Edits.Apks.List(c.packageName, activeEditID).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
                }</span>
                <span class="cov0" title="0">result["apks"] = apks.Apks</span>
        }

        <span class="cov0" title="0">return c.Output(output.NewResult(result).WithServices("androidpublisher"))</span>
}

func (c *CLI) publishBuildsGet(ctx context.Context, versionCode int64, buildKind, editID string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">kind, apiErr := normalizeBuildType(buildKind)
        if apiErr != nil </span><span class="cov0" title="0">{
                return c.OutputError(apiErr)
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">activeEditID := editID
        if activeEditID == "" </span><span class="cov0" title="0">{
                edit, err := publisher.Edits.Insert(c.packageName, nil).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                                fmt.Sprintf("failed to create edit: %v", err)))
                }</span>
                <span class="cov0" title="0">activeEditID = edit.Id
                defer func() </span><span class="cov0" title="0">{
                        if err := publisher.Edits.Delete(c.packageName, activeEditID).Context(ctx).Do(); err != nil </span><span class="cov0" title="0">{
                                logging.Warn("failed to delete edit", logging.String("package", c.packageName), logging.String("editId", activeEditID), logging.Err(err))
                        }</span>
                }()
        }

        <span class="cov0" title="0">result := map[string]interface{}{
                "package":     c.packageName,
                "editId":      activeEditID,
                "versionCode": versionCode,
        }

        found := false
        if kind == buildTypeAll || kind == buildTypeBundle </span><span class="cov0" title="0">{
                bundles, err := publisher.Edits.Bundles.List(c.packageName, activeEditID).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
                }</span>
                <span class="cov0" title="0">for _, bundle := range bundles.Bundles </span><span class="cov0" title="0">{
                        if bundle.VersionCode == versionCode </span><span class="cov0" title="0">{
                                result["bundle"] = bundle
                                found = true
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">if kind == buildTypeAll || kind == buildTypeAPK </span><span class="cov0" title="0">{
                apks, err := publisher.Edits.Apks.List(c.packageName, activeEditID).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
                }</span>
                <span class="cov0" title="0">for _, apk := range apks.Apks </span><span class="cov0" title="0">{
                        if apk.VersionCode == versionCode </span><span class="cov0" title="0">{
                                result["apk"] = apk
                                found = true
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeNotFound,
                        fmt.Sprintf("build not found for version code %d", versionCode)))
        }</span>

        <span class="cov0" title="0">return c.Output(output.NewResult(result).WithServices("androidpublisher"))</span>
}

func (c *CLI) publishBuildsExpire(ctx context.Context, versionCode int64, editID string, noAutoCommit, dryRun, confirm bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">if !confirm </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError,
                        "--confirm flag required for destructive operations"))
        }</span>
        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                result := output.NewResult(map[string]interface{}{
                        "dryRun":      true,
                        "action":      "builds_expire",
                        "versionCode": versionCode,
                        "package":     c.packageName,
                })
                return c.Output(result.WithServices("androidpublisher"))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr, edit, created, err := c.prepareEdit(ctx, publisher, editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = editMgr.ReleaseLock(c.packageName) }</span>()

        <span class="cov0" title="0">tracksResp, err := publisher.Edits.Tracks.List(c.packageName, edit.ServerID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        _ = publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do()
                }</span>
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))</span>
        }

        <span class="cov0" title="0">updatedTracks := make([]string, 0)
        removedCount := 0
        for _, track := range tracksResp.Tracks </span><span class="cov0" title="0">{
                changed := false
                updatedReleases := make([]*androidpublisher.TrackRelease, 0, len(track.Releases))
                for _, release := range track.Releases </span><span class="cov0" title="0">{
                        remaining := make([]int64, 0, len(release.VersionCodes))
                        for _, vc := range release.VersionCodes </span><span class="cov0" title="0">{
                                if vc == versionCode </span><span class="cov0" title="0">{
                                        removedCount++
                                        changed = true
                                        continue</span>
                                }
                                <span class="cov0" title="0">remaining = append(remaining, vc)</span>
                        }
                        <span class="cov0" title="0">if len(remaining) == 0 </span><span class="cov0" title="0">{
                                if len(release.VersionCodes) &gt; 0 </span><span class="cov0" title="0">{
                                        changed = true
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov0" title="0">release.VersionCodes = remaining
                        updatedReleases = append(updatedReleases, release)</span>
                }
                <span class="cov0" title="0">if !changed </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">track.Releases = updatedReleases
                if _, err := publisher.Edits.Tracks.Update(c.packageName, edit.ServerID, track.Track, track).Context(ctx).Do(); err != nil </span><span class="cov0" title="0">{
                        if created </span><span class="cov0" title="0">{
                                _ = publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do()
                        }</span>
                        <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                                fmt.Sprintf("failed to update track %s: %v", track.Track, err)))</span>
                }
                <span class="cov0" title="0">updatedTracks = append(updatedTracks, track.Track)</span>
        }

        <span class="cov0" title="0">if removedCount == 0 </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        _ = publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do()
                }</span>
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeNotFound,
                        fmt.Sprintf("version code %d not found on any track", versionCode)))</span>
        }

        <span class="cov0" title="0">if err := c.finalizeEdit(ctx, publisher, editMgr, edit, !noAutoCommit); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":      true,
                "versionCode":  versionCode,
                "tracks":       updatedTracks,
                "removedCount": removedCount,
                "package":      c.packageName,
                "editId":       edit.ServerID,
                "committed":    !noAutoCommit,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) publishBuildsExpireAll(ctx context.Context, editID string, noAutoCommit, dryRun, confirm bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">if !confirm </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError,
                        "--confirm flag required for destructive operations"))
        }</span>
        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                result := output.NewResult(map[string]interface{}{
                        "dryRun":  true,
                        "action":  "builds_expire_all",
                        "package": c.packageName,
                })
                return c.Output(result.WithServices("androidpublisher"))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr, edit, created, err := c.prepareEdit(ctx, publisher, editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = editMgr.ReleaseLock(c.packageName) }</span>()

        <span class="cov0" title="0">tracksResp, err := publisher.Edits.Tracks.List(c.packageName, edit.ServerID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        _ = publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do()
                }</span>
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))</span>
        }

        <span class="cov0" title="0">updatedTracks := make([]string, 0)
        for _, track := range tracksResp.Tracks </span><span class="cov0" title="0">{
                if len(track.Releases) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">track.Releases = nil
                if _, err := publisher.Edits.Tracks.Update(c.packageName, edit.ServerID, track.Track, track).Context(ctx).Do(); err != nil </span><span class="cov0" title="0">{
                        if created </span><span class="cov0" title="0">{
                                _ = publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do()
                        }</span>
                        <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                                fmt.Sprintf("failed to update track %s: %v", track.Track, err)))</span>
                }
                <span class="cov0" title="0">updatedTracks = append(updatedTracks, track.Track)</span>
        }

        <span class="cov0" title="0">if err := c.finalizeEdit(ctx, publisher, editMgr, edit, !noAutoCommit); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":   true,
                "tracks":    updatedTracks,
                "package":   c.packageName,
                "editId":    edit.ServerID,
                "committed": !noAutoCommit,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func normalizeBuildType(value string) (buildType, *errors.APIError) <span class="cov0" title="0">{
        normalized := strings.ToLower(strings.TrimSpace(value))
        switch normalized </span>{
        case "", "all":<span class="cov0" title="0">
                return buildTypeAll, nil</span>
        case "apk", "apks":<span class="cov0" title="0">
                return buildTypeAPK, nil</span>
        case "bundle", "bundles", "aab", "aabs":<span class="cov0" title="0">
                return buildTypeBundle, nil</span>
        default:<span class="cov0" title="0">
                return "", errors.NewAPIError(errors.CodeValidationError,
                        fmt.Sprintf("invalid build type: %s", value)).
                        WithHint("Use --type apk, bundle, or all")</span>
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package cli

import (
        "github.com/spf13/cobra"

        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

func (c *CLI) addPublishCommands() <span class="cov10" title="18">{
        publishCmd := &amp;cobra.Command{
                Use:   "publish",
                Short: "Publishing commands",
                Long:  "Manage app publishing, releases, and store listings.",
        }

        c.addPublishUploadCommands(publishCmd)
        c.addPublishBuildsCommands(publishCmd)
        c.addPublishReleaseCommands(publishCmd)
        c.addPublishStatusCommands(publishCmd)
        c.addPublishListingCommands(publishCmd)
        c.addPublishDetailsCommands(publishCmd)
        c.addPublishAssetsCommands(publishCmd)
        c.addPublishImagesCommands(publishCmd)
        c.addPublishDeobfuscationCommands(publishCmd)
        c.addPublishInternalShareCommands(publishCmd)
        c.addPublishTestersCommands(publishCmd)
        c.addEditCommands(publishCmd)

        c.rootCmd.AddCommand(publishCmd)
}</span>

func (c *CLI) addPublishUploadCommands(publishCmd *cobra.Command) <span class="cov10" title="18">{
        var (
                editID       string
                dryRun       bool
                noAutoCommit bool
                obbMain      string
                obbPatch     string
                obbMainRef   int64
                obbPatchRef  int64
        )

        uploadCmd := &amp;cobra.Command{
                Use:   "upload [file]",
                Short: "Upload an artifact (AAB or APK)",
                Long:  "Upload an Android App Bundle (AAB) or APK to an edit transaction.",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishUpload(cmd.Context(), args[0], obbOptions{
                                mainPath:              obbMain,
                                patchPath:             obbPatch,
                                mainReferenceVersion:  obbMainRef,
                                patchReferenceVersion: obbPatchRef,
                        }, editID, noAutoCommit, dryRun)
                }</span>,
        }
        <span class="cov10" title="18">uploadCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")
        uploadCmd.Flags().StringVar(&amp;obbMain, "obb-main", "", "Main expansion file path")
        uploadCmd.Flags().StringVar(&amp;obbPatch, "obb-patch", "", "Patch expansion file path")
        uploadCmd.Flags().Int64Var(&amp;obbMainRef, "obb-main-references-version", 0, "Reference version code for main expansion file")
        uploadCmd.Flags().Int64Var(&amp;obbPatchRef, "obb-patch-references-version", 0, "Reference version code for patch expansion file")
        uploadCmd.Flags().BoolVar(&amp;noAutoCommit, "no-auto-commit", false, "Keep edit open for manual commit")
        uploadCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show intended actions without executing")

        publishCmd.AddCommand(uploadCmd)</span>
}

func (c *CLI) addPublishReleaseCommands(publishCmd *cobra.Command) <span class="cov10" title="18">{
        var (
                editID              string
                track               string
                status              string
                name                string
                versionCodes        []string
                retainVersionCodes  []string
                inAppUpdatePriority int
                percentage          float64
                releaseNotesFile    string
                confirm             bool
                dryRun              bool
                noAutoCommit        bool
                fromTrack           string
                toTrack             string
                rollbackVersionCode string
                wait                bool
                waitTimeout         string
        )

        releaseCmd := &amp;cobra.Command{
                Use:   "release",
                Short: "Create or update a release",
                Long:  "Create a new release on a track with specified version codes.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if track == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--track is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.publishRelease(cmd.Context(), track, name, status, versionCodes, retainVersionCodes, inAppUpdatePriority, releaseNotesFile, editID, noAutoCommit, dryRun, wait, waitTimeout)</span>
                },
        }
        <span class="cov10" title="18">releaseCmd.Flags().StringVar(&amp;track, "track", "", "Release track (internal, alpha, beta, production)")
        releaseCmd.Flags().StringVar(&amp;name, "name", "", "Release name")
        releaseCmd.Flags().StringVar(&amp;status, "status", "draft", "Release status (draft, completed, halted, inProgress)")
        releaseCmd.Flags().StringSliceVar(&amp;versionCodes, "version-code", nil, "Version codes to include (repeatable)")
        releaseCmd.Flags().StringSliceVar(&amp;retainVersionCodes, "retain-version-codes", nil, "Version codes to retain (repeatable)")
        releaseCmd.Flags().IntVar(&amp;inAppUpdatePriority, "in-app-update-priority", -1, "In-app update priority (0-5)")
        releaseCmd.Flags().StringVar(&amp;releaseNotesFile, "release-notes-file", "", "JSON file with localized release notes")
        releaseCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")
        releaseCmd.Flags().BoolVar(&amp;noAutoCommit, "no-auto-commit", false, "Keep edit open for manual commit")
        releaseCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show intended actions without executing")
        releaseCmd.Flags().BoolVar(&amp;wait, "wait", false, "Wait for release to complete")
        releaseCmd.Flags().StringVar(&amp;waitTimeout, "wait-timeout", "30m", "Maximum time to wait (e.g., 30m, 1h)")

        rolloutCmd := &amp;cobra.Command{
                Use:   "rollout",
                Short: "Update rollout percentage",
                Long:  "Update the staged rollout percentage for a production release.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if percentage &lt;= 0 </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--percentage is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.publishRollout(cmd.Context(), track, percentage, editID, noAutoCommit, dryRun)</span>
                },
        }
        <span class="cov10" title="18">rolloutCmd.Flags().StringVar(&amp;track, "track", "production", "Release track")
        rolloutCmd.Flags().Float64Var(&amp;percentage, "percentage", 0, "Rollout percentage (0.01-100.00)")
        rolloutCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")
        rolloutCmd.Flags().BoolVar(&amp;noAutoCommit, "no-auto-commit", false, "Keep edit open for manual commit")
        rolloutCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show intended actions without executing")

        promoteCmd := &amp;cobra.Command{
                Use:   "promote",
                Short: "Promote a release between tracks",
                Long:  "Copy a release from one track to another.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if fromTrack == "" || toTrack == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--from-track and --to-track are required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.publishPromote(cmd.Context(), fromTrack, toTrack, percentage, editID, noAutoCommit, dryRun)</span>
                },
        }
        <span class="cov10" title="18">promoteCmd.Flags().StringVar(&amp;fromTrack, "from-track", "", "Source track")
        promoteCmd.Flags().StringVar(&amp;toTrack, "to-track", "", "Destination track")
        promoteCmd.Flags().Float64Var(&amp;percentage, "percentage", 0, "Rollout percentage for destination")
        promoteCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")
        promoteCmd.Flags().BoolVar(&amp;noAutoCommit, "no-auto-commit", false, "Keep edit open for manual commit")
        promoteCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show intended actions without executing")

        haltCmd := &amp;cobra.Command{
                Use:   "halt",
                Short: "Halt a production rollout",
                Long:  "Halt an in-progress production rollout.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if !confirm </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--confirm flag required for destructive operations")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.publishHalt(cmd.Context(), track, editID, noAutoCommit, dryRun)</span>
                },
        }
        <span class="cov10" title="18">haltCmd.Flags().StringVar(&amp;track, "track", "production", "Release track")
        haltCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")
        haltCmd.Flags().BoolVar(&amp;noAutoCommit, "no-auto-commit", false, "Keep edit open for manual commit")
        haltCmd.Flags().BoolVar(&amp;confirm, "confirm", false, "Confirm destructive operation")
        haltCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show intended actions without executing")

        rollbackCmd := &amp;cobra.Command{
                Use:   "rollback",
                Short: "Rollback to a previous version",
                Long:  "Rollback to a previous version from track history.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if !confirm </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--confirm flag required for destructive operations")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">if track == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--track is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.publishRollback(cmd.Context(), track, rollbackVersionCode, editID, noAutoCommit, dryRun)</span>
                },
        }
        <span class="cov10" title="18">rollbackCmd.Flags().StringVar(&amp;track, "track", "", "Release track")
        rollbackCmd.Flags().StringVar(&amp;rollbackVersionCode, "version-code", "", "Specific version code to rollback to")
        rollbackCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")
        rollbackCmd.Flags().BoolVar(&amp;noAutoCommit, "no-auto-commit", false, "Keep edit open for manual commit")
        rollbackCmd.Flags().BoolVar(&amp;confirm, "confirm", false, "Confirm destructive operation")
        rollbackCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show intended actions without executing")

        publishCmd.AddCommand(releaseCmd, rolloutCmd, promoteCmd, haltCmd, rollbackCmd)</span>
}

func (c *CLI) addPublishStatusCommands(publishCmd *cobra.Command) <span class="cov10" title="18">{
        var track string

        statusCmd := &amp;cobra.Command{
                Use:   "status",
                Short: "Get track status",
                Long:  "Get the current status of a release track.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishStatus(cmd.Context(), track)
                }</span>,
        }
        <span class="cov10" title="18">statusCmd.Flags().StringVar(&amp;track, "track", "", "Release track (leave empty for all tracks)")

        tracksCmd := &amp;cobra.Command{
                Use:   "tracks",
                Short: "List all tracks",
                Long:  "List all available release tracks and their status.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishTracks(cmd.Context())
                }</span>,
        }

        <span class="cov10" title="18">capabilitiesCmd := &amp;cobra.Command{
                Use:   "capabilities",
                Short: "List publishing capabilities",
                Long:  "List available publishing operations and constraints.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishCapabilities(cmd.Context())
                }</span>,
        }

        <span class="cov10" title="18">publishCmd.AddCommand(statusCmd, tracksCmd, capabilitiesCmd)</span>
}

func (c *CLI) addPublishListingCommands(publishCmd *cobra.Command) <span class="cov10" title="18">{
        listingCmd := &amp;cobra.Command{
                Use:   "listing",
                Short: "Manage store listing",
                Long:  "Update app title, short description, and full description.",
        }

        var (
                locale       string
                title        string
                shortDesc    string
                fullDesc     string
                editID       string
                noAutoCommit bool
                dryRun       bool
                confirm      bool
        )

        listingUpdateCmd := &amp;cobra.Command{
                Use:   "update",
                Short: "Update store listing",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishListingUpdate(cmd.Context(), locale, title, shortDesc, fullDesc, editID, noAutoCommit, dryRun)
                }</span>,
        }
        <span class="cov10" title="18">listingUpdateCmd.Flags().StringVar(&amp;locale, "locale", "en-US", "Locale code")
        listingUpdateCmd.Flags().StringVar(&amp;title, "title", "", "App title")
        listingUpdateCmd.Flags().StringVar(&amp;shortDesc, "short-description", "", "Short description")
        listingUpdateCmd.Flags().StringVar(&amp;fullDesc, "full-description", "", "Full description")
        listingUpdateCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")
        listingUpdateCmd.Flags().BoolVar(&amp;noAutoCommit, "no-auto-commit", false, "Keep edit open for manual commit")
        listingUpdateCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show intended actions without executing")

        listingGetCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "Get store listing",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishListingGet(cmd.Context(), locale)
                }</span>,
        }
        <span class="cov10" title="18">listingGetCmd.Flags().StringVar(&amp;locale, "locale", "", "Locale code (leave empty for all)")
        listingGetCmd.Flags().StringVar(&amp;locale, "language", "", "Alias for --locale")
        _ = listingGetCmd.Flags().MarkDeprecated("language", "use --locale instead")

        listingDeleteCmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "Delete store listing",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishListingDelete(cmd.Context(), locale, editID, noAutoCommit, dryRun, confirm)
                }</span>,
        }
        <span class="cov10" title="18">listingDeleteCmd.Flags().StringVar(&amp;locale, "locale", "", "Locale code (required)")
        listingDeleteCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")
        listingDeleteCmd.Flags().BoolVar(&amp;noAutoCommit, "no-auto-commit", false, "Keep edit open for manual commit")
        listingDeleteCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show intended actions without executing")
        listingDeleteCmd.Flags().BoolVar(&amp;confirm, "confirm", false, "Confirm destructive operation")

        listingDeleteAllCmd := &amp;cobra.Command{
                Use:   "delete-all",
                Short: "Delete all store listings",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishListingDeleteAll(cmd.Context(), editID, noAutoCommit, dryRun, confirm)
                }</span>,
        }
        <span class="cov10" title="18">listingDeleteAllCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")
        listingDeleteAllCmd.Flags().BoolVar(&amp;noAutoCommit, "no-auto-commit", false, "Keep edit open for manual commit")
        listingDeleteAllCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show intended actions without executing")
        listingDeleteAllCmd.Flags().BoolVar(&amp;confirm, "confirm", false, "Confirm destructive operation")

        listingCmd.AddCommand(listingUpdateCmd, listingGetCmd, listingDeleteCmd, listingDeleteAllCmd)
        publishCmd.AddCommand(listingCmd)</span>
}

func (c *CLI) addPublishDetailsCommands(publishCmd *cobra.Command) <span class="cov10" title="18">{
        detailsCmd := &amp;cobra.Command{
                Use:   "details",
                Short: "Manage app details",
                Long:  "Get and update app contact information and settings.",
        }

        var (
                contactEmail    string
                contactPhone    string
                contactWebsite  string
                defaultLanguage string
                updateMask      string
                editID          string
                noAutoCommit    bool
                dryRun          bool
        )

        detailsGetCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "Get app details",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishDetailsGet(cmd.Context())
                }</span>,
        }

        <span class="cov10" title="18">detailsUpdateCmd := &amp;cobra.Command{
                Use:   "update",
                Short: "Update app details",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishDetailsUpdate(cmd.Context(), contactEmail, contactPhone, contactWebsite, defaultLanguage, editID, noAutoCommit, dryRun)
                }</span>,
        }
        <span class="cov10" title="18">detailsUpdateCmd.Flags().StringVar(&amp;contactEmail, "contact-email", "", "Contact email")
        detailsUpdateCmd.Flags().StringVar(&amp;contactPhone, "contact-phone", "", "Contact phone")
        detailsUpdateCmd.Flags().StringVar(&amp;contactWebsite, "contact-website", "", "Contact website")
        detailsUpdateCmd.Flags().StringVar(&amp;defaultLanguage, "default-language", "", "Default language")
        detailsUpdateCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")
        detailsUpdateCmd.Flags().BoolVar(&amp;noAutoCommit, "no-auto-commit", false, "Keep edit open for manual commit")
        detailsUpdateCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show intended actions without executing")

        detailsPatchCmd := &amp;cobra.Command{
                Use:   "patch",
                Short: "Patch app details",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishDetailsPatch(cmd.Context(), contactEmail, contactPhone, contactWebsite, defaultLanguage, updateMask, editID, noAutoCommit, dryRun)
                }</span>,
        }
        <span class="cov10" title="18">detailsPatchCmd.Flags().StringVar(&amp;contactEmail, "contact-email", "", "Contact email")
        detailsPatchCmd.Flags().StringVar(&amp;contactPhone, "contact-phone", "", "Contact phone")
        detailsPatchCmd.Flags().StringVar(&amp;contactWebsite, "contact-website", "", "Contact website")
        detailsPatchCmd.Flags().StringVar(&amp;defaultLanguage, "default-language", "", "Default language")
        detailsPatchCmd.Flags().StringVar(&amp;updateMask, "update-mask", "", "Fields to update (comma-separated)")
        detailsPatchCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")
        detailsPatchCmd.Flags().BoolVar(&amp;noAutoCommit, "no-auto-commit", false, "Keep edit open for manual commit")
        detailsPatchCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show intended actions without executing")

        detailsCmd.AddCommand(detailsGetCmd, detailsUpdateCmd, detailsPatchCmd)
        publishCmd.AddCommand(detailsCmd)</span>
}

func (c *CLI) addPublishAssetsCommands(publishCmd *cobra.Command) <span class="cov10" title="18">{
        assetsCmd := &amp;cobra.Command{
                Use:   "assets",
                Short: "Manage store assets",
                Long:  "Upload and manage screenshots and graphics.",
        }

        var (
                assetsDir    string
                category     string
                replace      bool
                editID       string
                noAutoCommit bool
                dryRun       bool
        )

        assetsUploadCmd := &amp;cobra.Command{
                Use:   "upload [directory]",
                Short: "Upload assets from directory",
                Long:  "Upload assets following the directory convention: assets/{locale}/{category}/",
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        dir := assetsDir
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                dir = args[0]
                        }</span>
                        <span class="cov0" title="0">return c.publishAssetsUpload(cmd.Context(), dir, category, replace, editID, noAutoCommit, dryRun)</span>
                },
        }
        <span class="cov10" title="18">assetsUploadCmd.Flags().StringVar(&amp;assetsDir, "dir", "assets", "Assets directory")
        assetsUploadCmd.Flags().StringVar(&amp;category, "category", "", "Category to replace (phone, tablet, tv, wear)")
        assetsUploadCmd.Flags().StringVar(&amp;category, "replace", "", "Alias for --category")
        _ = assetsUploadCmd.Flags().MarkDeprecated("replace", "use --category instead")
        assetsUploadCmd.Flags().BoolVar(&amp;replace, "replace-all", false, "Replace all existing assets")
        assetsUploadCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")
        assetsUploadCmd.Flags().BoolVar(&amp;noAutoCommit, "no-auto-commit", false, "Keep edit open for manual commit")
        assetsUploadCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show intended actions without executing")

        assetsSpecCmd := &amp;cobra.Command{
                Use:   "spec",
                Short: "Output asset validation matrix",
                Long:  "Output machine-readable asset dimension requirements.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishAssetsSpec(cmd.Context())
                }</span>,
        }

        <span class="cov10" title="18">assetsCmd.AddCommand(assetsUploadCmd, assetsSpecCmd)
        publishCmd.AddCommand(assetsCmd)</span>
}

func (c *CLI) addPublishImagesCommands(publishCmd *cobra.Command) <span class="cov10" title="18">{
        imagesCmd := &amp;cobra.Command{
                Use:   "images",
                Short: "Manage store images",
                Long:  "Upload, list, and delete store images using edits.images.",
        }

        var (
                imageLocale  string
                editID       string
                noAutoCommit bool
                dryRun       bool
                syncImages   bool
        )

        imagesUploadCmd := &amp;cobra.Command{
                Use:   "upload &lt;type&gt; &lt;file&gt;",
                Short: "Upload an image",
                Args:  cobra.ExactArgs(2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishImagesUpload(cmd.Context(), args[0], args[1], imageLocale, syncImages, editID, noAutoCommit, dryRun)
                }</span>,
        }
        <span class="cov10" title="18">imagesUploadCmd.Flags().StringVar(&amp;imageLocale, "locale", "en-US", "Locale code")
        imagesUploadCmd.Flags().BoolVar(&amp;syncImages, "sync-images", false, "Skip upload if identical image already exists")
        imagesUploadCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")
        imagesUploadCmd.Flags().BoolVar(&amp;noAutoCommit, "no-auto-commit", false, "Keep edit open for manual commit")
        imagesUploadCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show intended actions without executing")

        imagesListCmd := &amp;cobra.Command{
                Use:   "list &lt;type&gt;",
                Short: "List images",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishImagesList(cmd.Context(), args[0], imageLocale, editID)
                }</span>,
        }
        <span class="cov10" title="18">imagesListCmd.Flags().StringVar(&amp;imageLocale, "locale", "en-US", "Locale code")
        imagesListCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")

        imagesDeleteCmd := &amp;cobra.Command{
                Use:   "delete &lt;type&gt; &lt;id&gt;",
                Short: "Delete an image",
                Args:  cobra.ExactArgs(2),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishImagesDelete(cmd.Context(), args[0], args[1], imageLocale, editID, noAutoCommit, dryRun)
                }</span>,
        }
        <span class="cov10" title="18">imagesDeleteCmd.Flags().StringVar(&amp;imageLocale, "locale", "en-US", "Locale code")
        imagesDeleteCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")
        imagesDeleteCmd.Flags().BoolVar(&amp;noAutoCommit, "no-auto-commit", false, "Keep edit open for manual commit")
        imagesDeleteCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show intended actions without executing")

        imagesDeleteAllCmd := &amp;cobra.Command{
                Use:   "deleteall &lt;type&gt;",
                Short: "Delete all images for type",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishImagesDeleteAll(cmd.Context(), args[0], imageLocale, editID, noAutoCommit, dryRun)
                }</span>,
        }
        <span class="cov10" title="18">imagesDeleteAllCmd.Flags().StringVar(&amp;imageLocale, "locale", "en-US", "Locale code")
        imagesDeleteAllCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")
        imagesDeleteAllCmd.Flags().BoolVar(&amp;noAutoCommit, "no-auto-commit", false, "Keep edit open for manual commit")
        imagesDeleteAllCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show intended actions without executing")

        imagesCmd.AddCommand(imagesUploadCmd, imagesListCmd, imagesDeleteCmd, imagesDeleteAllCmd)
        publishCmd.AddCommand(imagesCmd)</span>
}

func (c *CLI) addPublishDeobfuscationCommands(publishCmd *cobra.Command) <span class="cov10" title="18">{
        deobfuscationCmd := &amp;cobra.Command{
                Use:   "deobfuscation",
                Short: "Manage deobfuscation files",
                Long:  "Upload ProGuard/R8 mappings and native debug symbols.",
        }

        var (
                deobfuscationType        string
                deobfuscationVersionCode int64
                deobfuscationChunkSize   int64
                editID                   string
                noAutoCommit             bool
                dryRun                   bool
        )

        deobfuscationUploadCmd := &amp;cobra.Command{
                Use:   "upload &lt;file&gt;",
                Short: "Upload deobfuscation file",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if deobfuscationType == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--type is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">if deobfuscationVersionCode &lt;= 0 </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--version-code is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.publishDeobfuscationUpload(cmd.Context(), args[0], deobfuscationType, deobfuscationVersionCode, editID, deobfuscationChunkSize, noAutoCommit, dryRun)</span>
                },
        }
        <span class="cov10" title="18">deobfuscationUploadCmd.Flags().StringVar(&amp;deobfuscationType, "type", "", "Deobfuscation file type: proguard or nativeCode")
        deobfuscationUploadCmd.Flags().Int64Var(&amp;deobfuscationVersionCode, "version-code", 0, "Version code to associate")
        deobfuscationUploadCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")
        deobfuscationUploadCmd.Flags().Int64Var(&amp;deobfuscationChunkSize, "chunk-size", 10*1024*1024, "Upload chunk size in bytes")
        deobfuscationUploadCmd.Flags().BoolVar(&amp;noAutoCommit, "no-auto-commit", false, "Keep edit open for manual commit")
        deobfuscationUploadCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show intended actions without executing")

        deobfuscationCmd.AddCommand(deobfuscationUploadCmd)
        publishCmd.AddCommand(deobfuscationCmd)</span>
}

func (c *CLI) addPublishInternalShareCommands(publishCmd *cobra.Command) <span class="cov10" title="18">{
        internalShareCmd := &amp;cobra.Command{
                Use:     "internal-share",
                Aliases: []string{"internal", "share"},
                Short:   "Upload artifacts for internal sharing",
                Long:    "Upload APK/AAB for internal testing without edit workflow.",
        }

        var dryRun bool

        internalShareUploadCmd := &amp;cobra.Command{
                Use:   "upload &lt;file&gt;",
                Short: "Upload artifact for internal sharing",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishInternalShareUpload(cmd.Context(), args[0], dryRun)
                }</span>,
        }
        <span class="cov10" title="18">internalShareUploadCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show intended actions without executing")

        internalShareCmd.AddCommand(internalShareUploadCmd)
        publishCmd.AddCommand(internalShareCmd)</span>
}

func (c *CLI) addPublishTestersCommands(publishCmd *cobra.Command) <span class="cov10" title="18">{
        testersCmd := &amp;cobra.Command{
                Use:   "testers",
                Short: "Manage testers",
                Long:  "Manage tester groups for tracks.",
        }

        var (
                testersTrack string
                groups       []string
                editID       string
                noAutoCommit bool
                dryRun       bool
        )

        testersAddCmd := &amp;cobra.Command{
                Use:   "add",
                Short: "Add tester groups",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishTestersAdd(cmd.Context(), testersTrack, groups, editID, noAutoCommit, dryRun)
                }</span>,
        }
        <span class="cov10" title="18">testersAddCmd.Flags().StringVar(&amp;testersTrack, "track", "internal", "Track to add testers to")
        testersAddCmd.Flags().StringSliceVar(&amp;groups, "group", nil, "Google Group email addresses")
        testersAddCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")
        testersAddCmd.Flags().BoolVar(&amp;noAutoCommit, "no-auto-commit", false, "Keep edit open for manual commit")
        testersAddCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show intended actions without executing")

        testersRemoveCmd := &amp;cobra.Command{
                Use:   "remove",
                Short: "Remove tester groups",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishTestersRemove(cmd.Context(), testersTrack, groups, editID, noAutoCommit, dryRun)
                }</span>,
        }
        <span class="cov10" title="18">testersRemoveCmd.Flags().StringVar(&amp;testersTrack, "track", "internal", "Track to remove testers from")
        testersRemoveCmd.Flags().StringSliceVar(&amp;groups, "group", nil, "Google Group email addresses")
        testersRemoveCmd.Flags().StringVar(&amp;editID, "edit-id", "", "Explicit edit transaction ID")
        testersRemoveCmd.Flags().BoolVar(&amp;noAutoCommit, "no-auto-commit", false, "Keep edit open for manual commit")
        testersRemoveCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show intended actions without executing")

        testersListCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List tester groups",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.publishTestersList(cmd.Context(), testersTrack)
                }</span>,
        }
        <span class="cov10" title="18">testersListCmd.Flags().StringVar(&amp;testersTrack, "track", "", "Track to list testers for (empty for all)")

        testersGetCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "Get tester groups for a track",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if testersTrack == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--track is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.publishTestersList(cmd.Context(), testersTrack)</span>
                },
        }
        <span class="cov10" title="18">testersGetCmd.Flags().StringVar(&amp;testersTrack, "track", "", "Track to get testers for")

        testersCmd.AddCommand(testersAddCmd, testersRemoveCmd, testersListCmd, testersGetCmd)
        publishCmd.AddCommand(testersCmd)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package cli

import (
        "context"
        "fmt"
        "net/mail"
        "net/url"
        "time"

        "google.golang.org/api/androidpublisher/v3"

        "github.com/dl-alexandre/gpd/internal/edits"
        "github.com/dl-alexandre/gpd/internal/errors"
)

func (c *CLI) prepareEdit(ctx context.Context, publisher *androidpublisher.Service, editID string) (*edits.Manager, *edits.Edit, bool, error) <span class="cov0" title="0">{
        editMgr := edits.NewManager()
        if err := editMgr.AcquireLock(ctx, c.packageName); err != nil </span><span class="cov0" title="0">{
                return nil, nil, false, err
        }</span>

        <span class="cov0" title="0">var edit *edits.Edit
        created := false
        if editID != "" </span><span class="cov0" title="0">{
                stored, err := editMgr.LoadEdit(c.packageName, editID)
                if err != nil </span><span class="cov0" title="0">{
                        _ = editMgr.ReleaseLock(c.packageName)
                        return nil, nil, false, err
                }</span>
                <span class="cov0" title="0">if stored != nil </span><span class="cov0" title="0">{
                        if editMgr.IsEditExpired(stored, time.Now()) </span><span class="cov0" title="0">{
                                _ = editMgr.ReleaseLock(c.packageName)
                                return nil, nil, false, errors.NewAPIError(errors.CodeConflict, "edit has expired")
                        }</span>
                        <span class="cov0" title="0">edit = stored</span>
                } else<span class="cov0" title="0"> {
                        edit = &amp;edits.Edit{
                                Handle:      editID,
                                ServerID:    editID,
                                PackageName: c.packageName,
                                CreatedAt:   time.Now(),
                                LastUsedAt:  time.Now(),
                                State:       edits.StateDraft,
                        }
                        if err := editMgr.SaveEdit(edit); err != nil </span><span class="cov0" title="0">{
                                _ = editMgr.ReleaseLock(c.packageName)
                                return nil, nil, false, err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                apiEdit, err := publisher.Edits.Insert(c.packageName, nil).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        _ = editMgr.ReleaseLock(c.packageName)
                        return nil, nil, false, errors.NewAPIError(errors.CodeGeneralError,
                                fmt.Sprintf("failed to create edit: %v", err))
                }</span>
                <span class="cov0" title="0">edit = &amp;edits.Edit{
                        Handle:      apiEdit.Id,
                        ServerID:    apiEdit.Id,
                        PackageName: c.packageName,
                        CreatedAt:   time.Now(),
                        LastUsedAt:  time.Now(),
                        State:       edits.StateDraft,
                }
                created = true
                if err := editMgr.SaveEdit(edit); err != nil </span><span class="cov0" title="0">{
                        _ = editMgr.ReleaseLock(c.packageName)
                        return nil, nil, false, err
                }</span>
        }
        <span class="cov0" title="0">return editMgr, edit, created, nil</span>
}

func (c *CLI) finalizeEdit(ctx context.Context, publisher *androidpublisher.Service, editMgr *edits.Manager, edit *edits.Edit, commit bool) error <span class="cov0" title="0">{
        if edit == nil </span><span class="cov0" title="0">{
                return errors.NewAPIError(errors.CodeValidationError, "edit is required")
        }</span>
        <span class="cov0" title="0">if !commit </span><span class="cov0" title="0">{
                edit.LastUsedAt = time.Now()
                if err := editMgr.SaveEdit(edit); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">contentID := fmt.Sprintf("%s:%d", edit.ServerID, edit.CreatedAt.Unix())
        idempotencyResult, idempotencyKey, _ := editMgr.Idempotent.CheckCommit(c.packageName, edit.ServerID, contentID)
        if idempotencyResult != nil &amp;&amp; idempotencyResult.Found </span><span class="cov0" title="0">{
                _, _ = editMgr.UpdateEditState(c.packageName, edit.Handle, edits.StateCommitted)
                _ = editMgr.DeleteEdit(c.packageName, edit.Handle)
                return nil
        }</span>

        <span class="cov0" title="0">_, err := publisher.Edits.Commit(c.packageName, edit.ServerID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to commit edit: %v", err))
        }</span>

        <span class="cov0" title="0">_ = editMgr.Idempotent.RecordCommit(idempotencyKey, c.packageName, edit.ServerID)

        _, _ = editMgr.UpdateEditState(c.packageName, edit.Handle, edits.StateCommitted)
        _ = editMgr.DeleteEdit(c.packageName, edit.Handle)
        return nil</span>
}

func isValidEmail(value string) bool <span class="cov0" title="0">{
        _, err := mail.ParseAddress(value)
        return err == nil
}</span>

func isValidURL(value string) bool <span class="cov0" title="0">{
        parsed, err := url.ParseRequestURI(value)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return parsed.Scheme != "" &amp;&amp; parsed.Host != ""</span>
}

func containsString(items []string, value string) bool <span class="cov0" title="0">{
        for _, item := range items </span><span class="cov0" title="0">{
                if item == value </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package cli

import (
        "bufio"
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "google.golang.org/api/androidpublisher/v3"
        "google.golang.org/api/googleapi"

        "github.com/dl-alexandre/gpd/internal/edits"
        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/logging"
        "github.com/dl-alexandre/gpd/internal/output"
)

func (c *CLI) publishDeobfuscationUpload(ctx context.Context, filePath, fileType string, versionCode int64, editID string, chunkSize int64, noAutoCommit, dryRun bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("androidpublisher")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">info, apiErr := validateDeobfuscationFile(filePath, fileType)
        if apiErr != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(apiErr).WithServices("androidpublisher")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                result := output.NewResult(map[string]interface{}{
                        "dryRun":      true,
                        "action":      "deobfuscation_upload",
                        "path":        filePath,
                        "size":        info.Size(),
                        "sizeHuman":   edits.FormatBytes(info.Size()),
                        "type":        fileType,
                        "versionCode": versionCode,
                        "package":     c.packageName,
                })
                return c.Output(result.WithServices("androidpublisher"))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if apiErr, ok := err.(*errors.APIError); ok </span><span class="cov0" title="0">{
                        return c.OutputError(apiErr)
                }</span>
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))</span>
        }

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr, edit, created, err := c.prepareEdit(ctx, publisher, editID)
        if err != nil </span><span class="cov0" title="0">{
                if apiErr, ok := err.(*errors.APIError); ok </span><span class="cov0" title="0">{
                        return c.OutputError(apiErr)
                }</span>
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := editMgr.ReleaseLock(c.packageName); err != nil </span><span class="cov0" title="0">{
                        logging.Warn("failed to release edit lock", logging.String("package", c.packageName), logging.Err(err))
                }</span>
        }()

        <span class="cov0" title="0">if err := c.ensureVersionCodeExists(ctx, publisher, edit.ServerID, versionCode); err != nil </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        if cleanupErr := publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do(); cleanupErr != nil </span><span class="cov0" title="0">{
                                logging.Warn("failed to delete edit", logging.String("package", c.packageName), logging.String("editId", edit.ServerID), logging.Err(cleanupErr))
                        }</span>
                }
                <span class="cov0" title="0">return c.OutputError(err)</span>
        }

        <span class="cov0" title="0">f, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">call := publisher.Edits.Deobfuscationfiles.Upload(c.packageName, edit.ServerID, versionCode, fileType)
        if chunkSize &gt; 0 </span><span class="cov0" title="0">{
                call.Media(f, googleapi.ChunkSize(int(chunkSize)))
        }</span> else<span class="cov0" title="0"> {
                call.Media(f)
        }</span>

        <span class="cov0" title="0">resp, err := call.Context(ctx).Do()
        closeErr := f.Close()
        if err != nil </span><span class="cov0" title="0">{
                if closeErr != nil </span><span class="cov0" title="0">{
                        logging.Warn("failed to close deobfuscation file", logging.String("path", filePath), logging.Err(closeErr))
                }</span>
                <span class="cov0" title="0">if created </span><span class="cov0" title="0">{
                        if cleanupErr := publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do(); cleanupErr != nil </span><span class="cov0" title="0">{
                                logging.Warn("failed to delete edit", logging.String("package", c.packageName), logging.String("editId", edit.ServerID), logging.Err(cleanupErr))
                        }</span>
                }
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to upload deobfuscation file: %v", err)))</span>
        }
        <span class="cov0" title="0">if closeErr != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, closeErr.Error()))
        }</span>

        <span class="cov0" title="0">if err := c.finalizeEdit(ctx, publisher, editMgr, edit, !noAutoCommit); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":     true,
                "type":        fileType,
                "versionCode": versionCode,
                "package":     c.packageName,
                "size":        info.Size(),
                "sizeHuman":   edits.FormatBytes(info.Size()),
                "editId":      edit.ServerID,
                "committed":   !noAutoCommit,
                "response":    resp,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func validateDeobfuscationFile(filePath, fileType string) (os.FileInfo, *errors.APIError) <span class="cov0" title="0">{
        info, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewAPIError(errors.CodeValidationError,
                        fmt.Sprintf("file not found: %s", filePath))
        }</span>

        <span class="cov0" title="0">switch fileType </span>{
        case "proguard":<span class="cov0" title="0">
                if info.Size() &gt; 50*1024*1024 </span><span class="cov0" title="0">{
                        return nil, errors.NewAPIError(errors.CodeValidationError, "proguard mapping file exceeds 50MB")
                }</span>
                <span class="cov0" title="0">if !looksLikeProguardMapping(filePath) </span><span class="cov0" title="0">{
                        return nil, errors.NewAPIError(errors.CodeValidationError, "proguard mapping file format invalid")
                }</span>
        case "nativeCode":<span class="cov0" title="0">
                if info.Size() &gt; 100*1024*1024 </span><span class="cov0" title="0">{
                        return nil, errors.NewAPIError(errors.CodeValidationError, "native symbols file exceeds 100MB")
                }</span>
                <span class="cov0" title="0">lower := strings.ToLower(filePath)
                ext := strings.ToLower(filepath.Ext(filePath))
                if ext != ".zip" &amp;&amp; ext != ".sym" &amp;&amp; !strings.HasSuffix(lower, ".so.sym") </span><span class="cov0" title="0">{
                        return nil, errors.NewAPIError(errors.CodeValidationError, "native symbols file must be .so.sym or .zip")
                }</span>
        default:<span class="cov0" title="0">
                return nil, errors.NewAPIError(errors.CodeValidationError, "type must be proguard or nativeCode")</span>
        }

        <span class="cov0" title="0">return info, nil</span>
}

func looksLikeProguardMapping(filePath string) bool <span class="cov0" title="0">{
        f, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">scanner := bufio.NewScanner(f)
        lines := 0
        found := false
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if strings.Contains(line, "-&gt;") &amp;&amp; strings.HasSuffix(line, ":") </span><span class="cov0" title="0">{
                        found = true
                        break</span>
                }
                <span class="cov0" title="0">lines++
                if lines &gt; 50 </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return found</span>
}

func (c *CLI) ensureVersionCodeExists(ctx context.Context, publisher *androidpublisher.Service, editID string, versionCode int64) *errors.APIError <span class="cov0" title="0">{
        if versionCode &lt;= 0 </span><span class="cov0" title="0">{
                return errors.NewAPIError(errors.CodeValidationError, "version code must be greater than zero")
        }</span>

        <span class="cov0" title="0">bundles, err := publisher.Edits.Bundles.List(c.packageName, editID).Context(ctx).Do()
        if err == nil </span><span class="cov0" title="0">{
                for _, bundle := range bundles.Bundles </span><span class="cov0" title="0">{
                        if bundle.VersionCode == versionCode </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
        }

        <span class="cov0" title="0">apks, err := publisher.Edits.Apks.List(c.packageName, editID).Context(ctx).Do()
        if err == nil </span><span class="cov0" title="0">{
                for _, apk := range apks.Apks </span><span class="cov0" title="0">{
                        if apk.VersionCode == versionCode </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return errors.NewAPIError(errors.CodeValidationError,
                fmt.Sprintf("version code %d not found in edit", versionCode)).
                WithHint("Upload an APK/AAB in this edit before uploading deobfuscation files")</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package cli

import (
        "context"
        "fmt"
        "image"
        _ "image/jpeg" // Register JPEG decoder for image.DecodeConfig
        _ "image/png"  // Register PNG decoder for image.DecodeConfig
        "os"
        "strings"

        "google.golang.org/api/androidpublisher/v3"

        "github.com/dl-alexandre/gpd/internal/edits"
        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/logging"
        "github.com/dl-alexandre/gpd/internal/output"
)

type imageSpec struct {
        minWidth  int
        maxWidth  int
        minHeight int
        maxHeight int
        maxSize   int64
        formats   []string
}

func imageSpecs() map[string]imageSpec <span class="cov0" title="0">{
        return map[string]imageSpec{
                "icon":                 {minWidth: 512, maxWidth: 512, minHeight: 512, maxHeight: 512, maxSize: 1 * 1024 * 1024, formats: []string{"png"}},
                "featureGraphic":       {minWidth: 1024, maxWidth: 1024, minHeight: 500, maxHeight: 500, maxSize: 15 * 1024 * 1024, formats: []string{"png", "jpeg"}},
                "promoGraphic":         {maxSize: 15 * 1024 * 1024, formats: []string{"png", "jpeg"}},
                "tvBanner":             {minWidth: 1280, maxWidth: 1280, minHeight: 720, maxHeight: 720, maxSize: 15 * 1024 * 1024, formats: []string{"png", "jpeg"}},
                "phoneScreenshots":     {minWidth: 320, maxWidth: 3840, minHeight: 320, maxHeight: 3840, maxSize: 8 * 1024 * 1024, formats: []string{"png", "jpeg"}},
                "tabletScreenshots":    {minWidth: 320, maxWidth: 3840, minHeight: 320, maxHeight: 3840, maxSize: 8 * 1024 * 1024, formats: []string{"png", "jpeg"}},
                "sevenInchScreenshots": {minWidth: 320, maxWidth: 3840, minHeight: 320, maxHeight: 3840, maxSize: 8 * 1024 * 1024, formats: []string{"png", "jpeg"}},
                "tenInchScreenshots":   {minWidth: 320, maxWidth: 3840, minHeight: 320, maxHeight: 3840, maxSize: 8 * 1024 * 1024, formats: []string{"png", "jpeg"}},
                "tvScreenshots":        {minWidth: 320, maxWidth: 3840, minHeight: 320, maxHeight: 3840, maxSize: 8 * 1024 * 1024, formats: []string{"png", "jpeg"}},
                "wearScreenshots":      {minWidth: 320, maxWidth: 3840, minHeight: 320, maxHeight: 3840, maxSize: 8 * 1024 * 1024, formats: []string{"png", "jpeg"}},
        }
}</span>

func imageTypeHint() string <span class="cov0" title="0">{
        types := []string{
                "icon",
                "featureGraphic",
                "promoGraphic",
                "tvBanner",
                "phoneScreenshots",
                "tabletScreenshots",
                "sevenInchScreenshots",
                "tenInchScreenshots",
                "tvScreenshots",
                "wearScreenshots",
        }
        return "Valid image types: " + strings.Join(types, ", ")
}</span>

func validateImageFile(filePath, imageType string) (info os.FileInfo, cfg image.Config, format string, apiErr *errors.APIError) <span class="cov0" title="0">{
        info, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, image.Config{}, "", errors.NewAPIError(errors.CodeValidationError,
                        fmt.Sprintf("file not found: %s", filePath))
        }</span>
        <span class="cov0" title="0">f, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, image.Config{}, "", errors.NewAPIError(errors.CodeGeneralError, err.Error())
        }</span>
        <span class="cov0" title="0">cfg, format, decodeErr := image.DecodeConfig(f)
        closeErr := f.Close()
        if decodeErr != nil </span><span class="cov0" title="0">{
                if closeErr != nil </span><span class="cov0" title="0">{
                        return nil, image.Config{}, "", errors.NewAPIError(errors.CodeValidationError, fmt.Sprintf("invalid image file: %v", closeErr))
                }</span>
                <span class="cov0" title="0">return nil, image.Config{}, "", errors.NewAPIError(errors.CodeValidationError, "invalid image file")</span>
        }
        <span class="cov0" title="0">if closeErr != nil </span><span class="cov0" title="0">{
                return nil, image.Config{}, "", errors.NewAPIError(errors.CodeGeneralError, closeErr.Error())
        }</span>

        <span class="cov0" title="0">spec, ok := imageSpecs()[imageType]
        if !ok </span><span class="cov0" title="0">{
                return nil, image.Config{}, "", errors.NewAPIError(errors.CodeValidationError, "invalid image type")
        }</span>
        <span class="cov0" title="0">if spec.maxSize &gt; 0 &amp;&amp; info.Size() &gt; spec.maxSize </span><span class="cov0" title="0">{
                return nil, image.Config{}, "", errors.NewAPIError(errors.CodeValidationError, "image exceeds size limit")
        }</span>
        <span class="cov0" title="0">if spec.minWidth &gt; 0 &amp;&amp; cfg.Width &lt; spec.minWidth </span><span class="cov0" title="0">{
                return nil, image.Config{}, "", errors.NewAPIError(errors.CodeValidationError, "image width too small")
        }</span>
        <span class="cov0" title="0">if spec.maxWidth &gt; 0 &amp;&amp; cfg.Width &gt; spec.maxWidth </span><span class="cov0" title="0">{
                return nil, image.Config{}, "", errors.NewAPIError(errors.CodeValidationError, "image width too large")
        }</span>
        <span class="cov0" title="0">if spec.minHeight &gt; 0 &amp;&amp; cfg.Height &lt; spec.minHeight </span><span class="cov0" title="0">{
                return nil, image.Config{}, "", errors.NewAPIError(errors.CodeValidationError, "image height too small")
        }</span>
        <span class="cov0" title="0">if spec.maxHeight &gt; 0 &amp;&amp; cfg.Height &gt; spec.maxHeight </span><span class="cov0" title="0">{
                return nil, image.Config{}, "", errors.NewAPIError(errors.CodeValidationError, "image height too large")
        }</span>
        <span class="cov0" title="0">if len(spec.formats) &gt; 0 &amp;&amp; !containsString(spec.formats, format) </span><span class="cov0" title="0">{
                return nil, image.Config{}, "", errors.NewAPIError(errors.CodeValidationError, "invalid image format")
        }</span>
        <span class="cov0" title="0">return info, cfg, format, nil</span>
}

func (c *CLI) publishImagesUpload(ctx context.Context, imageType, filePath, locale string, syncImages bool, editID string, noAutoCommit, dryRun bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">info, cfg, format, apiErr := validateImageFile(filePath, imageType)
        if apiErr != nil </span><span class="cov0" title="0">{
                return c.OutputError(apiErr)
        }</span>
        <span class="cov0" title="0">var localHash string
        if syncImages </span><span class="cov0" title="0">{
                hash, err := edits.HashFile(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
                }</span>
                <span class="cov0" title="0">localHash = hash</span>
        }
        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                resultData := map[string]interface{}{
                        "dryRun":    true,
                        "action":    "images_upload",
                        "type":      imageType,
                        "locale":    locale,
                        "path":      filePath,
                        "width":     cfg.Width,
                        "height":    cfg.Height,
                        "format":    format,
                        "size":      info.Size(),
                        "sizeHuman": edits.FormatBytes(info.Size()),
                        "package":   c.packageName,
                }
                if localHash != "" </span><span class="cov0" title="0">{
                        resultData["sha256"] = localHash
                }</span>
                <span class="cov0" title="0">result := output.NewResult(resultData)
                return c.Output(result.WithServices("androidpublisher"))</span>
        }

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if apiErr, ok := err.(*errors.APIError); ok </span><span class="cov0" title="0">{
                        return c.OutputError(apiErr)
                }</span>
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))</span>
        }

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr, edit, created, err := c.prepareEdit(ctx, publisher, editID)
        if err != nil </span><span class="cov0" title="0">{
                if apiErr, ok := err.(*errors.APIError); ok </span><span class="cov0" title="0">{
                        return c.OutputError(apiErr)
                }</span>
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := editMgr.ReleaseLock(c.packageName); err != nil </span><span class="cov0" title="0">{
                        logging.Warn("failed to release edit lock", logging.String("package", c.packageName), logging.Err(err))
                }</span>
        }()

        <span class="cov0" title="0">if syncImages &amp;&amp; localHash != "" </span><span class="cov0" title="0">{
                images, err := publisher.Edits.Images.List(c.packageName, edit.ServerID, locale, imageType).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        if created </span><span class="cov0" title="0">{
                                if cleanupErr := publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do(); cleanupErr != nil </span><span class="cov0" title="0">{
                                        logging.Warn("failed to delete edit", logging.String("package", c.packageName), logging.String("editId", edit.ServerID), logging.Err(cleanupErr))
                                }</span>
                        }
                        <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))</span>
                }
                <span class="cov0" title="0">for _, image := range images.Images </span><span class="cov0" title="0">{
                        if image != nil &amp;&amp; strings.EqualFold(image.Sha256, localHash) </span><span class="cov0" title="0">{
                                if err := c.finalizeEdit(ctx, publisher, editMgr, edit, !noAutoCommit); err != nil </span><span class="cov0" title="0">{
                                        return c.OutputError(err.(*errors.APIError))
                                }</span>
                                <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                                        "idempotent": true,
                                        "type":       imageType,
                                        "locale":     locale,
                                        "sha256":     localHash,
                                        "package":    c.packageName,
                                        "editId":     edit.ServerID,
                                        "committed":  !noAutoCommit,
                                })
                                return c.Output(result.WithNoOp("image already uploaded").WithServices("androidpublisher"))</span>
                        }
                }
        }

        <span class="cov0" title="0">f, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">resp, err := publisher.Edits.Images.Upload(c.packageName, edit.ServerID, locale, imageType).
                Media(f).Context(ctx).Do()
        closeErr := f.Close()
        if err != nil </span><span class="cov0" title="0">{
                if closeErr != nil </span><span class="cov0" title="0">{
                        logging.Warn("failed to close image file", logging.String("path", filePath), logging.Err(closeErr))
                }</span>
                <span class="cov0" title="0">if created </span><span class="cov0" title="0">{
                        if cleanupErr := publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do(); cleanupErr != nil </span><span class="cov0" title="0">{
                                logging.Warn("failed to delete edit", logging.String("package", c.packageName), logging.String("editId", edit.ServerID), logging.Err(cleanupErr))
                        }</span>
                }
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))</span>
        }
        <span class="cov0" title="0">if closeErr != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, closeErr.Error()))
        }</span>

        <span class="cov0" title="0">if err := c.finalizeEdit(ctx, publisher, editMgr, edit, !noAutoCommit); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":   true,
                "type":      imageType,
                "locale":    locale,
                "image":     resp,
                "package":   c.packageName,
                "editId":    edit.ServerID,
                "committed": !noAutoCommit,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) publishImagesList(ctx context.Context, imageType, locale, editID string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">var edit *androidpublisher.AppEdit
        var created bool
        if editID == "" </span><span class="cov0" title="0">{
                edit, err = publisher.Edits.Insert(c.packageName, nil).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
                }</span>
                <span class="cov0" title="0">created = true</span>
        } else<span class="cov0" title="0"> {
                edit = &amp;androidpublisher.AppEdit{Id: editID}
        }</span>
        <span class="cov0" title="0">if created </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if err := publisher.Edits.Delete(c.packageName, edit.Id).Context(ctx).Do(); err != nil </span><span class="cov0" title="0">{
                                logging.Warn("failed to delete edit", logging.String("package", c.packageName), logging.String("editId", edit.Id), logging.Err(err))
                        }</span>
                }()
        }
        <span class="cov0" title="0">images, err := publisher.Edits.Images.List(c.packageName, edit.Id, locale, imageType).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                apiErr := errors.ClassifyAuthError(err)
                if apiErr == nil </span><span class="cov0" title="0">{
                        apiErr = errors.NewAPIError(errors.CodeGeneralError, err.Error())
                }</span>
                <span class="cov0" title="0">if apiErr.Hint == "" </span><span class="cov0" title="0">{
                        apiErr = apiErr.WithHint(imageTypeHint())
                }</span>
                <span class="cov0" title="0">result := output.NewErrorResult(apiErr).WithServices("androidpublisher")
                return c.Output(result)</span>
        }
        <span class="cov0" title="0">return c.Output(output.NewResult(images).WithServices("androidpublisher"))</span>
}

func (c *CLI) publishImagesDelete(ctx context.Context, imageType, imageID, locale, editID string, noAutoCommit, dryRun bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                result := output.NewResult(map[string]interface{}{
                        "dryRun":  true,
                        "action":  "images_delete",
                        "type":    imageType,
                        "locale":  locale,
                        "id":      imageID,
                        "package": c.packageName,
                })
                return c.Output(result.WithServices("androidpublisher"))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">editMgr, edit, created, err := c.prepareEdit(ctx, publisher, editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := editMgr.ReleaseLock(c.packageName); err != nil </span><span class="cov0" title="0">{
                        logging.Warn("failed to release edit lock", logging.String("package", c.packageName), logging.Err(err))
                }</span>
        }()

        <span class="cov0" title="0">if err := publisher.Edits.Images.Delete(c.packageName, edit.ServerID, locale, imageType, imageID).Context(ctx).Do(); err != nil </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        if cleanupErr := publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do(); cleanupErr != nil </span><span class="cov0" title="0">{
                                logging.Warn("failed to delete edit", logging.String("package", c.packageName), logging.String("editId", edit.ServerID), logging.Err(cleanupErr))
                        }</span>
                }
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))</span>
        }
        <span class="cov0" title="0">if err := c.finalizeEdit(ctx, publisher, editMgr, edit, !noAutoCommit); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":   true,
                "type":      imageType,
                "locale":    locale,
                "id":        imageID,
                "package":   c.packageName,
                "editId":    edit.ServerID,
                "committed": !noAutoCommit,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) publishImagesDeleteAll(ctx context.Context, imageType, locale, editID string, noAutoCommit, dryRun bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                result := output.NewResult(map[string]interface{}{
                        "dryRun":  true,
                        "action":  "images_deleteall",
                        "type":    imageType,
                        "locale":  locale,
                        "package": c.packageName,
                })
                return c.Output(result.WithServices("androidpublisher"))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">editMgr, edit, created, err := c.prepareEdit(ctx, publisher, editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := editMgr.ReleaseLock(c.packageName); err != nil </span><span class="cov0" title="0">{
                        logging.Warn("failed to release edit lock", logging.String("package", c.packageName), logging.Err(err))
                }</span>
        }()

        <span class="cov0" title="0">if _, err := publisher.Edits.Images.Deleteall(c.packageName, edit.ServerID, locale, imageType).Context(ctx).Do(); err != nil </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        if cleanupErr := publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do(); cleanupErr != nil </span><span class="cov0" title="0">{
                                logging.Warn("failed to delete edit", logging.String("package", c.packageName), logging.String("editId", edit.ServerID), logging.Err(cleanupErr))
                        }</span>
                }
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))</span>
        }
        <span class="cov0" title="0">if err := c.finalizeEdit(ctx, publisher, editMgr, edit, !noAutoCommit); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":   true,
                "type":      imageType,
                "locale":    locale,
                "package":   c.packageName,
                "editId":    edit.ServerID,
                "committed": !noAutoCommit,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) publishAssetsUpload(_ context.Context, dir, category string, replace bool, editID string, noAutoCommit, dryRun bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                result := output.NewResult(map[string]interface{}{
                        "dryRun":   true,
                        "action":   "upload_assets",
                        "dir":      dir,
                        "category": category,
                        "replace":  replace,
                        "package":  c.packageName,
                })
                return c.Output(result.WithServices("androidpublisher"))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":   true,
                "dir":       dir,
                "category":  category,
                "replace":   replace,
                "package":   c.packageName,
                "editId":    editID,
                "committed": !noAutoCommit,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) publishAssetsSpec(_ context.Context) error <span class="cov0" title="0">{
        result := output.NewResult(map[string]interface{}{
                "phone": map[string]interface{}{
                        "screenshot": map[string]interface{}{
                                "minWidth":  320,
                                "maxWidth":  3840,
                                "minHeight": 320,
                                "maxHeight": 3840,
                                "maxSize":   8 * 1024 * 1024,
                                "formats":   []string{"png", "jpg", "jpeg"},
                                "maxCount":  8,
                        },
                },
                "tablet": map[string]interface{}{
                        "screenshot": map[string]interface{}{
                                "minWidth":  320,
                                "maxWidth":  3840,
                                "minHeight": 320,
                                "maxHeight": 3840,
                                "maxSize":   8 * 1024 * 1024,
                                "formats":   []string{"png", "jpg", "jpeg"},
                                "maxCount":  8,
                        },
                },
                "featureGraphic": map[string]interface{}{
                        "width":   1024,
                        "height":  500,
                        "maxSize": 1 * 1024 * 1024,
                        "formats": []string{"png", "jpg", "jpeg"},
                },
                "icon": map[string]interface{}{
                        "width":   512,
                        "height":  512,
                        "maxSize": 1 * 1024 * 1024,
                        "formats": []string{"png"},
                },
        })
        return c.Output(result.WithServices("androidpublisher"))
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package cli

import (
        "context"
        "fmt"
        "strings"

        "google.golang.org/api/androidpublisher/v3"

        "github.com/dl-alexandre/gpd/internal/config"
        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

func (c *CLI) publishListingUpdate(ctx context.Context, locale, title, shortDesc, fullDesc, editID string, noAutoCommit, dryRun bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">locale = config.NormalizeLocale(locale)

        if dryRun </span><span class="cov0" title="0">{
                result := output.NewResult(map[string]interface{}{
                        "dryRun":           true,
                        "action":           "update_listing",
                        "locale":           locale,
                        "title":            title,
                        "shortDescription": shortDesc,
                        "fullDescription":  fullDesc,
                        "package":          c.packageName,
                })
                return c.Output(result.WithServices("androidpublisher"))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr, edit, created, err := c.prepareEdit(ctx, publisher, editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = editMgr.ReleaseLock(c.packageName) }</span>()

        <span class="cov0" title="0">listing := &amp;androidpublisher.Listing{
                Language: locale,
        }
        if title != "" </span><span class="cov0" title="0">{
                listing.Title = title
        }</span>
        <span class="cov0" title="0">if shortDesc != "" </span><span class="cov0" title="0">{
                listing.ShortDescription = shortDesc
        }</span>
        <span class="cov0" title="0">if fullDesc != "" </span><span class="cov0" title="0">{
                listing.FullDescription = fullDesc
        }</span>

        <span class="cov0" title="0">updatedListing, err := publisher.Edits.Listings.Update(c.packageName, edit.ServerID, locale, listing).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        _ = publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do()
                }</span>
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to update listing: %v", err)))</span>
        }

        <span class="cov0" title="0">if err := c.finalizeEdit(ctx, publisher, editMgr, edit, !noAutoCommit); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":          true,
                "locale":           updatedListing.Language,
                "title":            updatedListing.Title,
                "shortDescription": updatedListing.ShortDescription,
                "fullDescription":  updatedListing.FullDescription,
                "package":          c.packageName,
                "editId":           edit.ServerID,
                "committed":        !noAutoCommit,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) publishListingGet(ctx context.Context, locale string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">edit, err := publisher.Edits.Insert(c.packageName, nil).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to create edit: %v", err)))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = publisher.Edits.Delete(c.packageName, edit.Id).Context(ctx).Do() }</span>()

        <span class="cov0" title="0">if locale != "" </span><span class="cov0" title="0">{
                locale = config.NormalizeLocale(locale)
                listing, err := publisher.Edits.Listings.Get(c.packageName, edit.Id, locale).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeNotFound,
                                fmt.Sprintf("listing not found for locale: %s", locale)))
                }</span>
                <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                        "locale":           listing.Language,
                        "title":            listing.Title,
                        "shortDescription": listing.ShortDescription,
                        "fullDescription":  listing.FullDescription,
                        "video":            listing.Video,
                        "package":          c.packageName,
                })
                return c.Output(result.WithServices("androidpublisher"))</span>
        }

        <span class="cov0" title="0">listings, err := publisher.Edits.Listings.List(c.packageName, edit.Id).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">var listingResults []map[string]interface{}
        for _, listing := range listings.Listings </span><span class="cov0" title="0">{
                listingResults = append(listingResults, map[string]interface{}{
                        "locale":           listing.Language,
                        "title":            listing.Title,
                        "shortDescription": listing.ShortDescription,
                        "fullDescription":  listing.FullDescription,
                })
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "listings": listingResults,
                "count":    len(listingResults),
                "package":  c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) publishListingDelete(ctx context.Context, locale, editID string, noAutoCommit, dryRun, confirm bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">if !confirm </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError,
                        "--confirm flag required for destructive operations"))
        }</span>
        <span class="cov0" title="0">if locale == "" </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError, "locale is required"))
        }</span>
        <span class="cov0" title="0">locale = config.NormalizeLocale(locale)

        if dryRun </span><span class="cov0" title="0">{
                result := output.NewResult(map[string]interface{}{
                        "dryRun":  true,
                        "action":  "delete_listing",
                        "locale":  locale,
                        "package": c.packageName,
                })
                return c.Output(result.WithServices("androidpublisher"))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr, edit, created, err := c.prepareEdit(ctx, publisher, editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = editMgr.ReleaseLock(c.packageName) }</span>()

        <span class="cov0" title="0">if err := publisher.Edits.Listings.Delete(c.packageName, edit.ServerID, locale).Context(ctx).Do(); err != nil </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        _ = publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do()
                }</span>
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to delete listing: %v", err)))</span>
        }

        <span class="cov0" title="0">if err := c.finalizeEdit(ctx, publisher, editMgr, edit, !noAutoCommit); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":   true,
                "locale":    locale,
                "package":   c.packageName,
                "editId":    edit.ServerID,
                "committed": !noAutoCommit,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) publishListingDeleteAll(ctx context.Context, editID string, noAutoCommit, dryRun, confirm bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">if !confirm </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError,
                        "--confirm flag required for destructive operations"))
        }</span>

        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                result := output.NewResult(map[string]interface{}{
                        "dryRun":  true,
                        "action":  "delete_all_listings",
                        "package": c.packageName,
                })
                return c.Output(result.WithServices("androidpublisher"))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr, edit, created, err := c.prepareEdit(ctx, publisher, editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = editMgr.ReleaseLock(c.packageName) }</span>()

        <span class="cov0" title="0">if err := publisher.Edits.Listings.Deleteall(c.packageName, edit.ServerID).Context(ctx).Do(); err != nil </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        _ = publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do()
                }</span>
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to delete listings: %v", err)))</span>
        }

        <span class="cov0" title="0">if err := c.finalizeEdit(ctx, publisher, editMgr, edit, !noAutoCommit); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":   true,
                "package":   c.packageName,
                "editId":    edit.ServerID,
                "committed": !noAutoCommit,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) publishDetailsGet(ctx context.Context) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">edit, err := publisher.Edits.Insert(c.packageName, nil).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to create edit: %v", err)))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = publisher.Edits.Delete(c.packageName, edit.Id).Context(ctx).Do() }</span>()

        <span class="cov0" title="0">details, err := publisher.Edits.Details.Get(c.packageName, edit.Id).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">return c.Output(output.NewResult(details).WithServices("androidpublisher"))</span>
}

func (c *CLI) publishDetailsUpdate(ctx context.Context, email, phone, website, defaultLanguage, editID string, noAutoCommit, dryRun bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">if email == "" &amp;&amp; phone == "" &amp;&amp; website == "" &amp;&amp; defaultLanguage == "" </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError, "at least one field is required"))
        }</span>
        <span class="cov0" title="0">if email != "" &amp;&amp; !isValidEmail(email) </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError, "invalid contact email"))
        }</span>
        <span class="cov0" title="0">if website != "" &amp;&amp; !isValidURL(website) </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError, "invalid contact website"))
        }</span>

        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                result := output.NewResult(map[string]interface{}{
                        "dryRun":          true,
                        "action":          "details_update",
                        "contactEmail":    email,
                        "contactPhone":    phone,
                        "contactWebsite":  website,
                        "defaultLanguage": defaultLanguage,
                        "package":         c.packageName,
                })
                return c.Output(result.WithServices("androidpublisher"))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr, edit, created, err := c.prepareEdit(ctx, publisher, editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = editMgr.ReleaseLock(c.packageName) }</span>()

        <span class="cov0" title="0">details := &amp;androidpublisher.AppDetails{
                ContactEmail:    email,
                ContactPhone:    phone,
                ContactWebsite:  website,
                DefaultLanguage: defaultLanguage,
        }

        updated, err := publisher.Edits.Details.Update(c.packageName, edit.ServerID, details).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        _ = publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do()
                }</span>
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))</span>
        }

        <span class="cov0" title="0">if err := c.finalizeEdit(ctx, publisher, editMgr, edit, !noAutoCommit); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":   true,
                "details":   updated,
                "package":   c.packageName,
                "editId":    edit.ServerID,
                "committed": !noAutoCommit,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

// detailsPatchParams holds parameters for patching app details.
type detailsPatchParams struct {
        email           string
        phone           string
        website         string
        defaultLanguage string
        updateMask      string
        editID          string
        noAutoCommit    bool
}

// validateDetailsPatchInput validates the input parameters for details patch.
func validateDetailsPatchInput(email, phone, website, defaultLanguage string) *errors.APIError <span class="cov0" title="0">{
        if email == "" &amp;&amp; phone == "" &amp;&amp; website == "" &amp;&amp; defaultLanguage == "" </span><span class="cov0" title="0">{
                return errors.NewAPIError(errors.CodeValidationError, "at least one field is required")
        }</span>
        <span class="cov0" title="0">if email != "" &amp;&amp; !isValidEmail(email) </span><span class="cov0" title="0">{
                return errors.NewAPIError(errors.CodeValidationError, "invalid contact email")
        }</span>
        <span class="cov0" title="0">if website != "" &amp;&amp; !isValidURL(website) </span><span class="cov0" title="0">{
                return errors.NewAPIError(errors.CodeValidationError, "invalid contact website")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// buildUpdateMask constructs the update mask from non-empty fields.
func buildUpdateMask(email, phone, website, defaultLanguage, existingMask string) string <span class="cov0" title="0">{
        if existingMask != "" </span><span class="cov0" title="0">{
                return existingMask
        }</span>
        <span class="cov0" title="0">var fields []string
        if email != "" </span><span class="cov0" title="0">{
                fields = append(fields, "contactEmail")
        }</span>
        <span class="cov0" title="0">if phone != "" </span><span class="cov0" title="0">{
                fields = append(fields, "contactPhone")
        }</span>
        <span class="cov0" title="0">if website != "" </span><span class="cov0" title="0">{
                fields = append(fields, "contactWebsite")
        }</span>
        <span class="cov0" title="0">if defaultLanguage != "" </span><span class="cov0" title="0">{
                fields = append(fields, "defaultLanguage")
        }</span>
        <span class="cov0" title="0">return strings.Join(fields, ",")</span>
}

func (c *CLI) publishDetailsPatch(ctx context.Context, email, phone, website, defaultLanguage, updateMask, editID string, noAutoCommit, dryRun bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">if err := validateDetailsPatchInput(email, phone, website, defaultLanguage); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err)
        }</span>

        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                return c.outputDetailsPatchDryRun(email, phone, website, defaultLanguage, updateMask)
        }</span>

        <span class="cov0" title="0">params := &amp;detailsPatchParams{
                email:           email,
                phone:           phone,
                website:         website,
                defaultLanguage: defaultLanguage,
                updateMask:      buildUpdateMask(email, phone, website, defaultLanguage, updateMask),
                editID:          editID,
                noAutoCommit:    noAutoCommit,
        }

        return c.executeDetailsPatch(ctx, params)</span>
}

// outputDetailsPatchDryRun outputs the dry run result for details patch.
func (c *CLI) outputDetailsPatchDryRun(email, phone, website, defaultLanguage, updateMask string) error <span class="cov0" title="0">{
        result := output.NewResult(map[string]interface{}{
                "dryRun":          true,
                "action":          "details_patch",
                "contactEmail":    email,
                "contactPhone":    phone,
                "contactWebsite":  website,
                "defaultLanguage": defaultLanguage,
                "updateMask":      updateMask,
                "package":         c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))
}</span>

// executeDetailsPatch performs the actual patch operation.
func (c *CLI) executeDetailsPatch(ctx context.Context, params *detailsPatchParams) error <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr, edit, created, err := c.prepareEdit(ctx, publisher, params.editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = editMgr.ReleaseLock(c.packageName) }</span>()

        <span class="cov0" title="0">details := &amp;androidpublisher.AppDetails{
                ContactEmail:    params.email,
                ContactPhone:    params.phone,
                ContactWebsite:  params.website,
                DefaultLanguage: params.defaultLanguage,
        }

        call := publisher.Edits.Details.Patch(c.packageName, edit.ServerID, details)
        _ = params.updateMask // Note: API does not support field mask for Details.Patch
        updated, err := call.Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        _ = publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do()
                }</span>
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))</span>
        }

        <span class="cov0" title="0">if err := c.finalizeEdit(ctx, publisher, editMgr, edit, !params.noAutoCommit); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":   true,
                "details":   updated,
                "package":   c.packageName,
                "editId":    edit.ServerID,
                "committed": !params.noAutoCommit,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package cli

import (
        "context"
        "fmt"
        "os"
        "strings"

        "google.golang.org/api/androidpublisher/v3"

        "github.com/dl-alexandre/gpd/internal/errors"
)

type obbOptions struct {
        mainPath              string
        patchPath             string
        mainReferenceVersion  int64
        patchReferenceVersion int64
}

func validateObbOptions(ext string, opts obbOptions) *errors.APIError <span class="cov0" title="0">{
        hasObb := opts.mainPath != "" || opts.patchPath != "" || opts.mainReferenceVersion &gt; 0 || opts.patchReferenceVersion &gt; 0
        if hasObb &amp;&amp; ext != extAPK </span><span class="cov0" title="0">{
                return errors.NewAPIError(errors.CodeValidationError, "expansion files are only supported for APK uploads")
        }</span>
        <span class="cov0" title="0">if opts.mainPath != "" &amp;&amp; opts.mainReferenceVersion &gt; 0 </span><span class="cov0" title="0">{
                return errors.NewAPIError(errors.CodeValidationError, "cannot set both --obb-main and --obb-main-references-version")
        }</span>
        <span class="cov0" title="0">if opts.patchPath != "" &amp;&amp; opts.patchReferenceVersion &gt; 0 </span><span class="cov0" title="0">{
                return errors.NewAPIError(errors.CodeValidationError, "cannot set both --obb-patch and --obb-patch-references-version")
        }</span>
        <span class="cov0" title="0">if opts.mainReferenceVersion &lt; 0 || opts.patchReferenceVersion &lt; 0 </span><span class="cov0" title="0">{
                return errors.NewAPIError(errors.CodeValidationError, "expansion file reference version must be positive")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateObbFile(path string) (os.FileInfo, *errors.APIError) <span class="cov0" title="0">{
        if strings.TrimSpace(path) == "" </span><span class="cov0" title="0">{
                return nil, errors.NewAPIError(errors.CodeValidationError, "expansion file path is required")
        }</span>
        <span class="cov0" title="0">info, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewAPIError(errors.CodeValidationError, fmt.Sprintf("file not found: %s", path))
        }</span>
        <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                return nil, errors.NewAPIError(errors.CodeValidationError, fmt.Sprintf("file is a directory: %s", path))
        }</span>
        <span class="cov0" title="0">return info, nil</span>
}

func (c *CLI) uploadObbFiles(ctx context.Context, publisher *androidpublisher.Service, editID string, versionCode int64, opts obbOptions) (map[string]*androidpublisher.ExpansionFile, *errors.APIError) <span class="cov0" title="0">{
        results := map[string]*androidpublisher.ExpansionFile{}
        if opts.mainPath != "" </span><span class="cov0" title="0">{
                resp, err := uploadObbFile(ctx, publisher, c.packageName, editID, versionCode, "main", opts.mainPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">results["main"] = resp</span>
        } else<span class="cov0" title="0"> if opts.mainReferenceVersion &gt; 0 </span><span class="cov0" title="0">{
                resp, err := updateObbReference(ctx, publisher, c.packageName, editID, versionCode, "main", opts.mainReferenceVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">results["main"] = resp</span>
        }

        <span class="cov0" title="0">if opts.patchPath != "" </span><span class="cov0" title="0">{
                resp, err := uploadObbFile(ctx, publisher, c.packageName, editID, versionCode, "patch", opts.patchPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">results["patch"] = resp</span>
        } else<span class="cov0" title="0"> if opts.patchReferenceVersion &gt; 0 </span><span class="cov0" title="0">{
                resp, err := updateObbReference(ctx, publisher, c.packageName, editID, versionCode, "patch", opts.patchReferenceVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">results["patch"] = resp</span>
        }

        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return results, nil</span>
}

func uploadObbFile(ctx context.Context, publisher *androidpublisher.Service, packageName, editID string, versionCode int64, obbType, filePath string) (*androidpublisher.ExpansionFile, *errors.APIError) <span class="cov0" title="0">{
        f, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewAPIError(errors.CodeGeneralError, err.Error())
        }</span>

        <span class="cov0" title="0">resp, err := publisher.Edits.Expansionfiles.Upload(packageName, editID, versionCode, obbType).Media(f).Context(ctx).Do()
        closeErr := f.Close()
        if err != nil </span><span class="cov0" title="0">{
                if closeErr != nil </span><span class="cov0" title="0">{
                        return nil, errors.NewAPIError(errors.CodeGeneralError, fmt.Sprintf("%v; close error: %v", err, closeErr))
                }</span>
                <span class="cov0" title="0">return nil, errors.NewAPIError(errors.CodeGeneralError, err.Error())</span>
        }
        <span class="cov0" title="0">if closeErr != nil </span><span class="cov0" title="0">{
                return nil, errors.NewAPIError(errors.CodeGeneralError, closeErr.Error())
        }</span>
        <span class="cov0" title="0">if resp == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return resp.ExpansionFile, nil</span>
}

func updateObbReference(ctx context.Context, publisher *androidpublisher.Service, packageName, editID string, versionCode int64, obbType string, referenceVersion int64) (*androidpublisher.ExpansionFile, *errors.APIError) <span class="cov0" title="0">{
        expansion := &amp;androidpublisher.ExpansionFile{ReferencesVersion: referenceVersion}
        resp, err := publisher.Edits.Expansionfiles.Update(packageName, editID, versionCode, obbType, expansion).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewAPIError(errors.CodeGeneralError, err.Error())
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package cli

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "strconv"
        "time"

        "google.golang.org/api/androidpublisher/v3"

        "github.com/dl-alexandre/gpd/internal/api"
        "github.com/dl-alexandre/gpd/internal/config"
        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

// Release status constants
const (
        statusCompleted  = "completed"
        statusInProgress = "inProgress"
)

func (c *CLI) publishRelease(ctx context.Context, track, name, status string, versionCodes, retainVersionCodes []string, inAppUpdatePriority int, releaseNotesFile, editID string, noAutoCommit, dryRun, wait bool, waitTimeout string) error <span class="cov0" title="0">{
        if err := c.validateReleaseParams(track, status); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err)
        }</span>
        <span class="cov0" title="0">if inAppUpdatePriority != -1 &amp;&amp; (inAppUpdatePriority &lt; 0 || inAppUpdatePriority &gt; 5) </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError, "in-app-update-priority must be between 0 and 5"))
        }</span>

        <span class="cov0" title="0">codes, err := c.parseVersionCodes(versionCodes)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err)
        }</span>
        <span class="cov0" title="0">retainedCodes, err := c.parseVersionCodes(retainVersionCodes)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err)
        }</span>
        <span class="cov0" title="0">combinedCodes := mergeVersionCodes(codes, retainedCodes)

        releaseNotes, err := c.parseReleaseNotesFile(releaseNotesFile)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err)
        }</span>

        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                return c.outputDryRunRelease(track, name, status, combinedCodes, retainedCodes, inAppUpdatePriority, releaseNotes)
        }</span>

        <span class="cov0" title="0">return c.executeRelease(ctx, track, name, status, combinedCodes, retainedCodes, inAppUpdatePriority, releaseNotes, editID, noAutoCommit, wait, waitTimeout)</span>
}

func (c *CLI) validateReleaseParams(track, status string) *errors.APIError <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return err.(*errors.APIError)
        }</span>
        <span class="cov0" title="0">if !config.IsValidTrack(track) </span><span class="cov0" title="0">{
                return errors.ErrTrackInvalid
        }</span>
        <span class="cov0" title="0">if !api.IsValidReleaseStatus(status) </span><span class="cov0" title="0">{
                return errors.NewAPIError(errors.CodeValidationError,
                        fmt.Sprintf("invalid status: %s", status)).
                        WithHint("Valid statuses: draft, completed, halted, inProgress")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *CLI) parseVersionCodes(versionCodes []string) ([]int64, *errors.APIError) <span class="cov0" title="0">{
        var codes []int64
        for _, vc := range versionCodes </span><span class="cov0" title="0">{
                code, err := strconv.ParseInt(vc, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.NewAPIError(errors.CodeValidationError,
                                fmt.Sprintf("invalid version code: %s", vc))
                }</span>
                <span class="cov0" title="0">codes = append(codes, code)</span>
        }
        <span class="cov0" title="0">return codes, nil</span>
}

func mergeVersionCodes(primary, retain []int64) []int64 <span class="cov0" title="0">{
        seen := map[int64]bool{}
        var combined []int64
        for _, code := range primary </span><span class="cov0" title="0">{
                if seen[code] </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">seen[code] = true
                combined = append(combined, code)</span>
        }
        <span class="cov0" title="0">for _, code := range retain </span><span class="cov0" title="0">{
                if seen[code] </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">seen[code] = true
                combined = append(combined, code)</span>
        }
        <span class="cov0" title="0">return combined</span>
}

func (c *CLI) parseReleaseNotesFile(releaseNotesFile string) (map[string]string, *errors.APIError) <span class="cov0" title="0">{
        if releaseNotesFile == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">data, err := os.ReadFile(releaseNotesFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewAPIError(errors.CodeValidationError,
                        fmt.Sprintf("failed to read release notes file: %v", err))
        }</span>

        <span class="cov0" title="0">var releaseNotes map[string]string
        if err := json.Unmarshal(data, &amp;releaseNotes); err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewAPIError(errors.CodeValidationError,
                        fmt.Sprintf("invalid release notes JSON: %v", err)).
                        WithHint("Expected format: {\"en-US\": \"Release notes text\", \"ja-JP\": \"\"}")
        }</span>

        <span class="cov0" title="0">normalized := make(map[string]string, len(releaseNotes))
        for locale, text := range releaseNotes </span><span class="cov0" title="0">{
                normalized[config.NormalizeLocale(locale)] = text
        }</span>
        <span class="cov0" title="0">return normalized, nil</span>
}

func (c *CLI) outputDryRunRelease(track, name, status string, codes, retainedCodes []int64, inAppUpdatePriority int, releaseNotes map[string]string) error <span class="cov0" title="0">{
        dryRunData := map[string]interface{}{
                "dryRun":       true,
                "action":       "release",
                "track":        track,
                "name":         name,
                "status":       status,
                "versionCodes": codes,
                "package":      c.packageName,
        }
        if len(retainedCodes) &gt; 0 </span><span class="cov0" title="0">{
                dryRunData["retainedVersionCodes"] = retainedCodes
        }</span>
        <span class="cov0" title="0">if inAppUpdatePriority &gt;= 0 </span><span class="cov0" title="0">{
                dryRunData["inAppUpdatePriority"] = inAppUpdatePriority
        }</span>
        <span class="cov0" title="0">if len(releaseNotes) &gt; 0 </span><span class="cov0" title="0">{
                dryRunData["releaseNotes"] = releaseNotes
        }</span>
        <span class="cov0" title="0">result := output.NewResult(dryRunData)
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) executeRelease(ctx context.Context, track, name, status string, codes, retainedCodes []int64, inAppUpdatePriority int, releaseNotes map[string]string, editID string, noAutoCommit, wait bool, waitTimeout string) error <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr, edit, created, err := c.prepareEdit(ctx, publisher, editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = editMgr.ReleaseLock(c.packageName) }</span>()

        <span class="cov0" title="0">trackInfo, err := publisher.Edits.Tracks.Get(c.packageName, edit.ServerID, track).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                c.cleanupEditOnError(ctx, publisher, edit.ServerID, created)
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to get track: %v", err)))
        }</span>

        <span class="cov0" title="0">release := c.buildTrackRelease(name, status, codes, inAppUpdatePriority, releaseNotes)
        trackInfo.Releases = []*androidpublisher.TrackRelease{release}

        _, err = publisher.Edits.Tracks.Update(c.packageName, edit.ServerID, track, trackInfo).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                c.cleanupEditOnError(ctx, publisher, edit.ServerID, created)
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to update track: %v", err)))
        }</span>

        <span class="cov0" title="0">if err := c.finalizeEdit(ctx, publisher, editMgr, edit, !noAutoCommit); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">return c.outputReleaseResult(ctx, publisher, track, name, status, codes, retainedCodes, inAppUpdatePriority, releaseNotes, edit.ServerID, noAutoCommit, wait, waitTimeout)</span>
}

func (c *CLI) cleanupEditOnError(ctx context.Context, publisher *androidpublisher.Service, editID string, created bool) <span class="cov0" title="0">{
        if created </span><span class="cov0" title="0">{
                _ = publisher.Edits.Delete(c.packageName, editID).Context(ctx).Do()
        }</span>
}

func (c *CLI) buildTrackRelease(name, status string, codes []int64, inAppUpdatePriority int, releaseNotes map[string]string) *androidpublisher.TrackRelease <span class="cov0" title="0">{
        release := &amp;androidpublisher.TrackRelease{
                Name:         name,
                VersionCodes: codes,
                Status:       status,
        }
        if inAppUpdatePriority &gt;= 0 </span><span class="cov0" title="0">{
                release.InAppUpdatePriority = int64(inAppUpdatePriority)
        }</span>

        <span class="cov0" title="0">if len(releaseNotes) &gt; 0 </span><span class="cov0" title="0">{
                localizedNotes := make([]*androidpublisher.LocalizedText, 0, len(releaseNotes))
                for locale, text := range releaseNotes </span><span class="cov0" title="0">{
                        localizedNotes = append(localizedNotes, &amp;androidpublisher.LocalizedText{
                                Language: locale,
                                Text:     text,
                        })
                }</span>
                <span class="cov0" title="0">release.ReleaseNotes = localizedNotes</span>
        }

        <span class="cov0" title="0">return release</span>
}

func (c *CLI) outputReleaseResult(ctx context.Context, publisher *androidpublisher.Service, track, name, status string, codes, retainedCodes []int64, inAppUpdatePriority int, releaseNotes map[string]string, editID string, noAutoCommit, wait bool, waitTimeout string) error <span class="cov0" title="0">{
        resultData := map[string]interface{}{
                "success":      true,
                "track":        track,
                "name":         name,
                "status":       status,
                "versionCodes": codes,
                "package":      c.packageName,
                "editId":       editID,
                "committed":    !noAutoCommit,
        }
        if len(retainedCodes) &gt; 0 </span><span class="cov0" title="0">{
                resultData["retainedVersionCodes"] = retainedCodes
        }</span>
        <span class="cov0" title="0">if inAppUpdatePriority &gt;= 0 </span><span class="cov0" title="0">{
                resultData["inAppUpdatePriority"] = inAppUpdatePriority
        }</span>
        <span class="cov0" title="0">if len(releaseNotes) &gt; 0 </span><span class="cov0" title="0">{
                resultData["releaseNotes"] = releaseNotes
        }</span>

        <span class="cov0" title="0">if wait &amp;&amp; status == statusInProgress </span><span class="cov0" title="0">{
                if err := c.waitAndUpdateResult(ctx, publisher, track, waitTimeout, resultData); err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(err)
                }</span>
        }

        <span class="cov0" title="0">result := output.NewResult(resultData)
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) waitAndUpdateResult(ctx context.Context, publisher *androidpublisher.Service, track, waitTimeout string, resultData map[string]interface{}) *errors.APIError <span class="cov0" title="0">{
        timeout, err := time.ParseDuration(waitTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return errors.NewAPIError(errors.CodeValidationError,
                        fmt.Sprintf("invalid wait-timeout: %v", err)).
                        WithHint("Examples: 30m, 1h, 90m")
        }</span>

        <span class="cov0" title="0">finalRelease, apiErr := c.waitForReleaseCompletion(ctx, publisher, c.packageName, track, timeout)
        if apiErr != nil </span><span class="cov0" title="0">{
                return apiErr.(*errors.APIError)
        }</span>

        <span class="cov0" title="0">resultData["waited"] = true
        resultData["finalStatus"] = finalRelease.Status
        resultData["waitDuration"] = timeout.String()
        return nil</span>
}

func (c *CLI) waitForReleaseCompletion(ctx context.Context, publisher *androidpublisher.Service, packageName, track string, timeout time.Duration) (*androidpublisher.TrackRelease, error) <span class="cov0" title="0">{
        deadline := time.Now().Add(timeout)
        pollInterval := 10 * time.Second

        for time.Now().Before(deadline) </span><span class="cov0" title="0">{
                tempEdit, err := publisher.Edits.Insert(packageName, nil).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.NewAPIError(errors.CodeGeneralError,
                                fmt.Sprintf("failed to create edit for polling: %v", err))
                }</span>

                <span class="cov0" title="0">trackInfo, err := publisher.Edits.Tracks.Get(packageName, tempEdit.Id, track).Context(ctx).Do()
                _ = publisher.Edits.Delete(packageName, tempEdit.Id).Context(ctx).Do()

                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.NewAPIError(errors.CodeGeneralError,
                                fmt.Sprintf("failed to get track status: %v", err))
                }</span>

                <span class="cov0" title="0">for _, release := range trackInfo.Releases </span><span class="cov0" title="0">{
                        if release.Status == statusCompleted </span><span class="cov0" title="0">{
                                return release, nil
                        }</span>
                }

                <span class="cov0" title="0">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, errors.NewAPIError(errors.CodeGeneralError, "context cancelled")</span>
                case &lt;-time.After(pollInterval):<span class="cov0" title="0">
                        continue</span>
                }
        }

        <span class="cov0" title="0">return nil, errors.NewAPIError(errors.CodeGeneralError,
                fmt.Sprintf("release did not complete within timeout (%v)", timeout)).
                WithHint("Increase --wait-timeout or check release status manually")</span>
}

func (c *CLI) publishRollout(ctx context.Context, track string, percentage float64, editID string, noAutoCommit, dryRun bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">if percentage &lt; 0.01 || percentage &gt; 100 </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError,
                        "percentage must be between 0.01 and 100"))
        }</span>

        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                result := output.NewResult(map[string]interface{}{
                        "dryRun":     true,
                        "action":     "rollout",
                        "track":      track,
                        "percentage": percentage,
                        "package":    c.packageName,
                })
                return c.Output(result.WithServices("androidpublisher"))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr, edit, created, err := c.prepareEdit(ctx, publisher, editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = editMgr.ReleaseLock(c.packageName) }</span>()

        <span class="cov0" title="0">trackInfo, err := publisher.Edits.Tracks.Get(c.packageName, edit.ServerID, track).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        _ = publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do()
                }</span>
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeNotFound,
                        fmt.Sprintf("track not found: %s", track)))</span>
        }

        <span class="cov0" title="0">var updatedRelease *androidpublisher.TrackRelease
        for i, release := range trackInfo.Releases </span><span class="cov0" title="0">{
                if release.Status == statusInProgress </span><span class="cov0" title="0">{
                        userFraction := percentage / 100.0
                        trackInfo.Releases[i].UserFraction = userFraction
                        updatedRelease = trackInfo.Releases[i]
                        break</span>
                }
        }

        <span class="cov0" title="0">if updatedRelease == nil </span><span class="cov0" title="0">{
                _ = publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do()
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError,
                        "no in-progress release found on track").
                        WithHint("Create a staged rollout release first with status 'inProgress'"))
        }</span>

        <span class="cov0" title="0">_, err = publisher.Edits.Tracks.Update(c.packageName, edit.ServerID, track, trackInfo).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        _ = publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do()
                }</span>
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to update track: %v", err)))</span>
        }

        <span class="cov0" title="0">if err := c.finalizeEdit(ctx, publisher, editMgr, edit, !noAutoCommit); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":      true,
                "track":        track,
                "percentage":   percentage,
                "userFraction": percentage / 100.0,
                "versionCodes": updatedRelease.VersionCodes,
                "package":      c.packageName,
                "editId":       edit.ServerID,
                "committed":    !noAutoCommit,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

// promoteParams holds parameters for the promote operation.
type promoteParams struct {
        fromTrack    string
        toTrack      string
        percentage   float64
        editID       string
        noAutoCommit bool
}

// validatePromoteInput validates the input parameters for promotion.
func validatePromoteInput(fromTrack, toTrack string) *errors.APIError <span class="cov0" title="0">{
        if !config.IsValidTrack(fromTrack) || !config.IsValidTrack(toTrack) </span><span class="cov0" title="0">{
                return errors.ErrTrackInvalid
        }</span>
        <span class="cov0" title="0">if fromTrack == toTrack </span><span class="cov0" title="0">{
                return errors.NewAPIError(errors.CodeValidationError,
                        "source and destination tracks must be different")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// findActiveRelease finds the first active (completed or in-progress) release from a track.
func findActiveRelease(sourceTrack *androidpublisher.Track) *androidpublisher.TrackRelease <span class="cov0" title="0">{
        for _, release := range sourceTrack.Releases </span><span class="cov0" title="0">{
                if release.Status == statusCompleted || release.Status == statusInProgress </span><span class="cov0" title="0">{
                        return release
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// createPromotedRelease creates a new release for the destination track based on the source release.
func createPromotedRelease(sourceRelease *androidpublisher.TrackRelease, percentage float64) *androidpublisher.TrackRelease <span class="cov0" title="0">{
        newRelease := &amp;androidpublisher.TrackRelease{
                Name:         sourceRelease.Name,
                VersionCodes: sourceRelease.VersionCodes,
                ReleaseNotes: sourceRelease.ReleaseNotes,
        }
        if percentage &gt; 0 &amp;&amp; percentage &lt; 100 </span><span class="cov0" title="0">{
                newRelease.Status = statusInProgress
                newRelease.UserFraction = percentage / 100.0
        }</span> else<span class="cov0" title="0"> {
                newRelease.Status = statusCompleted
        }</span>
        <span class="cov0" title="0">return newRelease</span>
}

func (c *CLI) publishPromote(ctx context.Context, fromTrack, toTrack string, percentage float64, editID string, noAutoCommit, dryRun bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">if err := validatePromoteInput(fromTrack, toTrack); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err)
        }</span>

        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                return c.outputPromoteDryRun(fromTrack, toTrack, percentage)
        }</span>

        <span class="cov0" title="0">params := promoteParams{
                fromTrack:    fromTrack,
                toTrack:      toTrack,
                percentage:   percentage,
                editID:       editID,
                noAutoCommit: noAutoCommit,
        }

        return c.executePromote(ctx, params)</span>
}

// outputPromoteDryRun outputs the dry run result for promotion.
func (c *CLI) outputPromoteDryRun(fromTrack, toTrack string, percentage float64) error <span class="cov0" title="0">{
        result := output.NewResult(map[string]interface{}{
                "dryRun":     true,
                "action":     "promote",
                "fromTrack":  fromTrack,
                "toTrack":    toTrack,
                "percentage": percentage,
                "package":    c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))
}</span>

// executePromote performs the actual promotion operation.
func (c *CLI) executePromote(ctx context.Context, params promoteParams) error <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr, edit, created, err := c.prepareEdit(ctx, publisher, params.editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = editMgr.ReleaseLock(c.packageName) }</span>()

        <span class="cov0" title="0">cleanupEdit := func() </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        _ = publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do()
                }</span>
        }

        <span class="cov0" title="0">sourceRelease, apiErr := c.getSourceRelease(ctx, publisher, edit.ServerID, params.fromTrack, cleanupEdit)
        if apiErr != nil </span><span class="cov0" title="0">{
                return c.OutputError(apiErr)
        }</span>

        <span class="cov0" title="0">newRelease := createPromotedRelease(sourceRelease, params.percentage)

        if apiErr := c.updateDestinationTrack(ctx, publisher, edit.ServerID, params.toTrack, newRelease, cleanupEdit); apiErr != nil </span><span class="cov0" title="0">{
                return c.OutputError(apiErr)
        }</span>

        <span class="cov0" title="0">if err := c.finalizeEdit(ctx, publisher, editMgr, edit, !params.noAutoCommit); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":      true,
                "fromTrack":    params.fromTrack,
                "toTrack":      params.toTrack,
                "versionCodes": sourceRelease.VersionCodes,
                "status":       newRelease.Status,
                "percentage":   params.percentage,
                "package":      c.packageName,
                "editId":       edit.ServerID,
                "committed":    !params.noAutoCommit,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

// getSourceRelease retrieves the active release from the source track.
func (c *CLI) getSourceRelease(ctx context.Context, publisher *androidpublisher.Service, editID, fromTrack string, cleanup func()) (*androidpublisher.TrackRelease, *errors.APIError) <span class="cov0" title="0">{
        sourceTrack, err := publisher.Edits.Tracks.Get(c.packageName, editID, fromTrack).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                cleanup()
                return nil, errors.NewAPIError(errors.CodeNotFound,
                        fmt.Sprintf("source track not found: %s", fromTrack))
        }</span>

        <span class="cov0" title="0">sourceRelease := findActiveRelease(sourceTrack)
        if sourceRelease == nil </span><span class="cov0" title="0">{
                cleanup()
                return nil, errors.NewAPIError(errors.CodeValidationError,
                        fmt.Sprintf("no active release found on track: %s", fromTrack)).
                        WithHint("Ensure the source track has a completed or in-progress release")
        }</span>

        <span class="cov0" title="0">return sourceRelease, nil</span>
}

// updateDestinationTrack updates the destination track with the new release.
func (c *CLI) updateDestinationTrack(ctx context.Context, publisher *androidpublisher.Service, editID, toTrack string, newRelease *androidpublisher.TrackRelease, cleanup func()) *errors.APIError <span class="cov0" title="0">{
        destTrack, err := publisher.Edits.Tracks.Get(c.packageName, editID, toTrack).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                destTrack = &amp;androidpublisher.Track{
                        Track: toTrack,
                }
        }</span>

        <span class="cov0" title="0">destTrack.Releases = []*androidpublisher.TrackRelease{newRelease}

        _, err = publisher.Edits.Tracks.Update(c.packageName, editID, toTrack, destTrack).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                cleanup()
                return errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to update destination track: %v", err))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *CLI) publishHalt(ctx context.Context, track, editID string, noAutoCommit, dryRun bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                result := output.NewResult(map[string]interface{}{
                        "dryRun":  true,
                        "action":  "halt",
                        "track":   track,
                        "package": c.packageName,
                })
                return c.Output(result.WithServices("androidpublisher"))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr, edit, created, err := c.prepareEdit(ctx, publisher, editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = editMgr.ReleaseLock(c.packageName) }</span>()

        <span class="cov0" title="0">trackInfo, err := publisher.Edits.Tracks.Get(c.packageName, edit.ServerID, track).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        _ = publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do()
                }</span>
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeNotFound,
                        fmt.Sprintf("track not found: %s", track)))</span>
        }

        <span class="cov0" title="0">var haltedRelease *androidpublisher.TrackRelease
        for i, release := range trackInfo.Releases </span><span class="cov0" title="0">{
                if release.Status == statusInProgress </span><span class="cov0" title="0">{
                        trackInfo.Releases[i].Status = "halted"
                        haltedRelease = trackInfo.Releases[i]
                        break</span>
                }
        }

        <span class="cov0" title="0">if haltedRelease == nil </span><span class="cov0" title="0">{
                _ = publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do()
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError,
                        "no in-progress release found on track").
                        WithHint("Only releases with status 'inProgress' can be halted"))
        }</span>

        <span class="cov0" title="0">_, err = publisher.Edits.Tracks.Update(c.packageName, edit.ServerID, track, trackInfo).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        _ = publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do()
                }</span>
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to update track: %v", err)))</span>
        }

        <span class="cov0" title="0">if err := c.finalizeEdit(ctx, publisher, editMgr, edit, !noAutoCommit); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":      true,
                "track":        track,
                "status":       "halted",
                "versionCodes": haltedRelease.VersionCodes,
                "package":      c.packageName,
                "editId":       edit.ServerID,
                "committed":    !noAutoCommit,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

// rollbackResult holds the result of finding a release to rollback to.
type rollbackResult struct {
        release      *androidpublisher.TrackRelease
        versionCodes []int64
}

// findReleaseByVersionCode searches for a release containing the specified version code.
func findReleaseByVersionCode(trackInfo *androidpublisher.Track, targetVersionCode int64) *rollbackResult <span class="cov0" title="0">{
        for _, release := range trackInfo.Releases </span><span class="cov0" title="0">{
                for _, vc := range release.VersionCodes </span><span class="cov0" title="0">{
                        if vc == targetVersionCode </span><span class="cov0" title="0">{
                                return &amp;rollbackResult{
                                        release:      release,
                                        versionCodes: []int64{targetVersionCode},
                                }
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// findPreviousRelease finds the most recent completed release for rollback.
func findPreviousRelease(trackInfo *androidpublisher.Track) *rollbackResult <span class="cov0" title="0">{
        for _, release := range trackInfo.Releases </span><span class="cov0" title="0">{
                if release.Status == statusCompleted </span><span class="cov0" title="0">{
                        return &amp;rollbackResult{
                                release:      release,
                                versionCodes: release.VersionCodes,
                        }
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (c *CLI) publishRollback(ctx context.Context, track, versionCode, editID string, noAutoCommit, dryRun bool) error <span class="cov0" title="0">{
        if err := c.validateRollbackInput(track); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err)
        }</span>

        <span class="cov0" title="0">targetVersionCode, err := c.parseVersionCodeOpt(versionCode)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err)
        }</span>

        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                return c.outputRollbackDryRun(track, versionCode)
        }</span>

        <span class="cov0" title="0">return c.executeRollback(ctx, track, targetVersionCode, editID, noAutoCommit)</span>
}

// validateRollbackInput validates the input parameters for rollback.
func (c *CLI) validateRollbackInput(track string) *errors.APIError <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return err.(*errors.APIError)
        }</span>
        <span class="cov0" title="0">if !config.IsValidTrack(track) </span><span class="cov0" title="0">{
                return errors.ErrTrackInvalid
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// parseVersionCodeOpt parses an optional version code string.
func (c *CLI) parseVersionCodeOpt(versionCode string) (int64, *errors.APIError) <span class="cov0" title="0">{
        if versionCode == "" </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">parsed, err := strconv.ParseInt(versionCode, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.NewAPIError(errors.CodeValidationError,
                        fmt.Sprintf("invalid version code: %s", versionCode))
        }</span>
        <span class="cov0" title="0">return parsed, nil</span>
}

// outputRollbackDryRun outputs the dry run result for rollback.
func (c *CLI) outputRollbackDryRun(track, versionCode string) error <span class="cov0" title="0">{
        result := output.NewResult(map[string]interface{}{
                "dryRun":      true,
                "action":      "rollback",
                "track":       track,
                "versionCode": versionCode,
                "package":     c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))
}</span>

// executeRollback performs the actual rollback operation.
func (c *CLI) executeRollback(ctx context.Context, track string, targetVersionCode int64, editID string, noAutoCommit bool) error <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr, edit, created, err := c.prepareEdit(ctx, publisher, editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = editMgr.ReleaseLock(c.packageName) }</span>()

        <span class="cov0" title="0">cleanupEdit := func() </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        _ = publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do()
                }</span>
        }

        <span class="cov0" title="0">trackInfo, err := publisher.Edits.Tracks.Get(c.packageName, edit.ServerID, track).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                cleanupEdit()
                return c.OutputError(errors.NewAPIError(errors.CodeNotFound,
                        fmt.Sprintf("track not found: %s", track)))
        }</span>

        <span class="cov0" title="0">rollback, apiErr := c.findRollbackTarget(trackInfo, targetVersionCode, track)
        if apiErr != nil </span><span class="cov0" title="0">{
                cleanupEdit()
                return c.OutputError(apiErr)
        }</span>

        <span class="cov0" title="0">if apiErr := c.updateTrackWithRollback(ctx, publisher, edit.ServerID, track, trackInfo, rollback.versionCodes); apiErr != nil </span><span class="cov0" title="0">{
                cleanupEdit()
                return c.OutputError(apiErr)
        }</span>

        <span class="cov0" title="0">if err := c.finalizeEdit(ctx, publisher, editMgr, edit, !noAutoCommit); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":      true,
                "track":        track,
                "versionCodes": rollback.versionCodes,
                "releaseName":  rollback.release.Name,
                "package":      c.packageName,
                "editId":       edit.ServerID,
                "committed":    !noAutoCommit,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

// findRollbackTarget finds the appropriate release to rollback to.
func (c *CLI) findRollbackTarget(trackInfo *androidpublisher.Track, targetVersionCode int64, track string) (*rollbackResult, *errors.APIError) <span class="cov0" title="0">{
        if targetVersionCode &gt; 0 </span><span class="cov0" title="0">{
                result := findReleaseByVersionCode(trackInfo, targetVersionCode)
                if result == nil </span><span class="cov0" title="0">{
                        return nil, errors.NewAPIError(errors.CodeNotFound,
                                fmt.Sprintf("version code %d not found in track history", targetVersionCode)).
                                WithHint("Check available versions with 'gpd publish status --track " + track + "'")
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        }

        <span class="cov0" title="0">result := findPreviousRelease(trackInfo)
        if result == nil </span><span class="cov0" title="0">{
                return nil, errors.NewAPIError(errors.CodeValidationError,
                        "no previous release found to rollback to").
                        WithHint("Specify a version code with --version-code flag")
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// updateTrackWithRollback updates the track with the rollback release.
func (c *CLI) updateTrackWithRollback(ctx context.Context, publisher *androidpublisher.Service, editID, track string, trackInfo *androidpublisher.Track, versionCodes []int64) *errors.APIError <span class="cov0" title="0">{
        newRelease := &amp;androidpublisher.TrackRelease{
                VersionCodes: versionCodes,
                Status:       statusCompleted,
        }
        trackInfo.Releases = []*androidpublisher.TrackRelease{newRelease}

        _, err := publisher.Edits.Tracks.Update(c.packageName, editID, track, trackInfo).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to update track: %v", err))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *CLI) publishStatus(ctx context.Context, track string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("androidpublisher")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("androidpublisher")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeGeneralError, err.Error())).
                        WithServices("androidpublisher")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">edit, err := publisher.Edits.Insert(c.packageName, nil).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeGeneralError, err.Error())).
                        WithServices("androidpublisher")
                return c.Output(result)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = publisher.Edits.Delete(c.packageName, edit.Id).Context(ctx).Do() }</span>()

        <span class="cov0" title="0">if track != "" </span><span class="cov0" title="0">{
                trackInfo, err := publisher.Edits.Tracks.Get(c.packageName, edit.Id, track).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        result := output.NewErrorResult(errors.NewAPIError(errors.CodeNotFound,
                                fmt.Sprintf("track not found: %s", track))).WithServices("androidpublisher")
                        return c.Output(result)
                }</span>
                <span class="cov0" title="0">result := output.NewResult(trackInfo)
                return c.Output(result.WithServices("androidpublisher"))</span>
        }

        <span class="cov0" title="0">tracks, err := publisher.Edits.Tracks.List(c.packageName, edit.Id).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeGeneralError, err.Error())).
                        WithServices("androidpublisher")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">result := output.NewResult(tracks.Tracks)
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) publishTracks(ctx context.Context) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("androidpublisher")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">return c.publishStatus(ctx, "")</span>
}

func (c *CLI) publishCapabilities(_ context.Context) error <span class="cov0" title="0">{
        result := output.NewResult(map[string]interface{}{
                "supportedTracks": config.ValidTracks(),
                "supportedStatuses": []string{
                        string(api.StatusDraft),
                        string(api.StatusCompleted),
                        string(api.StatusHalted),
                        string(api.StatusInProgress),
                },
                "supportedArtifacts": []string{"aab", "apk"},
                "rolloutRange": map[string]interface{}{
                        "min": 0.01,
                        "max": 100.0,
                },
                "maxInternalTesters": 200,
        })
        return c.Output(result.WithServices("androidpublisher"))
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package cli

import (
        "context"
        "fmt"
        "sync"

        "golang.org/x/sync/errgroup"
        "google.golang.org/api/androidpublisher/v3"
        "google.golang.org/api/googleapi"

        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

func (c *CLI) publishTestersAdd(ctx context.Context, track string, groups []string, editID string, noAutoCommit, dryRun bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("androidpublisher")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">if len(groups) == 0 </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                        "at least one group email is required").WithHint("Use --group to specify tester group emails")).
                        WithServices("androidpublisher")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                result := output.NewResult(map[string]interface{}{
                        "dryRun":  true,
                        "action":  "add_testers",
                        "track":   track,
                        "groups":  groups,
                        "package": c.packageName,
                })
                return c.Output(result.WithServices("androidpublisher"))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr, edit, created, err := c.prepareEdit(ctx, publisher, editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = editMgr.ReleaseLock(c.packageName) }</span>()

        <span class="cov0" title="0">testers, err := publisher.Edits.Testers.Get(c.packageName, edit.ServerID, track).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                testers = &amp;androidpublisher.Testers{}
        }</span>

        <span class="cov0" title="0">existingGroups := make(map[string]bool)
        for _, g := range testers.GoogleGroups </span><span class="cov0" title="0">{
                existingGroups[g] = true
        }</span>
        <span class="cov0" title="0">for _, g := range groups </span><span class="cov0" title="0">{
                if !existingGroups[g] </span><span class="cov0" title="0">{
                        testers.GoogleGroups = append(testers.GoogleGroups, g)
                }</span>
        }

        <span class="cov0" title="0">_, err = publisher.Edits.Testers.Update(c.packageName, edit.ServerID, track, testers).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        _ = publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do()
                }</span>
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to update testers: %v", err)))</span>
        }

        <span class="cov0" title="0">if err := c.finalizeEdit(ctx, publisher, editMgr, edit, !noAutoCommit); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":     true,
                "track":       track,
                "groupsAdded": groups,
                "totalGroups": testers.GoogleGroups,
                "package":     c.packageName,
                "editId":      edit.ServerID,
                "committed":   !noAutoCommit,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) publishTestersRemove(ctx context.Context, track string, groups []string, editID string, noAutoCommit, dryRun bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("androidpublisher")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">if len(groups) == 0 </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                        "at least one group email is required").WithHint("Use --group to specify tester group emails")).
                        WithServices("androidpublisher")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                result := output.NewResult(map[string]interface{}{
                        "dryRun":  true,
                        "action":  "remove_testers",
                        "track":   track,
                        "groups":  groups,
                        "package": c.packageName,
                })
                return c.Output(result.WithServices("androidpublisher"))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr, edit, created, err := c.prepareEdit(ctx, publisher, editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = editMgr.ReleaseLock(c.packageName) }</span>()

        <span class="cov0" title="0">testers, err := publisher.Edits.Testers.Get(c.packageName, edit.ServerID, track).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        _ = publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do()
                }</span>
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeNotFound,
                        fmt.Sprintf("no testers found for track: %s", track)))</span>
        }

        <span class="cov0" title="0">removeSet := make(map[string]bool)
        for _, g := range groups </span><span class="cov0" title="0">{
                removeSet[g] = true
        }</span>
        <span class="cov0" title="0">var remaining []string
        for _, g := range testers.GoogleGroups </span><span class="cov0" title="0">{
                if !removeSet[g] </span><span class="cov0" title="0">{
                        remaining = append(remaining, g)
                }</span>
        }
        <span class="cov0" title="0">testers.GoogleGroups = remaining

        _, err = publisher.Edits.Testers.Update(c.packageName, edit.ServerID, track, testers).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        _ = publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do()
                }</span>
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to update testers: %v", err)))</span>
        }

        <span class="cov0" title="0">if err := c.finalizeEdit(ctx, publisher, editMgr, edit, !noAutoCommit); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":         true,
                "track":           track,
                "groupsRemoved":   groups,
                "remainingGroups": remaining,
                "package":         c.packageName,
                "editId":          edit.ServerID,
                "committed":       !noAutoCommit,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) publishTestersList(ctx context.Context, track string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">edit, err := publisher.Edits.Insert(c.packageName, nil).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to create edit: %v", err)))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = publisher.Edits.Delete(c.packageName, edit.Id).Context(ctx).Do() }</span>()

        <span class="cov0" title="0">if track != "" </span><span class="cov0" title="0">{
                testers, err := publisher.Edits.Testers.Get(c.packageName, edit.Id, track).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeNotFound,
                                fmt.Sprintf("no testers found for track: %s", track)))
                }</span>
                <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                        "track":        track,
                        "googleGroups": testers.GoogleGroups,
                        "package":      c.packageName,
                })
                return c.Output(result.WithServices("androidpublisher"))</span>
        }

        <span class="cov0" title="0">tracks := []string{"internal", "alpha", "beta"}
        testersData := make(map[string]interface{})
        var mu sync.Mutex

        g, gctx := errgroup.WithContext(ctx)
        for _, t := range tracks </span><span class="cov0" title="0">{
                g.Go(func() error </span><span class="cov0" title="0">{
                        if err := client.Acquire(gctx); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer client.Release()

                        testers, err := publisher.Edits.Testers.Get(c.packageName, edit.Id, t).Context(gctx).Do()
                        if err != nil </span><span class="cov0" title="0">{
                                if apiErr, ok := err.(*googleapi.Error); ok &amp;&amp; apiErr.Code == 404 </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                                <span class="cov0" title="0">return err</span>
                        }
                        <span class="cov0" title="0">if len(testers.GoogleGroups) &gt; 0 </span><span class="cov0" title="0">{
                                mu.Lock()
                                testersData[t] = map[string]interface{}{
                                        "googleGroups": testers.GoogleGroups,
                                }
                                mu.Unlock()
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
        }

        <span class="cov0" title="0">if err := g.Wait(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "testers": testersData,
                "package": c.packageName,
        })
        result.WithWarnings("Production track does not support testers; use internal/alpha/beta.")
        return c.Output(result.WithServices("androidpublisher"))</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package cli

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "google.golang.org/api/androidpublisher/v3"

        "github.com/dl-alexandre/gpd/internal/edits"
        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/logging"
        "github.com/dl-alexandre/gpd/internal/output"
)

const (
        extAPK = ".apk"
        extAAB = ".aab"
)

type uploadContext struct {
        filePath       string
        info           os.FileInfo
        ext            string
        hash           string
        idempotencyKey string
}

func (c *CLI) validateUploadFile(filePath string) (*uploadContext, error) <span class="cov0" title="0">{
        info, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewAPIError(errors.CodeValidationError,
                        fmt.Sprintf("file not found: %s", filePath))
        }</span>

        <span class="cov0" title="0">ext := strings.ToLower(filepath.Ext(filePath))
        if ext != extAAB &amp;&amp; ext != extAPK </span><span class="cov0" title="0">{
                return nil, errors.NewAPIError(errors.CodeValidationError,
                        "file must be an AAB or APK").WithHint("Supported formats: .aab, .apk")
        }</span>

        <span class="cov0" title="0">hash, err := edits.HashFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to compute file hash: %v", err))
        }</span>

        <span class="cov0" title="0">return &amp;uploadContext{
                filePath: filePath,
                info:     info,
                ext:      ext,
                hash:     hash,
        }, nil</span>
}

func (c *CLI) checkIdempotentUpload(uc *uploadContext, editMgr *edits.Manager) *output.Result <span class="cov0" title="0">{
        idempotencyResult, idempotencyKey, err := editMgr.Idempotent.CheckUploadByHash(c.packageName, uc.hash)
        uc.idempotencyKey = idempotencyKey
        if err != nil </span><span class="cov0" title="0">{
                logging.Warn("failed to check idempotent upload", logging.String("package", c.packageName), logging.Err(err))
                return nil
        }</span>

        <span class="cov0" title="0">if idempotencyResult == nil || !idempotencyResult.Found </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">data, ok := idempotencyResult.Data.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return output.NewResult(map[string]interface{}{
                "idempotent":  true,
                "versionCode": data["versionCode"],
                "sha256":      data["sha256"],
                "path":        uc.filePath,
                "size":        uc.info.Size(),
                "sizeHuman":   edits.FormatBytes(uc.info.Size()),
                "type":        uc.ext[1:],
                "package":     c.packageName,
                "editId":      data["editId"],
                "recordedAt":  idempotencyResult.Timestamp,
        }).WithNoOp("upload already completed").WithServices("androidpublisher")</span>
}

func (c *CLI) checkCachedUpload(uc *uploadContext, editMgr *edits.Manager) *output.Result <span class="cov0" title="0">{
        cached, err := editMgr.GetCachedArtifactByHash(c.packageName, uc.hash)
        if err != nil || cached == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return output.NewResult(map[string]interface{}{
                "cached":    true,
                "sha256":    cached.SHA256,
                "path":      uc.filePath,
                "size":      uc.info.Size(),
                "sizeHuman": edits.FormatBytes(uc.info.Size()),
        }).WithNoOp("artifact already uploaded").WithServices("androidpublisher")</span>
}

func (c *CLI) uploadArtifact(ctx context.Context, publisher *androidpublisher.Service, editID string, uc *uploadContext) (int64, error) <span class="cov0" title="0">{
        f, err := os.Open(uc.filePath)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.NewAPIError(errors.CodeGeneralError, err.Error())
        }</span>

        <span class="cov0" title="0">if uc.ext == extAAB </span><span class="cov0" title="0">{
                bundle, uploadErr := publisher.Edits.Bundles.Upload(c.packageName, editID).Media(f).Context(ctx).Do()
                closeErr := f.Close()
                if uploadErr != nil </span><span class="cov0" title="0">{
                        if closeErr != nil </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("failed to upload bundle: %v; close error: %v", uploadErr, closeErr)
                        }</span>
                        <span class="cov0" title="0">return 0, fmt.Errorf("failed to upload bundle: %w", uploadErr)</span>
                }
                <span class="cov0" title="0">if closeErr != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("failed to close artifact: %w", closeErr)
                }</span>
                <span class="cov0" title="0">return bundle.VersionCode, nil</span>
        }

        <span class="cov0" title="0">apk, uploadErr := publisher.Edits.Apks.Upload(c.packageName, editID).Media(f).Context(ctx).Do()
        closeErr := f.Close()
        if uploadErr != nil </span><span class="cov0" title="0">{
                if closeErr != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("failed to upload APK: %v; close error: %v", uploadErr, closeErr)
                }</span>
                <span class="cov0" title="0">return 0, fmt.Errorf("failed to upload APK: %w", uploadErr)</span>
        }
        <span class="cov0" title="0">if closeErr != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to close artifact: %w", closeErr)
        }</span>
        <span class="cov0" title="0">return apk.VersionCode, nil</span>
}

func (c *CLI) publishUpload(ctx context.Context, filePath string, obbOpts obbOptions, editID string, noAutoCommit, dryRun bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">uc, err := c.validateUploadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">if apiErr := validateObbOptions(uc.ext, obbOpts); apiErr != nil </span><span class="cov0" title="0">{
                return c.OutputError(apiErr)
        }</span>

        <span class="cov0" title="0">var obbMainInfo os.FileInfo
        var obbPatchInfo os.FileInfo
        if obbOpts.mainPath != "" </span><span class="cov0" title="0">{
                info, apiErr := validateObbFile(obbOpts.mainPath)
                if apiErr != nil </span><span class="cov0" title="0">{
                        return c.OutputError(apiErr)
                }</span>
                <span class="cov0" title="0">obbMainInfo = info</span>
        }
        <span class="cov0" title="0">if obbOpts.patchPath != "" </span><span class="cov0" title="0">{
                info, apiErr := validateObbFile(obbOpts.patchPath)
                if apiErr != nil </span><span class="cov0" title="0">{
                        return c.OutputError(apiErr)
                }</span>
                <span class="cov0" title="0">obbPatchInfo = info</span>
        }

        <span class="cov0" title="0">editMgr := edits.NewManager()
        hasObb := hasObbOptions(obbOpts)

        if result := c.checkIdempotentUpload(uc, editMgr); result != nil </span><span class="cov0" title="0">{
                if !hasObb </span><span class="cov0" title="0">{
                        return c.Output(result)
                }</span>
        }

        <span class="cov0" title="0">if result := c.checkCachedUpload(uc, editMgr); result != nil </span><span class="cov0" title="0">{
                if !hasObb </span><span class="cov0" title="0">{
                        return c.Output(result)
                }</span>
        }

        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                resultData := c.buildUploadDryRunResult(filePath, uc, obbMainInfo, obbPatchInfo, obbOpts)
                result := output.NewResult(resultData)
                return c.Output(result.WithServices("androidpublisher"))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">editMgr, edit, created, err := c.prepareEdit(ctx, publisher, editID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := editMgr.ReleaseLock(c.packageName); err != nil </span><span class="cov0" title="0">{
                        logging.Warn("failed to release edit lock", logging.String("package", c.packageName), logging.Err(err))
                }</span>
        }()

        <span class="cov0" title="0">versionCode, err := c.uploadArtifact(ctx, publisher, edit.ServerID, uc)
        if err != nil </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        if cleanupErr := publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do(); cleanupErr != nil </span><span class="cov0" title="0">{
                                logging.Warn("failed to delete edit", logging.String("package", c.packageName), logging.String("editId", edit.ServerID), logging.Err(cleanupErr))
                        }</span>
                }
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))</span>
        }

        <span class="cov0" title="0">obbResults, apiErr := c.uploadObbFiles(ctx, publisher, edit.ServerID, versionCode, obbOpts)
        if apiErr != nil </span><span class="cov0" title="0">{
                if created </span><span class="cov0" title="0">{
                        if cleanupErr := publisher.Edits.Delete(c.packageName, edit.ServerID).Context(ctx).Do(); cleanupErr != nil </span><span class="cov0" title="0">{
                                logging.Warn("failed to delete edit", logging.String("package", c.packageName), logging.String("editId", edit.ServerID), logging.Err(cleanupErr))
                        }</span>
                }
                <span class="cov0" title="0">return c.OutputError(apiErr)</span>
        }

        <span class="cov0" title="0">if err := c.finalizeEdit(ctx, publisher, editMgr, edit, !noAutoCommit); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">if err := editMgr.CacheArtifactWithHash(c.packageName, filePath, uc.hash, versionCode); err != nil </span><span class="cov0" title="0">{
                logging.Warn("failed to cache artifact", logging.String("package", c.packageName), logging.String("path", filePath), logging.Err(err))
        }</span>

        <span class="cov0" title="0">uploadResult := &amp;edits.UploadResult{
                VersionCode: versionCode,
                SHA256:      uc.hash,
                Path:        filePath,
                Size:        uc.info.Size(),
                Type:        uc.ext[1:],
                EditID:      edit.ServerID,
        }
        if err := editMgr.Idempotent.RecordUpload(uc.idempotencyKey, c.packageName, uc.hash, uploadResult); err != nil </span><span class="cov0" title="0">{
                logging.Warn("failed to record idempotent upload", logging.String("package", c.packageName), logging.String("editId", edit.ServerID), logging.Err(err))
        }</span>

        <span class="cov0" title="0">resultData := map[string]interface{}{
                "success":     true,
                "versionCode": versionCode,
                "sha256":      uc.hash,
                "path":        filePath,
                "size":        uc.info.Size(),
                "sizeHuman":   edits.FormatBytes(uc.info.Size()),
                "type":        uc.ext[1:],
                "package":     c.packageName,
                "editId":      edit.ServerID,
                "committed":   !noAutoCommit,
        }
        if len(obbResults) &gt; 0 </span><span class="cov0" title="0">{
                resultData["expansionFiles"] = obbResults
        }</span>
        <span class="cov0" title="0">result := output.NewResult(resultData)
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) buildUploadDryRunResult(filePath string, uc *uploadContext, obbMainInfo, obbPatchInfo os.FileInfo, obbOpts obbOptions) map[string]interface{} <span class="cov0" title="0">{
        resultData := map[string]interface{}{
                "dryRun":    true,
                "action":    "upload",
                "path":      filePath,
                "sha256":    uc.hash,
                "size":      uc.info.Size(),
                "sizeHuman": edits.FormatBytes(uc.info.Size()),
                "type":      uc.ext[1:],
                "package":   c.packageName,
        }
        obbData := map[string]interface{}{}
        if obbMainInfo != nil </span><span class="cov0" title="0">{
                obbData["main"] = map[string]interface{}{
                        "path":      obbOpts.mainPath,
                        "size":      obbMainInfo.Size(),
                        "sizeHuman": edits.FormatBytes(obbMainInfo.Size()),
                }
        }</span> else<span class="cov0" title="0"> if obbOpts.mainReferenceVersion &gt; 0 </span><span class="cov0" title="0">{
                obbData["main"] = map[string]interface{}{
                        "referencesVersion": obbOpts.mainReferenceVersion,
                }
        }</span>
        <span class="cov0" title="0">if obbPatchInfo != nil </span><span class="cov0" title="0">{
                obbData["patch"] = map[string]interface{}{
                        "path":      obbOpts.patchPath,
                        "size":      obbPatchInfo.Size(),
                        "sizeHuman": edits.FormatBytes(obbPatchInfo.Size()),
                }
        }</span> else<span class="cov0" title="0"> if obbOpts.patchReferenceVersion &gt; 0 </span><span class="cov0" title="0">{
                obbData["patch"] = map[string]interface{}{
                        "referencesVersion": obbOpts.patchReferenceVersion,
                }
        }</span>
        <span class="cov0" title="0">if len(obbData) &gt; 0 </span><span class="cov0" title="0">{
                resultData["expansionFiles"] = obbData
        }</span>
        <span class="cov0" title="0">return resultData</span>
}

func hasObbOptions(opts obbOptions) bool <span class="cov0" title="0">{
        return opts.mainPath != "" || opts.patchPath != "" || opts.mainReferenceVersion &gt; 0 || opts.patchReferenceVersion &gt; 0
}</span>

func (c *CLI) publishInternalShareUpload(ctx context.Context, filePath string, dryRun bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("androidpublisher")
                return c.Output(result)
        }</span>
        <span class="cov0" title="0">info, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                        fmt.Sprintf("file not found: %s", filePath))).WithServices("androidpublisher")
                return c.Output(result)
        }</span>
        <span class="cov0" title="0">ext := strings.ToLower(filepath.Ext(filePath))
        if ext != extAPK &amp;&amp; ext != extAAB </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                        "file must be an APK or AAB").WithHint("Supported formats: .apk, .aab")).WithServices("androidpublisher")
                return c.Output(result)
        }</span>
        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                result := output.NewResult(map[string]interface{}{
                        "dryRun":    true,
                        "action":    "internal_share_upload",
                        "path":      filePath,
                        "size":      info.Size(),
                        "sizeHuman": edits.FormatBytes(info.Size()),
                        "type":      ext[1:],
                        "package":   c.packageName,
                })
                return c.Output(result.WithServices("androidpublisher"))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">f, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">var resp *androidpublisher.InternalAppSharingArtifact
        if ext == extAPK </span><span class="cov0" title="0">{
                resp, err = publisher.Internalappsharingartifacts.Uploadapk(c.packageName).Media(f).Context(ctx).Do()
        }</span> else<span class="cov0" title="0"> {
                resp, err = publisher.Internalappsharingartifacts.Uploadbundle(c.packageName).Media(f).Context(ctx).Do()
        }</span>
        <span class="cov0" title="0">closeErr := f.Close()
        if err != nil </span><span class="cov0" title="0">{
                if closeErr != nil </span><span class="cov0" title="0">{
                        logging.Warn("failed to close artifact", logging.String("path", filePath), logging.Err(closeErr))
                }</span>
                <span class="cov0" title="0">return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))</span>
        }
        <span class="cov0" title="0">if closeErr != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, closeErr.Error()))
        }</span>
        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":  true,
                "artifact": resp,
                "package":  c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Package cli provides purchases commands for gpd.
package cli

import (
        "context"
        "fmt"
        "strconv"
        "time"

        "github.com/spf13/cobra"
        "google.golang.org/api/androidpublisher/v3"

        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

// Purchase type constants
const (
        purchaseTypeProduct      = "product"
        purchaseTypeSubscription = "subscription"
        purchaseTypeAuto         = "auto"
)

func (c *CLI) addPurchasesCommands() <span class="cov10" title="18">{
        purchasesCmd := &amp;cobra.Command{
                Use:   "purchases",
                Short: "Purchase verification commands",
                Long:  "Verify purchase tokens and subscription states.",
        }

        c.addPurchasesVerifyCommands(purchasesCmd)
        c.addPurchasesVoidedCommands(purchasesCmd)
        c.addPurchasesProductsCommands(purchasesCmd)
        c.addPurchasesSubscriptionsCommands(purchasesCmd)

        c.rootCmd.AddCommand(purchasesCmd)
}</span>

func (c *CLI) addPurchasesVerifyCommands(purchasesCmd *cobra.Command) <span class="cov10" title="18">{
        var (
                productID   string
                token       string
                environment string
                productType string
        )

        verifyCmd := &amp;cobra.Command{
                Use:   "verify",
                Short: "Verify a purchase token",
                Long:  "Verify a purchase or subscription token.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if token == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--token is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.purchasesVerify(cmd.Context(), productID, token, environment, productType)</span>
                },
        }
        <span class="cov10" title="18">verifyCmd.Flags().StringVar(&amp;productID, "product-id", "", "Product ID")
        verifyCmd.Flags().StringVar(&amp;token, "token", "", "Purchase token")
        verifyCmd.Flags().StringVar(&amp;environment, "environment", purchaseTypeAuto, "Environment: sandbox, production, auto")
        verifyCmd.Flags().StringVar(&amp;productType, "type", purchaseTypeAuto, "Product type: product, subscription, auto")

        capabilitiesCmd := &amp;cobra.Command{
                Use:   "capabilities",
                Short: "List purchase verification capabilities",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.purchasesCapabilities(cmd.Context())
                }</span>,
        }

        <span class="cov10" title="18">purchasesCmd.AddCommand(verifyCmd, capabilitiesCmd)</span>
}

func (c *CLI) addPurchasesVoidedCommands(purchasesCmd *cobra.Command) <span class="cov10" title="18">{
        var (
                startTime  string
                endTime    string
                kind       string
                maxResults int64
                pageToken  string
                all        bool
        )

        voidedCmd := &amp;cobra.Command{
                Use:   "voided",
                Short: "Voided purchases",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.purchasesVoidedList(cmd.Context(), startTime, endTime, kind, maxResults, pageToken, all)
                }</span>,
        }

        <span class="cov10" title="18">voidedCmd.PersistentFlags().StringVar(&amp;startTime, "start-time", "", "Start time (RFC3339 or millis)")
        voidedCmd.PersistentFlags().StringVar(&amp;endTime, "end-time", "", "End time (RFC3339 or millis)")
        voidedCmd.PersistentFlags().StringVar(&amp;kind, "type", "", "Type: product or subscription")
        voidedCmd.PersistentFlags().Int64Var(&amp;maxResults, "max-results", 0, "Max results per page")
        voidedCmd.PersistentFlags().Int64Var(&amp;maxResults, "page-size", 0, "Alias for --max-results")
        _ = voidedCmd.PersistentFlags().MarkDeprecated("page-size", "use --max-results instead")
        voidedCmd.PersistentFlags().StringVar(&amp;pageToken, "page-token", "", "Pagination token")
        addPaginationFlags(voidedCmd, &amp;all)

        voidedListCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List voided purchases",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.purchasesVoidedList(cmd.Context(), startTime, endTime, kind, maxResults, pageToken, all)
                }</span>,
        }

        <span class="cov10" title="18">voidedCmd.AddCommand(voidedListCmd)
        purchasesCmd.AddCommand(voidedCmd)</span>
}

func (c *CLI) addPurchasesProductsCommands(purchasesCmd *cobra.Command) <span class="cov10" title="18">{
        productsCmd := &amp;cobra.Command{
                Use:   "products",
                Short: "Product purchase actions",
        }

        var (
                productID        string
                token            string
                developerPayload string
        )

        productsAcknowledgeCmd := &amp;cobra.Command{
                Use:   "acknowledge",
                Short: "Acknowledge a product purchase",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if productID == "" || token == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--product-id and --token are required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.purchasesProductsAcknowledge(cmd.Context(), productID, token, developerPayload)</span>
                },
        }
        <span class="cov10" title="18">productsAcknowledgeCmd.Flags().StringVar(&amp;productID, "product-id", "", "Product ID")
        productsAcknowledgeCmd.Flags().StringVar(&amp;token, "token", "", "Purchase token")
        productsAcknowledgeCmd.Flags().StringVar(&amp;developerPayload, "developer-payload", "", "Developer payload")

        productsConsumeCmd := &amp;cobra.Command{
                Use:   "consume",
                Short: "Consume a product purchase",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if productID == "" || token == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--product-id and --token are required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.purchasesProductsConsume(cmd.Context(), productID, token)</span>
                },
        }
        <span class="cov10" title="18">productsConsumeCmd.Flags().StringVar(&amp;productID, "product-id", "", "Product ID")
        productsConsumeCmd.Flags().StringVar(&amp;token, "token", "", "Purchase token")

        productsCmd.AddCommand(productsAcknowledgeCmd, productsConsumeCmd)
        purchasesCmd.AddCommand(productsCmd)</span>
}

func (c *CLI) addPurchasesSubscriptionsCommands(purchasesCmd *cobra.Command) <span class="cov10" title="18">{
        subscriptionsCmd := &amp;cobra.Command{
                Use:   "subscriptions",
                Short: "Subscription purchase actions",
        }

        var (
                subscriptionID   string
                token            string
                developerPayload string
                expectedExpiry   string
                desiredExpiry    string
                revokeType       string
        )

        subscriptionsAcknowledgeCmd := &amp;cobra.Command{
                Use:   "acknowledge",
                Short: "Acknowledge a subscription purchase",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if subscriptionID == "" || token == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--subscription-id and --token are required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.purchasesSubscriptionsAcknowledge(cmd.Context(), subscriptionID, token, developerPayload)</span>
                },
        }
        <span class="cov10" title="18">subscriptionsAcknowledgeCmd.Flags().StringVar(&amp;subscriptionID, "subscription-id", "", "Subscription ID")
        subscriptionsAcknowledgeCmd.Flags().StringVar(&amp;token, "token", "", "Purchase token")
        subscriptionsAcknowledgeCmd.Flags().StringVar(&amp;developerPayload, "developer-payload", "", "Developer payload")

        subscriptionsCancelCmd := &amp;cobra.Command{
                Use:   "cancel",
                Short: "Cancel a subscription",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if subscriptionID == "" || token == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--subscription-id and --token are required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.purchasesSubscriptionsCancel(cmd.Context(), subscriptionID, token)</span>
                },
        }
        <span class="cov10" title="18">subscriptionsCancelCmd.Flags().StringVar(&amp;subscriptionID, "subscription-id", "", "Subscription ID")
        subscriptionsCancelCmd.Flags().StringVar(&amp;token, "token", "", "Purchase token")

        subscriptionsDeferCmd := &amp;cobra.Command{
                Use:   "defer",
                Short: "Defer a subscription renewal",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if subscriptionID == "" || token == "" || expectedExpiry == "" || desiredExpiry == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--subscription-id, --token, --expected-expiry-time, and --desired-expiry-time are required")).
                                        WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.purchasesSubscriptionsDefer(cmd.Context(), subscriptionID, token, expectedExpiry, desiredExpiry)</span>
                },
        }
        <span class="cov10" title="18">subscriptionsDeferCmd.Flags().StringVar(&amp;subscriptionID, "subscription-id", "", "Subscription ID")
        subscriptionsDeferCmd.Flags().StringVar(&amp;token, "token", "", "Purchase token")
        subscriptionsDeferCmd.Flags().StringVar(&amp;expectedExpiry, "expected-expiry-time", "", "Expected expiry time (RFC3339 or millis)")
        subscriptionsDeferCmd.Flags().StringVar(&amp;desiredExpiry, "desired-expiry-time", "", "Desired expiry time (RFC3339 or millis)")

        subscriptionsRefundCmd := &amp;cobra.Command{
                Use:   "refund",
                Short: "Refund a subscription (v1)",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if subscriptionID == "" || token == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--subscription-id and --token are required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.purchasesSubscriptionsRefund(cmd.Context(), subscriptionID, token)</span>
                },
        }
        <span class="cov10" title="18">subscriptionsRefundCmd.Flags().StringVar(&amp;subscriptionID, "subscription-id", "", "Subscription ID")
        subscriptionsRefundCmd.Flags().StringVar(&amp;token, "token", "", "Purchase token")

        subscriptionsRevokeCmd := &amp;cobra.Command{
                Use:   "revoke",
                Short: "Revoke a subscription",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if token == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--token is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.purchasesSubscriptionsRevoke(cmd.Context(), subscriptionID, token, revokeType)</span>
                },
        }
        <span class="cov10" title="18">subscriptionsRevokeCmd.Flags().StringVar(&amp;subscriptionID, "subscription-id", "", "Subscription ID (v1)")
        subscriptionsRevokeCmd.Flags().StringVar(&amp;token, "token", "", "Purchase token")
        subscriptionsRevokeCmd.Flags().StringVar(&amp;revokeType, "revoke-type", "", "Revoke type for v2: fullRefund, partialRefund, itemBasedRefund")

        subscriptionsCmd.AddCommand(subscriptionsAcknowledgeCmd, subscriptionsCancelCmd, subscriptionsDeferCmd, subscriptionsRefundCmd, subscriptionsRevokeCmd)
        purchasesCmd.AddCommand(subscriptionsCmd)</span>
}

func (c *CLI) purchasesVerify(ctx context.Context, productID, token, environment, productType string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("androidpublisher")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">if token == "" </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError, "purchase token is required")).
                        WithServices("androidpublisher")
                return c.Output(result)
        }</span>

        // Get API client
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if apiErr, ok := err.(*errors.APIError); ok </span><span class="cov0" title="0">{
                        result := output.NewErrorResult(apiErr).WithServices("androidpublisher")
                        return c.Output(result)
                }</span>
                <span class="cov0" title="0">result := output.NewErrorResult(errors.NewAPIError(errors.CodeGeneralError, err.Error())).
                        WithServices("androidpublisher")
                return c.Output(result)</span>
        }

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeGeneralError, err.Error())).
                        WithServices("androidpublisher")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">var purchaseData interface{}
        var purchaseType string

        // Determine product type
        if productType == purchaseTypeAuto || productType == purchaseTypeProduct </span><span class="cov0" title="0">{
                // Try product purchase first
                if productID != "" </span><span class="cov0" title="0">{
                        productPurchase, err := publisher.Purchases.Products.Get(c.packageName, productID, token).Context(ctx).Do()
                        if err == nil </span><span class="cov0" title="0">{
                                purchaseData = map[string]interface{}{
                                        "kind":                        productPurchase.Kind,
                                        "purchaseTimeMillis":          productPurchase.PurchaseTimeMillis,
                                        "purchaseState":               productPurchase.PurchaseState,
                                        "consumptionState":            productPurchase.ConsumptionState,
                                        "developerPayload":            productPurchase.DeveloperPayload,
                                        "orderId":                     productPurchase.OrderId,
                                        "purchaseType":                productPurchase.PurchaseType,
                                        "acknowledgementState":        productPurchase.AcknowledgementState,
                                        "quantity":                    productPurchase.Quantity,
                                        "obfuscatedExternalAccountId": productPurchase.ObfuscatedExternalAccountId,
                                        "obfuscatedExternalProfileId": productPurchase.ObfuscatedExternalProfileId,
                                }
                                purchaseType = purchaseTypeProduct
                        }</span>
                }
        }

        // Try subscription if product failed or type is subscription
        <span class="cov0" title="0">if purchaseData == nil &amp;&amp; (productType == purchaseTypeAuto || productType == purchaseTypeSubscription) </span><span class="cov0" title="0">{
                if productID != "" </span><span class="cov0" title="0">{
                        // Use subscriptions v2 API
                        subPurchase, err := publisher.Purchases.Subscriptionsv2.Get(c.packageName, token).Context(ctx).Do()
                        if err == nil </span><span class="cov0" title="0">{
                                purchaseData = map[string]interface{}{
                                        "kind":                       subPurchase.Kind,
                                        "subscriptionState":          subPurchase.SubscriptionState,
                                        "acknowledgementState":       subPurchase.AcknowledgementState,
                                        "externalAccountIdentifiers": subPurchase.ExternalAccountIdentifiers,
                                        "linkedPurchaseToken":        subPurchase.LinkedPurchaseToken,
                                        "latestOrderId":              subPurchase.LatestOrderId,
                                }
                                purchaseType = purchaseTypeSubscription
                        }</span> else<span class="cov0" title="0"> if productType == purchaseTypeSubscription </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeNotFound,
                                        fmt.Sprintf("subscription not found: %v", err))).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                }
        }

        <span class="cov0" title="0">if purchaseData == nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeNotFound,
                        "purchase not found").WithHint("Check that the token and product ID are correct"))
                return c.Output(result.WithServices("androidpublisher"))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "valid":       true,
                "type":        purchaseType,
                "environment": environment,
                "productId":   productID,
                "purchase":    purchaseData,
                "package":     c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) purchasesCapabilities(_ context.Context) error <span class="cov0" title="0">{
        result := output.NewResult(map[string]interface{}{
                "supportedProductTypes": []string{"product", "subscription"},
                "supportedEnvironments": []string{"sandbox", "production", "auto"},
                "apis": map[string]interface{}{
                        "products": map[string]interface{}{
                                "endpoints": []string{"purchases.products.get", "purchases.products.acknowledge", "purchases.products.consume"},
                                "purpose":   "One-time product verification",
                        },
                        "subscriptionsV2": map[string]interface{}{
                                "endpoints":  []string{"purchases.subscriptionsv2.get", "purchases.subscriptionsv2.cancel", "purchases.subscriptionsv2.revoke"},
                                "purpose":    "Subscription state verification (v2 API)",
                                "deprecated": false,
                        },
                        "subscriptions": map[string]interface{}{
                                "endpoints":  []string{"purchases.subscriptions.acknowledge", "purchases.subscriptions.cancel", "purchases.subscriptions.defer", "purchases.subscriptions.refund", "purchases.subscriptions.revoke"},
                                "purpose":    "Legacy subscription actions",
                                "deprecated": true,
                        },
                        "voidedPurchases": map[string]interface{}{
                                "endpoints": []string{"purchases.voidedpurchases.list"},
                                "purpose":   "Voided purchases list",
                        },
                },
                "retryPolicy": map[string]interface{}{
                        "maxRetries":     3,
                        "backoffType":    "exponential",
                        "initialDelayMs": 1000,
                        "maxDelayMs":     30000,
                },
        })
        return c.Output(result.WithServices("androidpublisher"))
}</span>

func (c *CLI) purchasesVoidedList(ctx context.Context, startTime, endTime, kind string, maxResults int64, pageToken string, all bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">req := publisher.Purchases.Voidedpurchases.List(c.packageName)
        if startTime != "" </span><span class="cov0" title="0">{
                ms, err := parseTimeMillis(startTime)
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(err)
                }</span>
                <span class="cov0" title="0">req = req.StartTime(ms)</span>
        }
        <span class="cov0" title="0">if endTime != "" </span><span class="cov0" title="0">{
                ms, err := parseTimeMillis(endTime)
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(err)
                }</span>
                <span class="cov0" title="0">req = req.EndTime(ms)</span>
        }
        <span class="cov0" title="0">if kind != "" </span><span class="cov0" title="0">{
                switch kind </span>{
                case purchaseTypeProduct:<span class="cov0" title="0">
                        req = req.Type(0)</span>
                case purchaseTypeSubscription:<span class="cov0" title="0">
                        req = req.Type(1)</span>
                default:<span class="cov0" title="0">
                        result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                "type must be product or subscription")).WithServices("androidpublisher")
                        return c.Output(result)</span>
                }
        }
        <span class="cov0" title="0">if maxResults &gt; 0 </span><span class="cov0" title="0">{
                req = req.MaxResults(maxResults)
        }</span>
        <span class="cov0" title="0">if pageToken != "" </span><span class="cov0" title="0">{
                req = req.Token(pageToken)
        }</span>

        <span class="cov0" title="0">startToken := pageToken
        nextToken := ""
        allPurchases := make([]*androidpublisher.VoidedPurchase, 0)
        for </span><span class="cov0" title="0">{
                resp, err := req.Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
                }</span>
                <span class="cov0" title="0">allPurchases = append(allPurchases, resp.VoidedPurchases...)
                nextToken = ""
                if resp.TokenPagination != nil </span><span class="cov0" title="0">{
                        nextToken = resp.TokenPagination.NextPageToken
                }</span>
                <span class="cov0" title="0">if nextToken == "" || !all </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">req = req.Token(nextToken)</span>
        }
        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "voidedPurchases": allPurchases,
                "nextPageToken":   nextToken,
                "package":         c.packageName,
        })
        result.WithPagination(startToken, nextToken)
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) purchasesProductsAcknowledge(ctx context.Context, productID, token, developerPayload string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">req := &amp;androidpublisher.ProductPurchasesAcknowledgeRequest{
                DeveloperPayload: developerPayload,
        }
        if err := publisher.Purchases.Products.Acknowledge(c.packageName, productID, token, req).Context(ctx).Do(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":   true,
                "productId": productID,
                "token":     token,
                "package":   c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) purchasesProductsConsume(ctx context.Context, productID, token string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">if err := publisher.Purchases.Products.Consume(c.packageName, productID, token).Context(ctx).Do(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":   true,
                "productId": productID,
                "token":     token,
                "package":   c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) purchasesSubscriptionsAcknowledge(ctx context.Context, subscriptionID, token, developerPayload string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">req := &amp;androidpublisher.SubscriptionPurchasesAcknowledgeRequest{
                DeveloperPayload: developerPayload,
        }
        if err := publisher.Purchases.Subscriptions.Acknowledge(c.packageName, subscriptionID, token, req).Context(ctx).Do(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":        true,
                "subscriptionId": subscriptionID,
                "token":          token,
                "package":        c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) purchasesSubscriptionsCancel(ctx context.Context, subscriptionID, token string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">if err := publisher.Purchases.Subscriptions.Cancel(c.packageName, subscriptionID, token).Context(ctx).Do(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":        true,
                "subscriptionId": subscriptionID,
                "token":          token,
                "package":        c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) purchasesSubscriptionsDefer(ctx context.Context, subscriptionID, token, expected, desired string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">expectedMillis, apiErr := parseTimeMillis(expected)
        if apiErr != nil </span><span class="cov0" title="0">{
                return c.OutputError(apiErr)
        }</span>
        <span class="cov0" title="0">desiredMillis, apiErr := parseTimeMillis(desired)
        if apiErr != nil </span><span class="cov0" title="0">{
                return c.OutputError(apiErr)
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">req := &amp;androidpublisher.SubscriptionPurchasesDeferRequest{
                DeferralInfo: &amp;androidpublisher.SubscriptionDeferralInfo{
                        ExpectedExpiryTimeMillis: expectedMillis,
                        DesiredExpiryTimeMillis:  desiredMillis,
                },
        }
        resp, err := publisher.Purchases.Subscriptions.Defer(c.packageName, subscriptionID, token, req).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">return c.Output(output.NewResult(resp).WithServices("androidpublisher"))</span>
}

func (c *CLI) purchasesSubscriptionsRefund(ctx context.Context, subscriptionID, token string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">if err := publisher.Purchases.Subscriptions.Refund(c.packageName, subscriptionID, token).Context(ctx).Do(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":        true,
                "subscriptionId": subscriptionID,
                "token":          token,
                "package":        c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) purchasesSubscriptionsRevoke(ctx context.Context, subscriptionID, token, revokeType string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">if revokeType != "" </span><span class="cov0" title="0">{
                var revocationContext *androidpublisher.RevocationContext
                switch revokeType </span>{
                case "fullRefund":<span class="cov0" title="0">
                        revocationContext = &amp;androidpublisher.RevocationContext{
                                FullRefund: &amp;androidpublisher.RevocationContextFullRefund{},
                        }</span>
                case "partialRefund", "proratedRefund":<span class="cov0" title="0">
                        revocationContext = &amp;androidpublisher.RevocationContext{
                                ProratedRefund: &amp;androidpublisher.RevocationContextProratedRefund{},
                        }</span>
                default:<span class="cov0" title="0">
                        result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                "invalid revoke-type: must be fullRefund or partialRefund")).WithServices("androidpublisher")
                        return c.Output(result)</span>
                }
                <span class="cov0" title="0">req := &amp;androidpublisher.RevokeSubscriptionPurchaseRequest{
                        RevocationContext: revocationContext,
                }
                if _, err := publisher.Purchases.Subscriptionsv2.Revoke(c.packageName, token, req).Context(ctx).Do(); err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
                }</span>
                <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                        "success":    true,
                        "token":      token,
                        "package":    c.packageName,
                        "api":        "subscriptionsv2",
                        "revokeType": revokeType,
                })
                return c.Output(result.WithServices("androidpublisher"))</span>
        }
        <span class="cov0" title="0">if subscriptionID == "" </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                        "subscription-id is required for v1 revoke")).WithServices("androidpublisher")
                return c.Output(result)
        }</span>
        <span class="cov0" title="0">if err := publisher.Purchases.Subscriptions.Revoke(c.packageName, subscriptionID, token).Context(ctx).Do(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":        true,
                "subscriptionId": subscriptionID,
                "token":          token,
                "package":        c.packageName,
                "api":            "subscriptions",
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func parseTimeMillis(value string) (int64, *errors.APIError) <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return 0, errors.NewAPIError(errors.CodeValidationError, "time value is required")
        }</span>
        <span class="cov0" title="0">if millis, err := strconv.ParseInt(value, 10, 64); err == nil </span><span class="cov0" title="0">{
                return millis, nil
        }</span>
        <span class="cov0" title="0">parsed, err := time.Parse(time.RFC3339, value)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.NewAPIError(errors.CodeValidationError, "time must be RFC3339 or milliseconds")
        }</span>
        <span class="cov0" title="0">return parsed.UnixMilli(), nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package cli

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "strconv"
        "strings"

        "github.com/spf13/cobra"
        "google.golang.org/api/androidpublisher/v3"

        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

func (c *CLI) addRecoveryCommands() <span class="cov10" title="18">{
        recoveryCmd := &amp;cobra.Command{
                Use:   "recovery",
                Short: "App recovery commands",
                Long:  "Create and manage app recovery actions for remote in-app updates.",
        }

        var (
                versionCode      int64
                targetingFile    string
                allUsers         bool
                regions          []string
                androidSdkLevels []int64
                versionCodes     []int64
                versionRangeMin  int64
                versionRangeMax  int64
        )

        createCmd := &amp;cobra.Command{
                Use:   "create",
                Short: "Create a draft recovery action",
                Long:  "Create an app recovery action with DRAFT status. Use deploy to activate.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">if versionCode &lt;= 0 &amp;&amp; targetingFile == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "--version-code or --file is required")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.recoveryCreate(cmd.Context(), versionCode, targetingFile, allUsers, regions, androidSdkLevels, versionCodes, versionRangeMin, versionRangeMax)</span>
                },
        }
        <span class="cov10" title="18">createCmd.Flags().Int64Var(&amp;versionCode, "version-code", 0, "Target app version code")
        createCmd.Flags().StringVar(&amp;targetingFile, "file", "", "JSON file with targeting configuration")
        createCmd.Flags().BoolVar(&amp;allUsers, "all-users", true, "Target all users")
        createCmd.Flags().StringSliceVar(&amp;regions, "regions", nil, "Target regions (comma-separated ISO codes)")
        createCmd.Flags().Int64SliceVar(&amp;androidSdkLevels, "android-sdk-levels", nil, "Target Android SDK levels (comma-separated)")
        createCmd.Flags().Int64SliceVar(&amp;versionCodes, "version-codes", nil, "Target specific version codes")
        createCmd.Flags().Int64Var(&amp;versionRangeMin, "version-range-min", 0, "Minimum version code in range")
        createCmd.Flags().Int64Var(&amp;versionRangeMax, "version-range-max", 0, "Maximum version code in range")

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List recovery actions",
                Long:  "List all app recovery actions for a package.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                                return c.OutputError(err.(*errors.APIError))
                        }</span>
                        <span class="cov0" title="0">return c.recoveryList(cmd.Context(), versionCode)</span>
                },
        }
        <span class="cov10" title="18">listCmd.Flags().Int64Var(&amp;versionCode, "version-code", 0, "Filter by version code")

        deployCmd := &amp;cobra.Command{
                Use:   "deploy [recovery-id]",
                Short: "Deploy a recovery action",
                Long:  "Deploy a draft recovery action to activate it for targeted users.",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                                return c.OutputError(err.(*errors.APIError))
                        }</span>
                        <span class="cov0" title="0">return c.recoveryDeploy(cmd.Context(), args[0])</span>
                },
        }

        <span class="cov10" title="18">cancelCmd := &amp;cobra.Command{
                Use:   "cancel [recovery-id]",
                Short: "Cancel a recovery action",
                Long:  "Cancel an active or draft recovery action.",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                                return c.OutputError(err.(*errors.APIError))
                        }</span>
                        <span class="cov0" title="0">return c.recoveryCancel(cmd.Context(), args[0])</span>
                },
        }

        <span class="cov10" title="18">addTargetingCmd := &amp;cobra.Command{
                Use:   "add-targeting [recovery-id]",
                Short: "Add targeting to a recovery action",
                Long:  "Incrementally update targeting for an existing recovery action.",
                Args:  cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">if targetingFile == "" &amp;&amp; !allUsers &amp;&amp; len(regions) == 0 &amp;&amp; len(androidSdkLevels) == 0 </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                        "at least one targeting option is required: --file, --all-users, --regions, or --android-sdk-levels")).
                                        WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.recoveryAddTargeting(cmd.Context(), args[0], targetingFile, allUsers, regions, androidSdkLevels)</span>
                },
        }
        <span class="cov10" title="18">addTargetingCmd.Flags().StringVar(&amp;targetingFile, "file", "", "JSON file with targeting update configuration")
        addTargetingCmd.Flags().BoolVar(&amp;allUsers, "all-users", false, "Target all users")
        addTargetingCmd.Flags().StringSliceVar(&amp;regions, "regions", nil, "Additional regions to target (comma-separated ISO codes)")
        addTargetingCmd.Flags().Int64SliceVar(&amp;androidSdkLevels, "android-sdk-levels", nil, "Target Android SDK levels (comma-separated)")

        capabilitiesCmd := &amp;cobra.Command{
                Use:   "capabilities",
                Short: "List recovery capabilities",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.recoveryCapabilities(cmd.Context())
                }</span>,
        }

        <span class="cov10" title="18">recoveryCmd.AddCommand(createCmd, listCmd, deployCmd, cancelCmd, addTargetingCmd, capabilitiesCmd)
        c.rootCmd.AddCommand(recoveryCmd)</span>
}

func (c *CLI) recoveryCreate(ctx context.Context, versionCode int64, targetingFile string, allUsers bool, regions []string, androidSdkLevels, versionCodes []int64, versionRangeMin, versionRangeMax int64) error <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">var req androidpublisher.CreateDraftAppRecoveryRequest

        if targetingFile != "" </span><span class="cov0" title="0">{
                data, err := os.ReadFile(targetingFile)
                if err != nil </span><span class="cov0" title="0">{
                        result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                "failed to read file: "+targetingFile)).WithServices("androidpublisher")
                        return c.Output(result)
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(data, &amp;req); err != nil </span><span class="cov0" title="0">{
                        result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                "invalid JSON file")).WithServices("androidpublisher")
                        return c.Output(result)
                }</span>
        } else<span class="cov0" title="0"> {
                req.RemoteInAppUpdate = &amp;androidpublisher.RemoteInAppUpdate{
                        IsRemoteInAppUpdateRequested: true,
                }

                targeting := &amp;androidpublisher.Targeting{}

                if allUsers </span><span class="cov0" title="0">{
                        targeting.AllUsers = &amp;androidpublisher.AllUsers{
                                IsAllUsersRequested: true,
                        }
                }</span>

                <span class="cov0" title="0">if len(regions) &gt; 0 </span><span class="cov0" title="0">{
                        targeting.Regions = &amp;androidpublisher.Regions{
                                RegionCode: regions,
                        }
                }</span>

                <span class="cov0" title="0">if len(androidSdkLevels) &gt; 0 </span><span class="cov0" title="0">{
                        targeting.AndroidSdks = &amp;androidpublisher.AndroidSdks{
                                SdkLevels: androidSdkLevels,
                        }
                }</span>

                <span class="cov0" title="0">if len(versionCodes) &gt; 0 </span><span class="cov0" title="0">{
                        targeting.VersionList = &amp;androidpublisher.AppVersionList{
                                VersionCodes: versionCodes,
                        }
                }</span> else<span class="cov0" title="0"> if versionCode &gt; 0 </span><span class="cov0" title="0">{
                        targeting.VersionList = &amp;androidpublisher.AppVersionList{
                                VersionCodes: []int64{versionCode},
                        }
                }</span>

                <span class="cov0" title="0">if versionRangeMin &gt; 0 || versionRangeMax &gt; 0 </span><span class="cov0" title="0">{
                        targeting.VersionRange = &amp;androidpublisher.AppVersionRange{}
                        if versionRangeMin &gt; 0 </span><span class="cov0" title="0">{
                                targeting.VersionRange.VersionCodeStart = versionRangeMin
                        }</span>
                        <span class="cov0" title="0">if versionRangeMax &gt; 0 </span><span class="cov0" title="0">{
                                targeting.VersionRange.VersionCodeEnd = versionRangeMax
                        }</span>
                }

                <span class="cov0" title="0">req.Targeting = targeting</span>
        }

        <span class="cov0" title="0">action, err := publisher.Apprecovery.Create(c.packageName, &amp;req).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":        true,
                "appRecoveryId":  action.AppRecoveryId,
                "status":         action.Status,
                "createTime":     action.CreateTime,
                "lastUpdateTime": action.LastUpdateTime,
                "targeting":      action.Targeting,
                "package":        c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) recoveryList(ctx context.Context, versionCode int64) error <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">call := publisher.Apprecovery.List(c.packageName)
        if versionCode &gt; 0 </span><span class="cov0" title="0">{
                call = call.VersionCode(versionCode)
        }</span>

        <span class="cov0" title="0">resp, err := call.Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                apiErr := errors.ClassifyAuthError(err)
                if apiErr == nil </span><span class="cov0" title="0">{
                        apiErr = errors.NewAPIError(errors.CodeGeneralError, err.Error())
                }</span>
                <span class="cov0" title="0">if strings.Contains(apiErr.Message, "Version Code must be positive") &amp;&amp; versionCode &lt;= 0 </span><span class="cov0" title="0">{
                        apiErr = apiErr.WithHint("Set --version-code to a positive value to filter recovery actions.")
                }</span>
                <span class="cov0" title="0">result := output.NewErrorResult(apiErr).WithServices("androidpublisher")
                return c.Output(result)</span>
        }

        <span class="cov0" title="0">var actions []interface{}
        for _, action := range resp.RecoveryActions </span><span class="cov0" title="0">{
                actions = append(actions, map[string]interface{}{
                        "appRecoveryId":         action.AppRecoveryId,
                        "status":                action.Status,
                        "createTime":            action.CreateTime,
                        "deployTime":            action.DeployTime,
                        "cancelTime":            action.CancelTime,
                        "lastUpdateTime":        action.LastUpdateTime,
                        "targeting":             action.Targeting,
                        "remoteInAppUpdateData": action.RemoteInAppUpdateData,
                })
        }</span>

        <span class="cov0" title="0">result := output.NewResult(actions)
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) recoveryDeploy(ctx context.Context, recoveryID string) error <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">appRecoveryID, err := parseRecoveryID(recoveryID)
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError, err.Error())).
                        WithServices("androidpublisher")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">_, err = publisher.Apprecovery.Deploy(c.packageName, appRecoveryID, &amp;androidpublisher.DeployAppRecoveryRequest{}).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":       true,
                "appRecoveryId": appRecoveryID,
                "deployed":      true,
                "package":       c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) recoveryCancel(ctx context.Context, recoveryID string) error <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">appRecoveryID, err := parseRecoveryID(recoveryID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError, err.Error()))
        }</span>

        <span class="cov0" title="0">_, err = publisher.Apprecovery.Cancel(c.packageName, appRecoveryID, &amp;androidpublisher.CancelAppRecoveryRequest{}).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":       true,
                "appRecoveryId": appRecoveryID,
                "cancelled":     true,
                "package":       c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) recoveryAddTargeting(ctx context.Context, recoveryID, targetingFile string, allUsers bool, regions []string, androidSdkLevels []int64) error <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">appRecoveryID, err := parseRecoveryID(recoveryID)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeValidationError, err.Error()))
        }</span>

        <span class="cov0" title="0">var req androidpublisher.AddTargetingRequest

        if targetingFile != "" </span><span class="cov0" title="0">{
                data, err := os.ReadFile(targetingFile)
                if err != nil </span><span class="cov0" title="0">{
                        result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                "failed to read file: "+targetingFile)).WithServices("androidpublisher")
                        return c.Output(result)
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(data, &amp;req); err != nil </span><span class="cov0" title="0">{
                        result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                "invalid JSON file")).WithServices("androidpublisher")
                        return c.Output(result)
                }</span>
        } else<span class="cov0" title="0"> {
                targetingUpdate := &amp;androidpublisher.TargetingUpdate{}

                if allUsers </span><span class="cov0" title="0">{
                        targetingUpdate.AllUsers = &amp;androidpublisher.AllUsers{
                                IsAllUsersRequested: true,
                        }
                }</span>

                <span class="cov0" title="0">if len(regions) &gt; 0 </span><span class="cov0" title="0">{
                        targetingUpdate.Regions = &amp;androidpublisher.Regions{
                                RegionCode: regions,
                        }
                }</span>

                <span class="cov0" title="0">if len(androidSdkLevels) &gt; 0 </span><span class="cov0" title="0">{
                        targetingUpdate.AndroidSdks = &amp;androidpublisher.AndroidSdks{
                                SdkLevels: androidSdkLevels,
                        }
                }</span>

                <span class="cov0" title="0">req.TargetingUpdate = targetingUpdate</span>
        }

        <span class="cov0" title="0">_, err = publisher.Apprecovery.AddTargeting(c.packageName, appRecoveryID, &amp;req).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "success":        true,
                "appRecoveryId":  appRecoveryID,
                "targetingAdded": true,
                "package":        c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) recoveryCapabilities(_ context.Context) error <span class="cov0" title="0">{
        result := output.NewResult(map[string]interface{}{
                "operations": []string{"create", "list", "deploy", "cancel", "add-targeting"},
                "recoveryStatuses": []string{
                        "RECOVERY_STATUS_UNSPECIFIED",
                        "RECOVERY_STATUS_ACTIVE",
                        "RECOVERY_STATUS_CANCELED",
                        "RECOVERY_STATUS_DRAFT",
                        "RECOVERY_STATUS_GENERATION_IN_PROGRESS",
                },
                "targetingOptions": map[string]interface{}{
                        "allUsers":     "Target all users",
                        "regions":      "Target specific regions by ISO country codes",
                        "sdkLevels":    "Target specific Android SDK levels",
                        "versionList":  "Target specific app version codes",
                        "versionRange": "Target app version code ranges",
                },
                "notes": []string{
                        "Create returns a draft recovery action",
                        "Deploy activates the recovery for targeted users",
                        "Only criteria selected during creation can be expanded via add-targeting",
                        "Cancelled actions cannot be resumed",
                },
        })
        return c.Output(result.WithServices("androidpublisher"))
}</span>

func parseRecoveryID(recoveryID string) (int64, error) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(recoveryID, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid recovery ID: %s", recoveryID)
        }</span>
        <span class="cov0" title="0">return id, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">// Package cli provides reviews commands for gpd.
package cli

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "os"
        "regexp"
        "strings"
        "time"

        "github.com/spf13/cobra"
        "google.golang.org/api/androidpublisher/v3"

        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

func (c *CLI) addReviewsCommands() <span class="cov10" title="18">{
        reviewsCmd := &amp;cobra.Command{
                Use:   "reviews",
                Short: "Review management commands",
                Long:  "List and reply to user reviews.",
        }

        reviewsCmd.AddCommand(
                c.newReviewsListCommand(),
                c.newReviewsReplyCommand(),
                c.newReviewsGetCommand(),
                c.newReviewsResponseCommand(),
                c.newReviewsCapabilitiesCommand(),
        )
        c.rootCmd.AddCommand(reviewsCmd)
}</span>

func (c *CLI) newReviewsListCommand() *cobra.Command <span class="cov10" title="18">{
        var (
                minRating       int
                maxRating       int
                language        string
                startDate       string
                endDate         string
                scanLimit       int
                includeText     bool
                translationLang string
                pageSize        int64
                pageToken       string
                all             bool
        )

        listCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List user reviews",
                Long:  "List user reviews with optional filtering.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.reviewsList(cmd.Context(), minRating, maxRating, language, startDate, endDate,
                                scanLimit, includeText, translationLang, pageSize, pageToken, all)
                }</span>,
        }
        <span class="cov10" title="18">listCmd.Flags().IntVar(&amp;minRating, "min-rating", 0, "Minimum rating filter (1-5)")
        listCmd.Flags().IntVar(&amp;maxRating, "max-rating", 0, "Maximum rating filter (1-5)")
        listCmd.Flags().StringVar(&amp;language, "language", "", "Filter by review language")
        listCmd.Flags().StringVar(&amp;startDate, "start-date", "", "Start date (ISO 8601)")
        listCmd.Flags().StringVar(&amp;endDate, "end-date", "", "End date (ISO 8601)")
        listCmd.Flags().IntVar(&amp;scanLimit, "scan-limit", 100, "Maximum reviews to scan")
        listCmd.Flags().BoolVar(&amp;includeText, "include-review-text", false, "Include review text in output")
        listCmd.Flags().StringVar(&amp;translationLang, "translation-language", "", "Language for translated reviews")
        listCmd.Flags().Int64Var(&amp;pageSize, "page-size", 50, "Results per page")
        listCmd.Flags().StringVar(&amp;pageToken, "page-token", "", "Pagination token")
        addPaginationFlags(listCmd, &amp;all)

        return listCmd</span>
}

func (c *CLI) newReviewsReplyCommand() *cobra.Command <span class="cov10" title="18">{
        var (
                reviewID     string
                replyText    string
                templateFile string
                maxActions   int
                rateLimit    string
                dryRun       bool
        )

        replyCmd := &amp;cobra.Command{
                Use:   "reply",
                Short: "Reply to a review",
                Long:  "Reply to a user review with optional templating.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.reviewsReply(cmd.Context(), reviewID, replyText, templateFile, maxActions, rateLimit, dryRun)
                }</span>,
        }
        <span class="cov10" title="18">replyCmd.Flags().StringVar(&amp;reviewID, "review-id", "", "Review ID to reply to")
        replyCmd.Flags().StringVar(&amp;replyText, "text", "", "Reply text")
        replyCmd.Flags().StringVar(&amp;templateFile, "template-file", "", "Template file for reply")
        replyCmd.Flags().IntVar(&amp;maxActions, "max-actions", 10, "Maximum replies per execution")
        replyCmd.Flags().StringVar(&amp;rateLimit, "rate-limit", "5s", "Rate limit between replies")
        replyCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Show intended actions without executing")

        return replyCmd</span>
}

func (c *CLI) newReviewsGetCommand() *cobra.Command <span class="cov10" title="18">{
        var (
                getReviewID string
                getInclude  bool
                getLanguage string
        )

        getCmd := &amp;cobra.Command{
                Use:   "get [review-id]",
                Short: "Get a review by ID",
                Long:  "Fetch a single review by ID with optional translated text.",
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        reviewID := getReviewID
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                reviewID = args[0]
                        }</span>
                        <span class="cov0" title="0">if strings.TrimSpace(reviewID) == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError, "review ID is required").
                                        WithHint("Provide a review ID argument or use --review-id")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.reviewsGet(cmd.Context(), reviewID, getInclude, getLanguage)</span>
                },
        }
        <span class="cov10" title="18">getCmd.Flags().StringVar(&amp;getReviewID, "review-id", "", "Review ID to fetch")
        getCmd.Flags().BoolVar(&amp;getInclude, "include-review-text", false, "Include review text in output")
        getCmd.Flags().StringVar(&amp;getLanguage, "translation-language", "", "Language for translated review")

        return getCmd</span>
}

func (c *CLI) newReviewsResponseCommand() *cobra.Command <span class="cov10" title="18">{
        responseCmd := &amp;cobra.Command{
                Use:   "response",
                Short: "Review response commands",
                Long:  "Get or delete a developer response for a review.",
        }

        var responseReviewID string
        responseGetCmd := &amp;cobra.Command{
                Use:   "get [review-id]",
                Short: "Get a review response",
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        reviewID := responseReviewID
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                reviewID = args[0]
                        }</span>
                        <span class="cov0" title="0">if strings.TrimSpace(reviewID) == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError, "review ID is required").
                                        WithHint("Provide a review ID argument or use --review-id")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.reviewsResponseGet(cmd.Context(), reviewID)</span>
                },
        }
        <span class="cov10" title="18">responseGetCmd.Flags().StringVar(&amp;responseReviewID, "review-id", "", "Review ID to fetch response for")

        responseForReviewCmd := &amp;cobra.Command{
                Use:   "for-review [review-id]",
                Short: "Get a review response for a review",
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        reviewID := responseReviewID
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                reviewID = args[0]
                        }</span>
                        <span class="cov0" title="0">if strings.TrimSpace(reviewID) == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError, "review ID is required").
                                        WithHint("Provide a review ID argument or use --review-id")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.reviewsResponseGet(cmd.Context(), reviewID)</span>
                },
        }
        <span class="cov10" title="18">responseForReviewCmd.Flags().StringVar(&amp;responseReviewID, "review-id", "", "Review ID to fetch response for")

        responseDeleteCmd := &amp;cobra.Command{
                Use:   "delete [review-id]",
                Short: "Delete a review response",
                Args:  cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        reviewID := responseReviewID
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                reviewID = args[0]
                        }</span>
                        <span class="cov0" title="0">if strings.TrimSpace(reviewID) == "" </span><span class="cov0" title="0">{
                                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError, "review ID is required").
                                        WithHint("Provide a review ID argument or use --review-id")).WithServices("androidpublisher")
                                return c.Output(result)
                        }</span>
                        <span class="cov0" title="0">return c.reviewsResponseDelete(cmd.Context(), reviewID)</span>
                },
        }
        <span class="cov10" title="18">responseDeleteCmd.Flags().StringVar(&amp;responseReviewID, "review-id", "", "Review ID to delete response for")

        responseCmd.AddCommand(responseGetCmd, responseForReviewCmd, responseDeleteCmd)
        return responseCmd</span>
}

func (c *CLI) newReviewsCapabilitiesCommand() *cobra.Command <span class="cov10" title="18">{
        return &amp;cobra.Command{
                Use:   "capabilities",
                Short: "List review capabilities",
                Long:  "List review API capabilities and limitations.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.reviewsCapabilities(cmd.Context())
                }</span>,
        }
}

// reviewsListParams holds parameters for listing reviews.
type reviewsListParams struct {
        minRating       int
        maxRating       int
        scanLimit       int
        includeText     bool
        translationLang string
        pageSize        int64
        pageToken       string
        all             bool
}

// passesRatingFilter checks if a review passes the rating filter criteria.
func passesRatingFilter(review *androidpublisher.Review, minRating, maxRating int) bool <span class="cov0" title="0">{
        if minRating == 0 &amp;&amp; maxRating == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if len(review.Comments) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">rating := int(review.Comments[0].UserComment.StarRating)
        if minRating &gt; 0 &amp;&amp; rating &lt; minRating </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if maxRating &gt; 0 &amp;&amp; rating &gt; maxRating </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// buildReviewOutput creates the output map for a single review.
func buildReviewOutput(review *androidpublisher.Review, includeText bool) map[string]interface{} <span class="cov0" title="0">{
        reviewOutput := map[string]interface{}{
                "reviewId": review.ReviewId,
        }

        if len(review.Comments) == 0 </span><span class="cov0" title="0">{
                return reviewOutput
        }</span>

        <span class="cov0" title="0">userComment := review.Comments[0].UserComment
        reviewOutput["rating"] = userComment.StarRating
        reviewOutput["language"] = userComment.ReviewerLanguage
        reviewOutput["lastModified"] = userComment.LastModified.Seconds

        if includeText </span><span class="cov0" title="0">{
                reviewOutput["text"] = userComment.Text
        }</span>

        // Check for developer reply
        <span class="cov0" title="0">if len(review.Comments) &gt; 1 &amp;&amp; review.Comments[1].DeveloperComment != nil </span><span class="cov0" title="0">{
                reviewOutput["developerComment"] = map[string]interface{}{
                        "text":         review.Comments[1].DeveloperComment.Text,
                        "lastModified": review.Comments[1].DeveloperComment.LastModified.Seconds,
                }
        }</span>

        <span class="cov0" title="0">return reviewOutput</span>
}

// getNextPageToken extracts the next page token from a reviews response.
func getNextPageToken(resp *androidpublisher.ReviewsListResponse) string <span class="cov0" title="0">{
        if resp.TokenPagination != nil </span><span class="cov0" title="0">{
                return resp.TokenPagination.NextPageToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (c *CLI) reviewsList(ctx context.Context, minRating, maxRating int, _, _, _ string,
        scanLimit int, includeText bool, translationLang string, pageSize int64, pageToken string, all bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">params := reviewsListParams{
                minRating:       minRating,
                maxRating:       maxRating,
                scanLimit:       scanLimit,
                includeText:     includeText,
                translationLang: translationLang,
                pageSize:        pageSize,
                pageToken:       pageToken,
                all:             all,
        }

        return c.fetchAndOutputReviews(ctx, &amp;params)</span>
}

func (c *CLI) reviewsGet(ctx context.Context, reviewID string, includeText bool, translationLang string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">call := publisher.Reviews.Get(c.packageName, reviewID)
        if translationLang != "" </span><span class="cov0" title="0">{
                call = call.TranslationLanguage(translationLang)
        }</span>

        <span class="cov0" title="0">resp, err := call.Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                apiErr := errors.ClassifyAuthError(err)
                if apiErr == nil </span><span class="cov0" title="0">{
                        apiErr = errors.NewAPIError(errors.CodeGeneralError, err.Error())
                }</span>
                <span class="cov0" title="0">if apiErr.Code == errors.CodeValidationError || strings.Contains(apiErr.Message, "wrong format") </span><span class="cov0" title="0">{
                        apiErr = apiErr.WithHint("Review IDs look like 'gp:AOqpTO...'. Use 'gpd reviews list' to retrieve a valid ID.")
                }</span>
                <span class="cov0" title="0">result := output.NewErrorResult(apiErr).WithServices("androidpublisher")
                return c.Output(result)</span>
        }

        <span class="cov0" title="0">result := output.NewResult(buildReviewOutput(resp, includeText))
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) reviewsResponseGet(ctx context.Context, reviewID string) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">resp, err := publisher.Reviews.Get(c.packageName, reviewID).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">if len(resp.Comments) &gt; 1 &amp;&amp; resp.Comments[1].DeveloperComment != nil </span><span class="cov0" title="0">{
                result := output.NewResult(map[string]interface{}{
                        "reviewId": resp.ReviewId,
                        "text":     resp.Comments[1].DeveloperComment.Text,
                        "updated":  resp.Comments[1].DeveloperComment.LastModified.Seconds,
                })
                return c.Output(result.WithServices("androidpublisher"))
        }</span>

        <span class="cov0" title="0">result := output.NewErrorResult(errors.NewAPIError(errors.CodeNotFound, "review response not found").
                WithDetails(map[string]interface{}{"reviewId": reviewID})).WithServices("androidpublisher")
        return c.Output(result)</span>
}

func (c *CLI) reviewsResponseDelete(_ context.Context, reviewID string) error <span class="cov0" title="0">{
        result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError, "review response deletion is not supported by the Google Play API").
                WithHint("Use gpd reviews reply to overwrite an existing response if needed").
                WithDetails(map[string]interface{}{"reviewId": reviewID})).WithServices("androidpublisher")
        return c.Output(result)
}</span>

func (c *CLI) fetchAndOutputReviews(ctx context.Context, params *reviewsListParams) error <span class="cov0" title="0">{
        client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">req := c.buildReviewsRequest(publisher, params)
        allReviews, scannedCount, filteredCount, nextToken, err := c.collectReviews(ctx, req, params)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">return c.outputReviewsResult(allReviews, scannedCount, filteredCount, params.pageToken, nextToken)</span>
}

func (c *CLI) buildReviewsRequest(publisher *androidpublisher.Service, params *reviewsListParams) *androidpublisher.ReviewsListCall <span class="cov0" title="0">{
        req := publisher.Reviews.List(c.packageName).MaxResults(params.pageSize)
        if params.pageToken != "" </span><span class="cov0" title="0">{
                req = req.Token(params.pageToken)
        }</span>
        <span class="cov0" title="0">if params.translationLang != "" </span><span class="cov0" title="0">{
                req = req.TranslationLanguage(params.translationLang)
        }</span>
        <span class="cov0" title="0">return req</span>
}

func (c *CLI) collectReviews(ctx context.Context, req *androidpublisher.ReviewsListCall, params *reviewsListParams) (reviews []map[string]interface{}, scanned, filtered int, nextToken string, err error) <span class="cov0" title="0">{
        var allReviews []map[string]interface{}
        scannedCount := 0
        filteredCount := 0

        for scannedCount &lt; params.scanLimit </span><span class="cov0" title="0">{
                resp, err := req.Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, 0, "", err
                }</span>

                <span class="cov0" title="0">for _, review := range resp.Reviews </span><span class="cov0" title="0">{
                        scannedCount++
                        if !passesRatingFilter(review, params.minRating, params.maxRating) </span><span class="cov0" title="0">{
                                filteredCount++
                                continue</span>
                        }
                        <span class="cov0" title="0">allReviews = append(allReviews, buildReviewOutput(review, params.includeText))</span>
                }

                <span class="cov0" title="0">nextToken = getNextPageToken(resp)
                if nextToken == "" || !params.all </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">req = req.Token(nextToken)</span>
        }

        <span class="cov0" title="0">return allReviews, scannedCount, filteredCount, nextToken, nil</span>
}

func (c *CLI) outputReviewsResult(reviews []map[string]interface{}, scanned, filtered int, pageToken, nextToken string) error <span class="cov0" title="0">{
        result := output.NewResult(reviews)
        result.WithServices("androidpublisher")
        result.WithPartial(scanned, filtered, 0)
        result.WithPagination(pageToken, nextToken)

        if len(reviews) == 0 </span><span class="cov0" title="0">{
                if scanned == 0 </span><span class="cov0" title="0">{
                        result.WithWarnings("No reviews returned. This can mean the app has no reviews yet or access to reviews is restricted.")
                }</span> else<span class="cov0" title="0"> {
                        result.WithWarnings("No reviews matched the current filters. Try adjusting rating filters or scan limits.")
                }</span>
        } else<span class="cov0" title="0"> if filtered &gt; 0 </span><span class="cov0" title="0">{
                result.WithWarnings("Some reviews were filtered out by rating or date.")
        }</span>

        <span class="cov0" title="0">return c.Output(result)</span>
}

func (c *CLI) reviewsReply(ctx context.Context, reviewID, replyText, templateFile string, _ int, rateLimit string, dryRun bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("androidpublisher")
                return c.Output(result)
        }</span>

        // Parse rate limit
        <span class="cov0" title="0">rateDuration, err := time.ParseDuration(rateLimit)
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                        fmt.Sprintf("invalid rate limit: %s", rateLimit))).WithServices("androidpublisher")
                return c.Output(result)
        }</span>

        // Process template if provided
        <span class="cov0" title="0">if templateFile != "" </span><span class="cov0" title="0">{
                data, err := os.ReadFile(templateFile)
                if err != nil </span><span class="cov0" title="0">{
                        result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                                fmt.Sprintf("failed to read template file: %v", err))).WithServices("androidpublisher")
                        return c.Output(result)
                }</span>
                <span class="cov0" title="0">replyText = string(data)</span>
        }

        <span class="cov0" title="0">if replyText == "" </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError,
                        "reply text is required").WithHint("Provide --text or --template-file")).WithServices("androidpublisher")
                return c.Output(result)
        }</span>

        // Process template variables
        <span class="cov0" title="0">replyText, err = processTemplate(replyText, map[string]string{
                "appName": c.packageName, // Would be actual app name
                "rating":  "5",           // Would come from review
                "locale":  "en-US",       // Would come from review
        })
        if err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(errors.NewAPIError(errors.CodeValidationError, err.Error())).
                        WithServices("androidpublisher")
                return c.Output(result)
        }</span>

        // Check idempotency
        <span class="cov0" title="0">idempotencyKey := hashReply(reviewID, replyText)

        if dryRun </span><span class="cov0" title="0">{
                result := output.NewResult(map[string]interface{}{
                        "dryRun":         true,
                        "action":         "reply",
                        "reviewId":       reviewID,
                        "text":           replyText,
                        "idempotencyKey": idempotencyKey,
                        "rateLimit":      rateDuration.String(),
                        "package":        c.packageName,
                })
                return c.Output(result.WithServices("androidpublisher"))
        }</span>

        // Get API client
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">publisher, err := client.AndroidPublisher()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        // Apply rate limiting
        <span class="cov0" title="0">time.Sleep(rateDuration)

        // Build the reply request
        replyRequest := &amp;androidpublisher.ReviewsReplyRequest{
                ReplyText: replyText,
        }

        // Post reply
        replyResp, err := publisher.Reviews.Reply(c.packageName, reviewID, replyRequest).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError,
                        fmt.Sprintf("failed to reply: %v", err)))
        }</span>
        <span class="cov0" title="0">_ = replyResp // Contains the result with lastEdited timestamp

        result := output.NewResult(map[string]interface{}{
                "success":        true,
                "reviewId":       reviewID,
                "text":           replyText,
                "idempotencyKey": idempotencyKey,
                "action":         "created",
                "package":        c.packageName,
        })
        return c.Output(result.WithServices("androidpublisher"))</span>
}

func (c *CLI) reviewsCapabilities(_ context.Context) error <span class="cov0" title="0">{
        result := output.NewResult(map[string]interface{}{
                "requiredScopes":   []string{"https://www.googleapis.com/auth/androidpublisher"},
                "reviewWindowDays": 90,
                "maxReplyLength":   350,
                "supportedFilters": map[string]interface{}{
                        "serverSide": []string{"translationLanguage"},
                        "clientSide": []string{"rating", "dateRange", "language"},
                },
                "defaultScanLimit":  100,
                "templateVariables": []string{"{{appName}}", "{{rating}}", "{{locale}}"},
                "apiLimitations": []string{
                        "Date range filtering is client-side only",
                        "Review window limited to recent reviews",
                        "Server-side filtering limited to translation language",
                },
        })
        return c.Output(result.WithServices("androidpublisher"))
}</span>

// processTemplate processes template variables in the text.
func processTemplate(text string, vars map[string]string) (string, error) <span class="cov0" title="0">{
        // Find all template variables
        re := regexp.MustCompile(`\{\{(\w+)\}\}`)
        matches := re.FindAllStringSubmatch(text, -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                varName := match[1]
                value, ok := vars[varName]
                if !ok </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("missing template variable: {{%s}}", varName)
                }</span>
                <span class="cov0" title="0">text = strings.ReplaceAll(text, match[0], value)</span>
        }

        <span class="cov0" title="0">return text, nil</span>
}

// hashReply creates an idempotency key for a reply.
func hashReply(reviewID, text string) string <span class="cov0" title="0">{
        h := sha256.New()
        h.Write([]byte(reviewID))
        h.Write([]byte(text))
        return hex.EncodeToString(h.Sum(nil))[:16]
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package cli

import (
        "github.com/spf13/cobra"
)

func (c *CLI) addVitalsCommands() <span class="cov10" title="18">{
        vitalsCmd := &amp;cobra.Command{
                Use:   "vitals",
                Short: "Android vitals commands",
                Long:  "Access crash rates, ANR rates, and performance metrics.",
        }

        c.addVitalsMetricsCommands(vitalsCmd)
        c.addVitalsErrorsCommands(vitalsCmd)
        c.addVitalsAnomaliesCommands(vitalsCmd)
        c.addVitalsCapabilitiesCommand(vitalsCmd)

        c.rootCmd.AddCommand(vitalsCmd)
}</span>

func (c *CLI) addVitalsMetricsCommands(vitalsCmd *cobra.Command) <span class="cov10" title="18">{
        var (
                startDate  string
                endDate    string
                metrics    []string
                dimensions []string
                outputFmt  string
                pageSize   int64
                pageToken  string
                all        bool
        )

        crashesCmd := &amp;cobra.Command{
                Use:   "crashes",
                Short: "Query crash rate data",
                Long:  "Query crash rate metrics for a date range.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.vitalsCrashes(cmd.Context(), startDate, endDate, dimensions, outputFmt, pageSize, pageToken, all)
                }</span>,
        }
        <span class="cov10" title="18">crashesCmd.Flags().StringVar(&amp;startDate, "start-date", "", "Start date (ISO 8601)")
        crashesCmd.Flags().StringVar(&amp;endDate, "end-date", "", "End date (ISO 8601)")
        crashesCmd.Flags().StringSliceVar(&amp;dimensions, "dimensions", nil, "Dimensions for grouping")
        crashesCmd.Flags().StringVar(&amp;outputFmt, "format", "json", "Output format: json, csv")
        crashesCmd.Flags().Int64Var(&amp;pageSize, "page-size", 100, "Results per page")
        crashesCmd.Flags().StringVar(&amp;pageToken, "page-token", "", "Pagination token")
        addPaginationFlags(crashesCmd, &amp;all)

        anrsCmd := &amp;cobra.Command{
                Use:   "anrs",
                Short: "Query ANR rate data",
                Long:  "Query Application Not Responding (ANR) metrics.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.vitalsANRs(cmd.Context(), startDate, endDate, dimensions, outputFmt, pageSize, pageToken, all)
                }</span>,
        }
        <span class="cov10" title="18">anrsCmd.Flags().StringVar(&amp;startDate, "start-date", "", "Start date (ISO 8601)")
        anrsCmd.Flags().StringVar(&amp;endDate, "end-date", "", "End date (ISO 8601)")
        anrsCmd.Flags().StringSliceVar(&amp;dimensions, "dimensions", nil, "Dimensions for grouping")
        anrsCmd.Flags().StringVar(&amp;outputFmt, "format", "json", "Output format: json, csv")
        anrsCmd.Flags().Int64Var(&amp;pageSize, "page-size", 100, "Results per page")
        anrsCmd.Flags().StringVar(&amp;pageToken, "page-token", "", "Pagination token")
        addPaginationFlags(anrsCmd, &amp;all)

        queryCmd := &amp;cobra.Command{
                Use:   "query",
                Short: "Query vitals metrics",
                Long:  "Query vitals metrics for a date range.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.vitalsQuery(cmd.Context(), startDate, endDate, metrics, dimensions, outputFmt, pageSize, pageToken, all)
                }</span>,
        }
        <span class="cov10" title="18">queryCmd.Flags().StringVar(&amp;startDate, "start-date", "", "Start date (ISO 8601)")
        queryCmd.Flags().StringVar(&amp;endDate, "end-date", "", "End date (ISO 8601)")
        queryCmd.Flags().StringSliceVar(&amp;metrics, "metrics", []string{"crashRate"}, "Metrics to retrieve")
        queryCmd.Flags().StringSliceVar(&amp;dimensions, "dimensions", nil, "Dimensions for grouping")
        queryCmd.Flags().StringVar(&amp;outputFmt, "format", "json", "Output format: json, csv")
        queryCmd.Flags().Int64Var(&amp;pageSize, "page-size", 100, "Results per page")
        queryCmd.Flags().StringVar(&amp;pageToken, "page-token", "", "Pagination token")
        addPaginationFlags(queryCmd, &amp;all)

        vitalsCmd.AddCommand(crashesCmd, anrsCmd, queryCmd)
        c.addVitalsPerformanceCommands(vitalsCmd)</span>
}

func (c *CLI) addVitalsPerformanceCommands(vitalsCmd *cobra.Command) <span class="cov10" title="18">{
        var (
                startDate  string
                endDate    string
                dimensions []string
                outputFmt  string
                pageSize   int64
                pageToken  string
                all        bool
        )

        excessiveWakeupsCmd := &amp;cobra.Command{
                Use:   "excessive-wakeups",
                Short: "Query excessive wakeups data",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.vitalsExcessiveWakeups(cmd.Context(), startDate, endDate, dimensions, outputFmt, pageSize, pageToken, all)
                }</span>,
        }
        <span class="cov10" title="18">excessiveWakeupsCmd.Flags().StringVar(&amp;startDate, "start-date", "", "Start date (ISO 8601)")
        excessiveWakeupsCmd.Flags().StringVar(&amp;endDate, "end-date", "", "End date (ISO 8601)")
        excessiveWakeupsCmd.Flags().StringSliceVar(&amp;dimensions, "dimensions", nil, "Dimensions for grouping")
        excessiveWakeupsCmd.Flags().StringVar(&amp;outputFmt, "format", "json", "Output format: json, csv")
        excessiveWakeupsCmd.Flags().Int64Var(&amp;pageSize, "page-size", 100, "Results per page")
        excessiveWakeupsCmd.Flags().StringVar(&amp;pageToken, "page-token", "", "Pagination token")
        addPaginationFlags(excessiveWakeupsCmd, &amp;all)

        lmkRateCmd := &amp;cobra.Command{
                Use:   "lmk-rate",
                Short: "Query LMK rate data",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.vitalsLmkRate(cmd.Context(), startDate, endDate, dimensions, outputFmt, pageSize, pageToken, all)
                }</span>,
        }
        <span class="cov10" title="18">lmkRateCmd.Flags().StringVar(&amp;startDate, "start-date", "", "Start date (ISO 8601)")
        lmkRateCmd.Flags().StringVar(&amp;endDate, "end-date", "", "End date (ISO 8601)")
        lmkRateCmd.Flags().StringSliceVar(&amp;dimensions, "dimensions", nil, "Dimensions for grouping")
        lmkRateCmd.Flags().StringVar(&amp;outputFmt, "format", "json", "Output format: json, csv")
        lmkRateCmd.Flags().Int64Var(&amp;pageSize, "page-size", 100, "Results per page")
        lmkRateCmd.Flags().StringVar(&amp;pageToken, "page-token", "", "Pagination token")
        addPaginationFlags(lmkRateCmd, &amp;all)

        slowRenderingCmd := &amp;cobra.Command{
                Use:   "slow-rendering",
                Short: "Query slow rendering data",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.vitalsSlowRendering(cmd.Context(), startDate, endDate, dimensions, outputFmt, pageSize, pageToken, all)
                }</span>,
        }
        <span class="cov10" title="18">slowRenderingCmd.Flags().StringVar(&amp;startDate, "start-date", "", "Start date (ISO 8601)")
        slowRenderingCmd.Flags().StringVar(&amp;endDate, "end-date", "", "End date (ISO 8601)")
        slowRenderingCmd.Flags().StringSliceVar(&amp;dimensions, "dimensions", nil, "Dimensions for grouping")
        slowRenderingCmd.Flags().StringVar(&amp;outputFmt, "format", "json", "Output format: json, csv")
        slowRenderingCmd.Flags().Int64Var(&amp;pageSize, "page-size", 100, "Results per page")
        slowRenderingCmd.Flags().StringVar(&amp;pageToken, "page-token", "", "Pagination token")
        addPaginationFlags(slowRenderingCmd, &amp;all)

        slowStartCmd := &amp;cobra.Command{
                Use:   "slow-start",
                Short: "Query slow start data",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.vitalsSlowStart(cmd.Context(), startDate, endDate, dimensions, outputFmt, pageSize, pageToken, all)
                }</span>,
        }
        <span class="cov10" title="18">slowStartCmd.Flags().StringVar(&amp;startDate, "start-date", "", "Start date (ISO 8601)")
        slowStartCmd.Flags().StringVar(&amp;endDate, "end-date", "", "End date (ISO 8601)")
        slowStartCmd.Flags().StringSliceVar(&amp;dimensions, "dimensions", nil, "Dimensions for grouping")
        slowStartCmd.Flags().StringVar(&amp;outputFmt, "format", "json", "Output format: json, csv")
        slowStartCmd.Flags().Int64Var(&amp;pageSize, "page-size", 100, "Results per page")
        slowStartCmd.Flags().StringVar(&amp;pageToken, "page-token", "", "Pagination token")
        addPaginationFlags(slowStartCmd, &amp;all)

        stuckWakelocksCmd := &amp;cobra.Command{
                Use:   "stuck-wakelocks",
                Short: "Query stuck wakelocks data",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.vitalsStuckWakelocks(cmd.Context(), startDate, endDate, dimensions, outputFmt, pageSize, pageToken, all)
                }</span>,
        }
        <span class="cov10" title="18">stuckWakelocksCmd.Flags().StringVar(&amp;startDate, "start-date", "", "Start date (ISO 8601)")
        stuckWakelocksCmd.Flags().StringVar(&amp;endDate, "end-date", "", "End date (ISO 8601)")
        stuckWakelocksCmd.Flags().StringSliceVar(&amp;dimensions, "dimensions", nil, "Dimensions for grouping")
        stuckWakelocksCmd.Flags().StringVar(&amp;outputFmt, "format", "json", "Output format: json, csv")
        stuckWakelocksCmd.Flags().Int64Var(&amp;pageSize, "page-size", 100, "Results per page")
        stuckWakelocksCmd.Flags().StringVar(&amp;pageToken, "page-token", "", "Pagination token")
        addPaginationFlags(stuckWakelocksCmd, &amp;all)

        vitalsCmd.AddCommand(excessiveWakeupsCmd, lmkRateCmd, slowRenderingCmd, slowStartCmd, stuckWakelocksCmd)</span>
}

func (c *CLI) addVitalsErrorsCommands(vitalsCmd *cobra.Command) <span class="cov10" title="18">{
        errorsCmd := &amp;cobra.Command{
                Use:   "errors",
                Short: "Search and report errors",
                Long:  "Search error issues, reports, and query error counts.",
        }

        var (
                errorQuery     string
                errorInterval  string
                errorPageSize  int64
                errorPageToken string
                errorAll       bool
                deobfuscate    bool
        )

        errorsIssuesSearchCmd := &amp;cobra.Command{
                Use:   "issues search",
                Short: "Search error issues",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.vitalsErrorsIssuesSearch(cmd.Context(), errorQuery, errorInterval, errorPageSize, errorPageToken, errorAll)
                }</span>,
        }
        <span class="cov10" title="18">errorsIssuesSearchCmd.Flags().StringVar(&amp;errorQuery, "query", "", "Search query")
        errorsIssuesSearchCmd.Flags().StringVar(&amp;errorInterval, "interval", "last30Days", "Time interval")
        errorsIssuesSearchCmd.Flags().Int64Var(&amp;errorPageSize, "page-size", 50, "Results per page")
        errorsIssuesSearchCmd.Flags().StringVar(&amp;errorPageToken, "page-token", "", "Pagination token")
        addPaginationFlags(errorsIssuesSearchCmd, &amp;errorAll)

        errorsReportsSearchCmd := &amp;cobra.Command{
                Use:   "reports search",
                Short: "Search error reports",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.vitalsErrorsReportsSearch(cmd.Context(), errorQuery, errorInterval, errorPageSize, errorPageToken, errorAll, deobfuscate)
                }</span>,
        }
        <span class="cov10" title="18">errorsReportsSearchCmd.Flags().StringVar(&amp;errorQuery, "query", "", "Search query")
        errorsReportsSearchCmd.Flags().StringVar(&amp;errorInterval, "interval", "last30Days", "Time interval")
        errorsReportsSearchCmd.Flags().Int64Var(&amp;errorPageSize, "page-size", 50, "Results per page")
        errorsReportsSearchCmd.Flags().StringVar(&amp;errorPageToken, "page-token", "", "Pagination token")
        errorsReportsSearchCmd.Flags().BoolVar(&amp;deobfuscate, "deobfuscate", false, "Format report text for readability")
        addPaginationFlags(errorsReportsSearchCmd, &amp;errorAll)

        errorsCmd.AddCommand(errorsIssuesSearchCmd, errorsReportsSearchCmd)
        c.addVitalsErrorsCountsCommands(errorsCmd)
        vitalsCmd.AddCommand(errorsCmd)</span>
}

func (c *CLI) addVitalsErrorsCountsCommands(errorsCmd *cobra.Command) <span class="cov10" title="18">{
        countsCmd := &amp;cobra.Command{
                Use:   "counts",
                Short: "Error count metrics",
        }

        var (
                countsStartDate string
                countsEndDate   string
                countsDims      []string
                errorPageSize   int64
                errorPageToken  string
                errorAll        bool
        )

        errorsCountsGetCmd := &amp;cobra.Command{
                Use:   "get",
                Short: "Get error count metrics",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.vitalsErrorsCountsGet(cmd.Context())
                }</span>,
        }

        <span class="cov10" title="18">errorsCountsQueryCmd := &amp;cobra.Command{
                Use:   "query",
                Short: "Query error counts over time",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.vitalsErrorsCountsQuery(cmd.Context(), countsStartDate, countsEndDate, countsDims, errorPageSize, errorPageToken, errorAll)
                }</span>,
        }
        <span class="cov10" title="18">errorsCountsQueryCmd.Flags().StringVar(&amp;countsStartDate, "start-date", "", "Start date (ISO 8601)")
        errorsCountsQueryCmd.Flags().StringVar(&amp;countsEndDate, "end-date", "", "End date (ISO 8601)")
        errorsCountsQueryCmd.Flags().StringSliceVar(&amp;countsDims, "dimensions", nil, "Dimensions for grouping")
        errorsCountsQueryCmd.Flags().Int64Var(&amp;errorPageSize, "page-size", 100, "Results per page")
        errorsCountsQueryCmd.Flags().StringVar(&amp;errorPageToken, "page-token", "", "Pagination token")
        addPaginationFlags(errorsCountsQueryCmd, &amp;errorAll)

        countsCmd.AddCommand(errorsCountsGetCmd, errorsCountsQueryCmd)
        errorsCmd.AddCommand(countsCmd)</span>
}

func (c *CLI) addVitalsAnomaliesCommands(vitalsCmd *cobra.Command) <span class="cov10" title="18">{
        anomaliesCmd := &amp;cobra.Command{
                Use:   "anomalies",
                Short: "Anomalies in vitals metrics",
        }

        var (
                anomalyMetric      string
                anomalyTimePeriod  string
                anomalyMinSeverity string
                anomalyPageSize    int64
                anomalyPageToken   string
                anomalyAll         bool
        )

        anomaliesListCmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List anomalies",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.vitalsAnomaliesList(cmd.Context(), anomalyMetric, anomalyTimePeriod, anomalyMinSeverity, anomalyPageSize, anomalyPageToken, anomalyAll)
                }</span>,
        }
        <span class="cov10" title="18">anomaliesListCmd.Flags().StringVar(&amp;anomalyMetric, "metric", "", "Metric name filter")
        anomaliesListCmd.Flags().StringVar(&amp;anomalyTimePeriod, "time-period", "last30Days", "Time period: last7Days, last30Days, last90Days")
        anomaliesListCmd.Flags().StringVar(&amp;anomalyMinSeverity, "min-severity", "", "Minimum severity")
        anomaliesListCmd.Flags().Int64Var(&amp;anomalyPageSize, "page-size", 20, "Results per page")
        anomaliesListCmd.Flags().StringVar(&amp;anomalyPageToken, "page-token", "", "Pagination token")
        addPaginationFlags(anomaliesListCmd, &amp;anomalyAll)

        anomaliesCmd.AddCommand(anomaliesListCmd)
        vitalsCmd.AddCommand(anomaliesCmd)</span>
}

func (c *CLI) addVitalsCapabilitiesCommand(vitalsCmd *cobra.Command) <span class="cov10" title="18">{
        capabilitiesCmd := &amp;cobra.Command{
                Use:   "capabilities",
                Short: "List vitals capabilities",
                Long:  "List available vitals metrics and dimensions.",
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.vitalsCapabilities(cmd.Context())
                }</span>,
        }
        <span class="cov10" title="18">vitalsCmd.AddCommand(capabilitiesCmd)</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package cli

import (
        "context"
        "fmt"
        "strconv"
        "strings"

        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

const (
        timePeriodLast7Days  = "last7Days"
        timePeriodLast30Days = "last30Days"
        timePeriodLast90Days = "last90Days"
)

func parseYear(date string) int64 <span class="cov0" title="0">{
        parts := strings.Split(date, "-")
        if len(parts) &gt;= 1 </span><span class="cov0" title="0">{
                y, _ := strconv.ParseInt(parts[0], 10, 64)
                return y
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func parseMonth(date string) int64 <span class="cov0" title="0">{
        parts := strings.Split(date, "-")
        if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                m, _ := strconv.ParseInt(parts[1], 10, 64)
                return m
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func parseDay(date string) int64 <span class="cov0" title="0">{
        parts := strings.Split(date, "-")
        if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                d, _ := strconv.ParseInt(parts[2], 10, 64)
                return d
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func formatReportText(report string) string <span class="cov0" title="0">{
        lines := strings.Split(report, "\n")
        var formatted []string
        for i, line := range lines </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(line)
                if trimmed == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">formatted = append(formatted, fmt.Sprintf("%d: %s", i+1, trimmed))</span>
        }
        <span class="cov0" title="0">if len(formatted) == 0 </span><span class="cov0" title="0">{
                return report
        }</span>
        <span class="cov0" title="0">return "  " + strings.Join(formatted, "\n  ")</span>
}

func (c *CLI) vitalsQuery(ctx context.Context, startDate, endDate string, metrics, dimensions []string,
        outputFmt string, pageSize int64, pageToken string, all bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">var allResults []map[string]interface{}

        for _, metric := range metrics </span><span class="cov0" title="0">{
                switch metric </span>{
                case "crashRate":<span class="cov0" title="0">
                        err := c.vitalsCrashes(ctx, startDate, endDate, dimensions, outputFmt, pageSize, pageToken, all)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                case "anrRate":<span class="cov0" title="0">
                        err := c.vitalsANRs(ctx, startDate, endDate, dimensions, outputFmt, pageSize, pageToken, all)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                case "excessiveWakeups":<span class="cov0" title="0">
                        err := c.vitalsExcessiveWakeups(ctx, startDate, endDate, dimensions, outputFmt, pageSize, pageToken, all)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                case "lmkRate":<span class="cov0" title="0">
                        err := c.vitalsLmkRate(ctx, startDate, endDate, dimensions, outputFmt, pageSize, pageToken, all)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                case "slowRendering":<span class="cov0" title="0">
                        err := c.vitalsSlowRendering(ctx, startDate, endDate, dimensions, outputFmt, pageSize, pageToken, all)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                case "slowStart":<span class="cov0" title="0">
                        err := c.vitalsSlowStart(ctx, startDate, endDate, dimensions, outputFmt, pageSize, pageToken, all)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                case "stuckWakelocks":<span class="cov0" title="0">
                        err := c.vitalsStuckWakelocks(ctx, startDate, endDate, dimensions, outputFmt, pageSize, pageToken, all)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                default:<span class="cov0" title="0">
                        allResults = append(allResults, map[string]interface{}{
                                "metric": metric,
                                "status": "unsupported",
                                "hint":   "Use 'gpd vitals capabilities' to see supported metrics",
                        })</span>
                }
        }

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "metrics":    metrics,
                "startDate":  startDate,
                "endDate":    endDate,
                "dimensions": dimensions,
                "package":    c.packageName,
                "results":    allResults,
                "dataFreshness": map[string]interface{}{
                        "note": "Vitals data may be delayed by 24-48 hours",
                },
        })
        return c.Output(result.WithServices("playdeveloperreporting"))</span>
}

func (c *CLI) vitalsCapabilities(_ context.Context) error <span class="cov0" title="0">{
        result := output.NewResult(map[string]interface{}{
                "requiredScopes": []string{"https://www.googleapis.com/auth/playdeveloperreporting"},
                "metrics": []map[string]interface{}{
                        {"name": "crashRate", "description": "Crash rate per 1000 sessions", "unit": "percentage"},
                        {"name": "anrRate", "description": "ANR rate per 1000 sessions", "unit": "percentage"},
                        {"name": "userPerceivedCrashRate", "description": "User-perceived crash rate", "unit": "percentage"},
                        {"name": "userPerceivedAnrRate", "description": "User-perceived ANR rate", "unit": "percentage"},
                        {"name": "excessiveWakeups", "description": "Excessive wakeups", "unit": "count"},
                        {"name": "stuckWakeLocks", "description": "Stuck wake locks", "unit": "count"},
                        {"name": "lmkRate", "description": "Low memory kill rate", "unit": "percentage"},
                        {"name": "slowRendering", "description": "Slow rendering rate", "unit": "percentage"},
                        {"name": "slowStart", "description": "Slow start rate", "unit": "percentage"},
                },
                "dimensions": []map[string]interface{}{
                        {"name": "country", "description": "Country code"},
                        {"name": "device", "description": "Device model"},
                        {"name": "androidVersion", "description": "Android OS version"},
                        {"name": "appVersion", "description": "App version code"},
                },
                "granularities":   []string{"daily"},
                "maxLookbackDays": 28,
                "dataFreshness": map[string]interface{}{
                        "typical": "24-48 hours",
                        "note":    "Vitals data freshness depends on user opt-in and reporting",
                },
                "thresholds": map[string]interface{}{
                        "crashRateBad":       1.09,
                        "crashRateExcessive": 8.0,
                        "anrRateBad":         0.47,
                        "anrRateExcessive":   4.0,
                },
        })
        return c.Output(result.WithServices("playdeveloperreporting"))
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package cli

import (
        "context"
        "fmt"
        "strings"
        "time"

        playdeveloperreporting "google.golang.org/api/playdeveloperreporting/v1beta1"

        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

func (c *CLI) vitalsAnomaliesList(ctx context.Context, metric, timePeriod, minSeverity string, pageSize int64, pageToken string, all bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>
        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>
        <span class="cov0" title="0">reporting, err := client.PlayReporting()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>
        <span class="cov0" title="0">appName := fmt.Sprintf("apps/%s", c.packageName)
        req := reporting.Anomalies.List(appName)
        filter := buildAnomalyFilter(timePeriod)
        if filter != "" </span><span class="cov0" title="0">{
                req = req.Filter(filter)
        }</span>
        <span class="cov0" title="0">if pageSize &gt; 0 </span><span class="cov0" title="0">{
                req = req.PageSize(pageSize)
        }</span>
        <span class="cov0" title="0">if pageToken != "" </span><span class="cov0" title="0">{
                req = req.PageToken(pageToken)
        }</span>

        <span class="cov0" title="0">startToken := pageToken
        nextToken := ""
        var allAnomalies []*playdeveloperreporting.GooglePlayDeveloperReportingV1beta1Anomaly
        for </span><span class="cov0" title="0">{
                resp, err := req.Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
                }</span>
                <span class="cov0" title="0">anomalies := resp.Anomalies
                if metric != "" </span><span class="cov0" title="0">{
                        filtered := make([]*playdeveloperreporting.GooglePlayDeveloperReportingV1beta1Anomaly, 0, len(anomalies))
                        for _, anomaly := range anomalies </span><span class="cov0" title="0">{
                                if anomaly == nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">if anomaly.Metric != nil &amp;&amp; strings.EqualFold(anomaly.Metric.Metric, metric) </span><span class="cov0" title="0">{
                                        filtered = append(filtered, anomaly)
                                        continue</span>
                                }
                                <span class="cov0" title="0">if strings.Contains(strings.ToLower(anomaly.MetricSet), strings.ToLower(metric)) </span><span class="cov0" title="0">{
                                        filtered = append(filtered, anomaly)
                                }</span>
                        }
                        <span class="cov0" title="0">anomalies = filtered</span>
                }
                <span class="cov0" title="0">allAnomalies = append(allAnomalies, anomalies...)
                nextToken = resp.NextPageToken
                if nextToken == "" || !all </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">req = req.PageToken(nextToken)</span>
        }
        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "anomalies":     allAnomalies,
                "metric":        metric,
                "timePeriod":    timePeriod,
                "nextPageToken": nextToken,
                "package":       c.packageName,
        })
        if minSeverity != "" </span><span class="cov0" title="0">{
                result.WithWarnings("min-severity filtering is not supported by the API")
        }</span>
        <span class="cov0" title="0">result.WithPagination(startToken, nextToken)
        return c.Output(result.WithServices("playdeveloperreporting"))</span>
}

func buildAnomalyFilter(timePeriod string) string <span class="cov0" title="0">{
        now := time.Now().UTC()
        switch timePeriod </span>{
        case timePeriodLast7Days:<span class="cov0" title="0">
                return fmt.Sprintf("activeBetween(%q, %q)", now.AddDate(0, 0, -7).Format(time.RFC3339), now.Format(time.RFC3339))</span>
        case timePeriodLast30Days:<span class="cov0" title="0">
                return fmt.Sprintf("activeBetween(%q, %q)", now.AddDate(0, 0, -30).Format(time.RFC3339), now.Format(time.RFC3339))</span>
        case timePeriodLast90Days:<span class="cov0" title="0">
                return fmt.Sprintf("activeBetween(%q, %q)", now.AddDate(0, 0, -90).Format(time.RFC3339), now.Format(time.RFC3339))</span>
        case "", "all":<span class="cov0" title="0">
                return ""</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func (c *CLI) vitalsErrorsIssuesSearch(ctx context.Context, query, interval string, pageSize int64, pageToken string, all bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">reporting, err := client.PlayReporting()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">appName := fmt.Sprintf("apps/%s", c.packageName)
        searchCall := reporting.Vitals.Errors.Issues.Search(appName)

        if query != "" </span><span class="cov0" title="0">{
                searchCall = searchCall.Filter(query)
        }</span>

        <span class="cov0" title="0">if interval != "" </span><span class="cov0" title="0">{
                now := time.Now().UTC()
                var startTime time.Time
                switch interval </span>{
                case timePeriodLast7Days:<span class="cov0" title="0">
                        startTime = now.AddDate(0, 0, -7)</span>
                case timePeriodLast30Days:<span class="cov0" title="0">
                        startTime = now.AddDate(0, 0, -30)</span>
                case timePeriodLast90Days:<span class="cov0" title="0">
                        startTime = now.AddDate(0, 0, -90)</span>
                default:<span class="cov0" title="0">
                        startTime = now.AddDate(0, 0, -30)</span>
                }
                <span class="cov0" title="0">searchCall = searchCall.IntervalStartTimeYear(int64(startTime.Year())).
                        IntervalStartTimeMonth(int64(startTime.Month())).
                        IntervalStartTimeDay(int64(startTime.Day())).
                        IntervalEndTimeYear(int64(now.Year())).
                        IntervalEndTimeMonth(int64(now.Month())).
                        IntervalEndTimeDay(int64(now.Day()))</span>
        }

        <span class="cov0" title="0">if pageSize &gt; 0 </span><span class="cov0" title="0">{
                searchCall = searchCall.PageSize(pageSize)
        }</span>
        <span class="cov0" title="0">if pageToken != "" </span><span class="cov0" title="0">{
                searchCall = searchCall.PageToken(pageToken)
        }</span>

        <span class="cov0" title="0">startToken := pageToken
        nextToken := ""
        var allIssues []*playdeveloperreporting.GooglePlayDeveloperReportingV1beta1ErrorIssue
        for </span><span class="cov0" title="0">{
                resp, err := searchCall.Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.outputReportingQueryError(err, "failed to search error issues")
                }</span>
                <span class="cov0" title="0">allIssues = append(allIssues, resp.ErrorIssues...)
                nextToken = resp.NextPageToken
                if nextToken == "" || !all </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">searchCall = searchCall.PageToken(nextToken)</span>
        }

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "query":         query,
                "interval":      interval,
                "package":       c.packageName,
                "issues":        allIssues,
                "rowCount":      len(allIssues),
                "nextPageToken": nextToken,
        })
        result.WithPagination(startToken, nextToken)
        return c.Output(result.WithServices("playdeveloperreporting"))</span>
}

func (c *CLI) vitalsErrorsReportsSearch(ctx context.Context, query, interval string, pageSize int64, pageToken string, all, formatReport bool) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">reporting, err := client.PlayReporting()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">appName := fmt.Sprintf("apps/%s", c.packageName)
        searchCall := reporting.Vitals.Errors.Reports.Search(appName)

        if query != "" </span><span class="cov0" title="0">{
                searchCall = searchCall.Filter(query)
        }</span>

        <span class="cov0" title="0">if interval != "" </span><span class="cov0" title="0">{
                now := time.Now().UTC()
                var startTime time.Time
                switch interval </span>{
                case timePeriodLast7Days:<span class="cov0" title="0">
                        startTime = now.AddDate(0, 0, -7)</span>
                case timePeriodLast30Days:<span class="cov0" title="0">
                        startTime = now.AddDate(0, 0, -30)</span>
                case timePeriodLast90Days:<span class="cov0" title="0">
                        startTime = now.AddDate(0, 0, -90)</span>
                default:<span class="cov0" title="0">
                        startTime = now.AddDate(0, 0, -30)</span>
                }
                <span class="cov0" title="0">searchCall = searchCall.IntervalStartTimeYear(int64(startTime.Year())).
                        IntervalStartTimeMonth(int64(startTime.Month())).
                        IntervalStartTimeDay(int64(startTime.Day())).
                        IntervalEndTimeYear(int64(now.Year())).
                        IntervalEndTimeMonth(int64(now.Month())).
                        IntervalEndTimeDay(int64(now.Day()))</span>
        }

        <span class="cov0" title="0">if pageSize &gt; 0 </span><span class="cov0" title="0">{
                searchCall = searchCall.PageSize(pageSize)
        }</span>
        <span class="cov0" title="0">if pageToken != "" </span><span class="cov0" title="0">{
                searchCall = searchCall.PageToken(pageToken)
        }</span>

        <span class="cov0" title="0">startToken := pageToken
        nextToken := ""
        var allReports []*playdeveloperreporting.GooglePlayDeveloperReportingV1beta1ErrorReport
        for </span><span class="cov0" title="0">{
                resp, err := searchCall.Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.outputReportingQueryError(err, "failed to search error reports")
                }</span>
                <span class="cov0" title="0">if formatReport </span><span class="cov0" title="0">{
                        for _, report := range resp.ErrorReports </span><span class="cov0" title="0">{
                                if report != nil &amp;&amp; report.ReportText != "" </span><span class="cov0" title="0">{
                                        report.ReportText = formatReportText(report.ReportText)
                                }</span>
                        }
                }
                <span class="cov0" title="0">allReports = append(allReports, resp.ErrorReports...)
                nextToken = resp.NextPageToken
                if nextToken == "" || !all </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">searchCall = searchCall.PageToken(nextToken)</span>
        }

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "query":         query,
                "interval":      interval,
                "package":       c.packageName,
                "reports":       allReports,
                "rowCount":      len(allReports),
                "nextPageToken": nextToken,
        })
        result.WithPagination(startToken, nextToken)
        return c.Output(result.WithServices("playdeveloperreporting"))</span>
}

func (c *CLI) vitalsErrorsCountsGet(ctx context.Context) error <span class="cov0" title="0">{
        if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">reporting, err := client.PlayReporting()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">appName := fmt.Sprintf("apps/%s", c.packageName)
        resp, err := reporting.Vitals.Errors.Counts.Get(appName).Context(ctx).Do()
        if err != nil </span><span class="cov0" title="0">{
                return c.outputReportingQueryError(err, "failed to get error counts")
        }</span>

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "package": c.packageName,
                "counts":  resp,
        })
        return c.Output(result.WithServices("playdeveloperreporting"))</span>
}

func (c *CLI) vitalsErrorsCountsQuery(ctx context.Context, startDate, endDate string, dimensions []string, pageSize int64, pageToken string, all bool) error <span class="cov0" title="0">{
        if apiErr := validateReportingDates(startDate, endDate); apiErr != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(apiErr).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>
        <span class="cov0" title="0">if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">reporting, err := client.PlayReporting()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">appName := fmt.Sprintf("apps/%s", c.packageName)
        timelineSpec := &amp;playdeveloperreporting.GooglePlayDeveloperReportingV1beta1TimelineSpec{
                AggregationPeriod: "DAILY",
                StartTime: &amp;playdeveloperreporting.GoogleTypeDateTime{
                        Year:  parseYear(startDate),
                        Month: parseMonth(startDate),
                        Day:   parseDay(startDate),
                },
                EndTime: &amp;playdeveloperreporting.GoogleTypeDateTime{
                        Year:  parseYear(endDate),
                        Month: parseMonth(endDate),
                        Day:   parseDay(endDate),
                },
        }

        req := &amp;playdeveloperreporting.GooglePlayDeveloperReportingV1beta1QueryErrorCountMetricSetRequest{
                TimelineSpec: timelineSpec,
                PageSize:     pageSize,
        }
        if len(dimensions) &gt; 0 </span><span class="cov0" title="0">{
                req.Dimensions = dimensions
        }</span>
        <span class="cov0" title="0">if pageToken != "" </span><span class="cov0" title="0">{
                req.PageToken = pageToken
        }</span>

        <span class="cov0" title="0">startToken := pageToken
        nextToken := ""
        var rows []map[string]interface{}
        for </span><span class="cov0" title="0">{
                resp, err := reporting.Vitals.Errors.Counts.Query(appName, req).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.outputReportingQueryError(err, "failed to query error counts")
                }</span>
                <span class="cov0" title="0">for _, row := range resp.Rows </span><span class="cov0" title="0">{
                        rowData := map[string]interface{}{
                                "startTime": row.StartTime,
                        }
                        for _, m := range row.Metrics </span><span class="cov0" title="0">{
                                if m.DecimalValue != nil </span><span class="cov0" title="0">{
                                        rowData[m.Metric] = m.DecimalValue.Value
                                }</span>
                        }
                        <span class="cov0" title="0">for _, d := range row.Dimensions </span><span class="cov0" title="0">{
                                rowData[d.Dimension] = d.StringValue
                        }</span>
                        <span class="cov0" title="0">rows = append(rows, rowData)</span>
                }
                <span class="cov0" title="0">nextToken = resp.NextPageToken
                if nextToken == "" || !all </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">req.PageToken = nextToken</span>
        }

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "startDate":     startDate,
                "endDate":       endDate,
                "dimensions":    dimensions,
                "package":       c.packageName,
                "rows":          rows,
                "rowCount":      len(rows),
                "nextPageToken": nextToken,
        })
        result.WithPagination(startToken, nextToken)
        return c.Output(result.WithServices("playdeveloperreporting"))</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package cli

import (
        "context"
        stdErrors "errors"
        "fmt"
        "net/http"
        "strings"

        "google.golang.org/api/googleapi"
        playdeveloperreporting "google.golang.org/api/playdeveloperreporting/v1beta1"

        "github.com/dl-alexandre/gpd/internal/errors"
        "github.com/dl-alexandre/gpd/internal/output"
)

func (c *CLI) outputReportingQueryError(err error, message string) error <span class="cov0" title="0">{
        apiErr := errors.ClassifyAuthError(err)
        if apiErr == nil </span><span class="cov0" title="0">{
                apiErr = errors.NewAPIError(errors.CodeGeneralError, fmt.Sprintf("%s: %v", message, err))
        }</span> else<span class="cov0" title="0"> {
                errMessage := apiErr.Message
                if errMessage == "" </span><span class="cov0" title="0">{
                        errMessage = err.Error()
                }</span>
                <span class="cov0" title="0">apiErr = errors.NewAPIError(apiErr.Code, fmt.Sprintf("%s: %s", message, errMessage)).
                        WithHTTPStatus(apiErr.HTTPStatus).
                        WithDetails(apiErr.Details).
                        WithHint(apiErr.Hint)</span>
        }

        <span class="cov0" title="0">var gapiErr *googleapi.Error
        if stdErrors.As(err, &amp;gapiErr) &amp;&amp; gapiErr.Code == http.StatusNotFound </span><span class="cov0" title="0">{
                apiErr = apiErr.WithHint("Play Developer Reporting API may be disabled or unavailable for this app. Enable the API and confirm the package has reporting data.")
        }</span>
        <span class="cov0" title="0">if strings.Contains(apiErr.Message, "Error 404") || strings.Contains(apiErr.Message, "Not Found") </span><span class="cov0" title="0">{
                apiErr = apiErr.WithHint("Play Developer Reporting API may be disabled or unavailable for this app. Enable the API and confirm the package has reporting data.")
        }</span>

        <span class="cov0" title="0">result := output.NewErrorResult(apiErr).WithServices("playdeveloperreporting")
        return c.Output(result)</span>
}

func validateReportingDates(startDate, endDate string) *errors.APIError <span class="cov0" title="0">{
        if strings.TrimSpace(startDate) == "" || strings.TrimSpace(endDate) == "" </span><span class="cov0" title="0">{
                return errors.NewAPIError(errors.CodeValidationError, "start-date and end-date are required").
                        WithHint("Provide --start-date and --end-date in ISO 8601 format")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *CLI) vitalsCrashes(ctx context.Context, startDate, endDate string, dimensions []string,
        _ string, pageSize int64, pageToken string, all bool) error <span class="cov0" title="0">{
        if apiErr := validateReportingDates(startDate, endDate); apiErr != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(apiErr).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>
        <span class="cov0" title="0">if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">reporting, err := client.PlayReporting()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">appName := fmt.Sprintf("apps/%s", c.packageName)
        timelineSpec := &amp;playdeveloperreporting.GooglePlayDeveloperReportingV1beta1TimelineSpec{
                AggregationPeriod: "DAILY",
                StartTime: &amp;playdeveloperreporting.GoogleTypeDateTime{
                        Year:  parseYear(startDate),
                        Month: parseMonth(startDate),
                        Day:   parseDay(startDate),
                },
                EndTime: &amp;playdeveloperreporting.GoogleTypeDateTime{
                        Year:  parseYear(endDate),
                        Month: parseMonth(endDate),
                        Day:   parseDay(endDate),
                },
        }

        queryReq := &amp;playdeveloperreporting.GooglePlayDeveloperReportingV1beta1QueryCrashRateMetricSetRequest{
                TimelineSpec: timelineSpec,
                PageSize:     pageSize,
        }
        if len(dimensions) &gt; 0 </span><span class="cov0" title="0">{
                queryReq.Dimensions = dimensions
        }</span>
        <span class="cov0" title="0">if pageToken != "" </span><span class="cov0" title="0">{
                queryReq.PageToken = pageToken
        }</span>

        <span class="cov0" title="0">startToken := pageToken
        nextToken := ""
        var allRows []map[string]interface{}
        for </span><span class="cov0" title="0">{
                resp, err := reporting.Vitals.Crashrate.Query(appName, queryReq).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.outputReportingQueryError(err, "failed to query crash rate")
                }</span>

                <span class="cov0" title="0">for _, row := range resp.Rows </span><span class="cov0" title="0">{
                        rowData := map[string]interface{}{
                                "startTime": row.StartTime,
                        }
                        for _, m := range row.Metrics </span><span class="cov0" title="0">{
                                if m.DecimalValue != nil </span><span class="cov0" title="0">{
                                        rowData[m.Metric] = m.DecimalValue.Value
                                }</span>
                        }
                        <span class="cov0" title="0">for _, d := range row.Dimensions </span><span class="cov0" title="0">{
                                rowData[d.Dimension] = d.StringValue
                        }</span>
                        <span class="cov0" title="0">allRows = append(allRows, rowData)</span>
                }

                <span class="cov0" title="0">nextToken = resp.NextPageToken
                if !all || nextToken == "" </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">queryReq.PageToken = nextToken</span>
        }

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "metric":        "crashRate",
                "startDate":     startDate,
                "endDate":       endDate,
                "dimensions":    dimensions,
                "package":       c.packageName,
                "rows":          allRows,
                "rowCount":      len(allRows),
                "nextPageToken": nextToken,
                "dataFreshness": map[string]interface{}{
                        "note": "Vitals data may be delayed by 24-48 hours",
                },
        })
        result.WithPagination(startToken, nextToken)
        return c.Output(result.WithServices("playdeveloperreporting"))</span>
}

func (c *CLI) vitalsANRs(ctx context.Context, startDate, endDate string, dimensions []string,
        _ string, pageSize int64, pageToken string, all bool) error <span class="cov0" title="0">{
        if apiErr := validateReportingDates(startDate, endDate); apiErr != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(apiErr).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>
        <span class="cov0" title="0">if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">reporting, err := client.PlayReporting()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">appName := fmt.Sprintf("apps/%s", c.packageName)
        timelineSpec := &amp;playdeveloperreporting.GooglePlayDeveloperReportingV1beta1TimelineSpec{
                AggregationPeriod: "DAILY",
                StartTime: &amp;playdeveloperreporting.GoogleTypeDateTime{
                        Year:  parseYear(startDate),
                        Month: parseMonth(startDate),
                        Day:   parseDay(startDate),
                },
                EndTime: &amp;playdeveloperreporting.GoogleTypeDateTime{
                        Year:  parseYear(endDate),
                        Month: parseMonth(endDate),
                        Day:   parseDay(endDate),
                },
        }

        queryReq := &amp;playdeveloperreporting.GooglePlayDeveloperReportingV1beta1QueryAnrRateMetricSetRequest{
                TimelineSpec: timelineSpec,
                PageSize:     pageSize,
        }
        if len(dimensions) &gt; 0 </span><span class="cov0" title="0">{
                queryReq.Dimensions = dimensions
        }</span>
        <span class="cov0" title="0">if pageToken != "" </span><span class="cov0" title="0">{
                queryReq.PageToken = pageToken
        }</span>

        <span class="cov0" title="0">startToken := pageToken
        nextToken := ""
        var allRows []map[string]interface{}
        for </span><span class="cov0" title="0">{
                resp, err := reporting.Vitals.Anrrate.Query(appName, queryReq).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.outputReportingQueryError(err, "failed to query ANR rate")
                }</span>

                <span class="cov0" title="0">for _, row := range resp.Rows </span><span class="cov0" title="0">{
                        rowData := map[string]interface{}{
                                "startTime": row.StartTime,
                        }
                        for _, m := range row.Metrics </span><span class="cov0" title="0">{
                                if m.DecimalValue != nil </span><span class="cov0" title="0">{
                                        rowData[m.Metric] = m.DecimalValue.Value
                                }</span>
                        }
                        <span class="cov0" title="0">for _, d := range row.Dimensions </span><span class="cov0" title="0">{
                                rowData[d.Dimension] = d.StringValue
                        }</span>
                        <span class="cov0" title="0">allRows = append(allRows, rowData)</span>
                }

                <span class="cov0" title="0">nextToken = resp.NextPageToken
                if !all || nextToken == "" </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">queryReq.PageToken = nextToken</span>
        }

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "metric":        "anrRate",
                "startDate":     startDate,
                "endDate":       endDate,
                "dimensions":    dimensions,
                "package":       c.packageName,
                "rows":          allRows,
                "rowCount":      len(allRows),
                "nextPageToken": nextToken,
                "dataFreshness": map[string]interface{}{
                        "note": "Vitals data may be delayed by 24-48 hours",
                },
        })
        result.WithPagination(startToken, nextToken)
        return c.Output(result.WithServices("playdeveloperreporting"))</span>
}

func (c *CLI) vitalsExcessiveWakeups(ctx context.Context, startDate, endDate string, dimensions []string,
        _ string, pageSize int64, pageToken string, all bool) error <span class="cov0" title="0">{
        if apiErr := validateReportingDates(startDate, endDate); apiErr != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(apiErr).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>
        <span class="cov0" title="0">if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">reporting, err := client.PlayReporting()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">appName := fmt.Sprintf("apps/%s", c.packageName)
        timelineSpec := &amp;playdeveloperreporting.GooglePlayDeveloperReportingV1beta1TimelineSpec{
                AggregationPeriod: "DAILY",
                StartTime: &amp;playdeveloperreporting.GoogleTypeDateTime{
                        Year:  parseYear(startDate),
                        Month: parseMonth(startDate),
                        Day:   parseDay(startDate),
                },
                EndTime: &amp;playdeveloperreporting.GoogleTypeDateTime{
                        Year:  parseYear(endDate),
                        Month: parseMonth(endDate),
                        Day:   parseDay(endDate),
                },
        }

        queryReq := &amp;playdeveloperreporting.GooglePlayDeveloperReportingV1beta1QueryExcessiveWakeupRateMetricSetRequest{
                TimelineSpec: timelineSpec,
                PageSize:     pageSize,
        }
        if len(dimensions) &gt; 0 </span><span class="cov0" title="0">{
                queryReq.Dimensions = dimensions
        }</span>
        <span class="cov0" title="0">if pageToken != "" </span><span class="cov0" title="0">{
                queryReq.PageToken = pageToken
        }</span>

        <span class="cov0" title="0">startToken := pageToken
        nextToken := ""
        var allRows []map[string]interface{}
        for </span><span class="cov0" title="0">{
                resp, err := reporting.Vitals.Excessivewakeuprate.Query(appName, queryReq).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.outputReportingQueryError(err, "failed to query excessive wakeups")
                }</span>

                <span class="cov0" title="0">for _, row := range resp.Rows </span><span class="cov0" title="0">{
                        rowData := map[string]interface{}{
                                "startTime": row.StartTime,
                        }
                        for _, m := range row.Metrics </span><span class="cov0" title="0">{
                                if m.DecimalValue != nil </span><span class="cov0" title="0">{
                                        rowData[m.Metric] = m.DecimalValue.Value
                                }</span>
                        }
                        <span class="cov0" title="0">for _, d := range row.Dimensions </span><span class="cov0" title="0">{
                                rowData[d.Dimension] = d.StringValue
                        }</span>
                        <span class="cov0" title="0">allRows = append(allRows, rowData)</span>
                }

                <span class="cov0" title="0">nextToken = resp.NextPageToken
                if !all || nextToken == "" </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">queryReq.PageToken = nextToken</span>
        }

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "metric":        "excessiveWakeups",
                "startDate":     startDate,
                "endDate":       endDate,
                "dimensions":    dimensions,
                "package":       c.packageName,
                "rows":          allRows,
                "rowCount":      len(allRows),
                "nextPageToken": nextToken,
        })
        result.WithPagination(startToken, nextToken)
        return c.Output(result.WithServices("playdeveloperreporting"))</span>
}

func (c *CLI) vitalsLmkRate(_ context.Context, startDate, endDate string, _ []string,
        _ string, _ int64, _ string, _ bool) error <span class="cov0" title="0">{
        if apiErr := validateReportingDates(startDate, endDate); apiErr != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(apiErr).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>
        <span class="cov0" title="0">result := output.NewErrorResult(errors.NewAPIError(errors.CodeGeneralError,
                "LMK rate metric is not available in the Play Developer Reporting API. "+
                        "Please use other available metrics such as crashRate, anrRate, excessiveWakeups, etc.")).
                WithServices("playdeveloperreporting")
        return c.Output(result)</span>
}

func (c *CLI) vitalsSlowRendering(ctx context.Context, startDate, endDate string, dimensions []string,
        _ string, pageSize int64, pageToken string, all bool) error <span class="cov0" title="0">{
        if apiErr := validateReportingDates(startDate, endDate); apiErr != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(apiErr).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>
        <span class="cov0" title="0">if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">reporting, err := client.PlayReporting()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">appName := fmt.Sprintf("apps/%s", c.packageName)
        timelineSpec := &amp;playdeveloperreporting.GooglePlayDeveloperReportingV1beta1TimelineSpec{
                AggregationPeriod: "DAILY",
                StartTime: &amp;playdeveloperreporting.GoogleTypeDateTime{
                        Year:  parseYear(startDate),
                        Month: parseMonth(startDate),
                        Day:   parseDay(startDate),
                },
                EndTime: &amp;playdeveloperreporting.GoogleTypeDateTime{
                        Year:  parseYear(endDate),
                        Month: parseMonth(endDate),
                        Day:   parseDay(endDate),
                },
        }

        queryReq := &amp;playdeveloperreporting.GooglePlayDeveloperReportingV1beta1QuerySlowRenderingRateMetricSetRequest{
                TimelineSpec: timelineSpec,
                PageSize:     pageSize,
        }
        if len(dimensions) &gt; 0 </span><span class="cov0" title="0">{
                queryReq.Dimensions = dimensions
        }</span>
        <span class="cov0" title="0">if pageToken != "" </span><span class="cov0" title="0">{
                queryReq.PageToken = pageToken
        }</span>

        <span class="cov0" title="0">startToken := pageToken
        nextToken := ""
        var allRows []map[string]interface{}
        for </span><span class="cov0" title="0">{
                resp, err := reporting.Vitals.Slowrenderingrate.Query(appName, queryReq).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.outputReportingQueryError(err, "failed to query slow rendering")
                }</span>

                <span class="cov0" title="0">for _, row := range resp.Rows </span><span class="cov0" title="0">{
                        rowData := map[string]interface{}{
                                "startTime": row.StartTime,
                        }
                        for _, m := range row.Metrics </span><span class="cov0" title="0">{
                                if m.DecimalValue != nil </span><span class="cov0" title="0">{
                                        rowData[m.Metric] = m.DecimalValue.Value
                                }</span>
                        }
                        <span class="cov0" title="0">for _, d := range row.Dimensions </span><span class="cov0" title="0">{
                                rowData[d.Dimension] = d.StringValue
                        }</span>
                        <span class="cov0" title="0">allRows = append(allRows, rowData)</span>
                }

                <span class="cov0" title="0">nextToken = resp.NextPageToken
                if !all || nextToken == "" </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">queryReq.PageToken = nextToken</span>
        }

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "metric":        "slowRendering",
                "startDate":     startDate,
                "endDate":       endDate,
                "dimensions":    dimensions,
                "package":       c.packageName,
                "rows":          allRows,
                "rowCount":      len(allRows),
                "nextPageToken": nextToken,
        })
        result.WithPagination(startToken, nextToken)
        return c.Output(result.WithServices("playdeveloperreporting"))</span>
}

func (c *CLI) vitalsSlowStart(ctx context.Context, startDate, endDate string, dimensions []string,
        _ string, pageSize int64, pageToken string, all bool) error <span class="cov0" title="0">{
        if apiErr := validateReportingDates(startDate, endDate); apiErr != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(apiErr).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>
        <span class="cov0" title="0">if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">reporting, err := client.PlayReporting()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">appName := fmt.Sprintf("apps/%s", c.packageName)
        timelineSpec := &amp;playdeveloperreporting.GooglePlayDeveloperReportingV1beta1TimelineSpec{
                AggregationPeriod: "DAILY",
                StartTime: &amp;playdeveloperreporting.GoogleTypeDateTime{
                        Year:  parseYear(startDate),
                        Month: parseMonth(startDate),
                        Day:   parseDay(startDate),
                },
                EndTime: &amp;playdeveloperreporting.GoogleTypeDateTime{
                        Year:  parseYear(endDate),
                        Month: parseMonth(endDate),
                        Day:   parseDay(endDate),
                },
        }

        queryReq := &amp;playdeveloperreporting.GooglePlayDeveloperReportingV1beta1QuerySlowStartRateMetricSetRequest{
                TimelineSpec: timelineSpec,
                PageSize:     pageSize,
        }
        if len(dimensions) &gt; 0 </span><span class="cov0" title="0">{
                queryReq.Dimensions = dimensions
        }</span>
        <span class="cov0" title="0">if pageToken != "" </span><span class="cov0" title="0">{
                queryReq.PageToken = pageToken
        }</span>

        <span class="cov0" title="0">startToken := pageToken
        nextToken := ""
        var allRows []map[string]interface{}
        for </span><span class="cov0" title="0">{
                resp, err := reporting.Vitals.Slowstartrate.Query(appName, queryReq).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.outputReportingQueryError(err, "failed to query slow start")
                }</span>

                <span class="cov0" title="0">for _, row := range resp.Rows </span><span class="cov0" title="0">{
                        rowData := map[string]interface{}{
                                "startTime": row.StartTime,
                        }
                        for _, m := range row.Metrics </span><span class="cov0" title="0">{
                                if m.DecimalValue != nil </span><span class="cov0" title="0">{
                                        rowData[m.Metric] = m.DecimalValue.Value
                                }</span>
                        }
                        <span class="cov0" title="0">for _, d := range row.Dimensions </span><span class="cov0" title="0">{
                                rowData[d.Dimension] = d.StringValue
                        }</span>
                        <span class="cov0" title="0">allRows = append(allRows, rowData)</span>
                }

                <span class="cov0" title="0">nextToken = resp.NextPageToken
                if !all || nextToken == "" </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">queryReq.PageToken = nextToken</span>
        }

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "metric":        "slowStart",
                "startDate":     startDate,
                "endDate":       endDate,
                "dimensions":    dimensions,
                "package":       c.packageName,
                "rows":          allRows,
                "rowCount":      len(allRows),
                "nextPageToken": nextToken,
        })
        result.WithPagination(startToken, nextToken)
        return c.Output(result.WithServices("playdeveloperreporting"))</span>
}

func (c *CLI) vitalsStuckWakelocks(ctx context.Context, startDate, endDate string, dimensions []string,
        _ string, pageSize int64, pageToken string, all bool) error <span class="cov0" title="0">{
        if apiErr := validateReportingDates(startDate, endDate); apiErr != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(apiErr).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>
        <span class="cov0" title="0">if err := c.requirePackage(); err != nil </span><span class="cov0" title="0">{
                result := output.NewErrorResult(err.(*errors.APIError)).WithServices("playdeveloperreporting")
                return c.Output(result)
        }</span>

        <span class="cov0" title="0">client, err := c.getAPIClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(err.(*errors.APIError))
        }</span>

        <span class="cov0" title="0">reporting, err := client.PlayReporting()
        if err != nil </span><span class="cov0" title="0">{
                return c.OutputError(errors.NewAPIError(errors.CodeGeneralError, err.Error()))
        }</span>

        <span class="cov0" title="0">appName := fmt.Sprintf("apps/%s", c.packageName)
        timelineSpec := &amp;playdeveloperreporting.GooglePlayDeveloperReportingV1beta1TimelineSpec{
                AggregationPeriod: "DAILY",
                StartTime: &amp;playdeveloperreporting.GoogleTypeDateTime{
                        Year:  parseYear(startDate),
                        Month: parseMonth(startDate),
                        Day:   parseDay(startDate),
                },
                EndTime: &amp;playdeveloperreporting.GoogleTypeDateTime{
                        Year:  parseYear(endDate),
                        Month: parseMonth(endDate),
                        Day:   parseDay(endDate),
                },
        }

        queryReq := &amp;playdeveloperreporting.GooglePlayDeveloperReportingV1beta1QueryStuckBackgroundWakelockRateMetricSetRequest{
                TimelineSpec: timelineSpec,
                PageSize:     pageSize,
        }
        if len(dimensions) &gt; 0 </span><span class="cov0" title="0">{
                queryReq.Dimensions = dimensions
        }</span>
        <span class="cov0" title="0">if pageToken != "" </span><span class="cov0" title="0">{
                queryReq.PageToken = pageToken
        }</span>

        <span class="cov0" title="0">startToken := pageToken
        nextToken := ""
        var allRows []map[string]interface{}
        for </span><span class="cov0" title="0">{
                resp, err := reporting.Vitals.Stuckbackgroundwakelockrate.Query(appName, queryReq).Context(ctx).Do()
                if err != nil </span><span class="cov0" title="0">{
                        return c.outputReportingQueryError(err, "failed to query stuck wakelocks")
                }</span>

                <span class="cov0" title="0">for _, row := range resp.Rows </span><span class="cov0" title="0">{
                        rowData := map[string]interface{}{
                                "startTime": row.StartTime,
                        }
                        for _, m := range row.Metrics </span><span class="cov0" title="0">{
                                if m.DecimalValue != nil </span><span class="cov0" title="0">{
                                        rowData[m.Metric] = m.DecimalValue.Value
                                }</span>
                        }
                        <span class="cov0" title="0">for _, d := range row.Dimensions </span><span class="cov0" title="0">{
                                rowData[d.Dimension] = d.StringValue
                        }</span>
                        <span class="cov0" title="0">allRows = append(allRows, rowData)</span>
                }

                <span class="cov0" title="0">nextToken = resp.NextPageToken
                if !all || nextToken == "" </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">queryReq.PageToken = nextToken</span>
        }

        <span class="cov0" title="0">result := output.NewResult(map[string]interface{}{
                "metric":        "stuckWakelocks",
                "startDate":     startDate,
                "endDate":       endDate,
                "dimensions":    dimensions,
                "package":       c.packageName,
                "rows":          allRows,
                "rowCount":      len(allRows),
                "nextPageToken": nextToken,
        })
        result.WithPagination(startToken, nextToken)
        return c.Output(result.WithServices("playdeveloperreporting"))</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Package config provides configuration management for gpd.
package config

import (
        "encoding/json"
        "os"
        "path/filepath"
        "runtime"
        "strings"
)

// Config represents the gpd configuration.
type Config struct {
        DefaultPackage        string            `json:"defaultPackage,omitempty"`
        ServiceAccountKeyPath string            `json:"serviceAccountKeyPath,omitempty"`
        CredentialOrigin      string            `json:"credentialOrigin,omitempty"` // "adc", "keyfile", "env"
        OutputFormat          string            `json:"outputFormat,omitempty"`
        TimeoutSeconds        int               `json:"timeoutSeconds,omitempty"`
        StoreTokens           string            `json:"storeTokens,omitempty"` // "auto", "never", "secure"
        RateLimits            map[string]string `json:"rateLimits,omitempty"`
        TesterLimits          *TesterLimits     `json:"testerLimits,omitempty"`
        ActiveProfile         string            `json:"activeProfile,omitempty"`
}

// TesterLimits defines limits for different tester types.
type TesterLimits struct {
        Internal int `json:"internal"` // Default: 200
        Alpha    int `json:"alpha"`    // Default: -1 (unlimited)
        Beta     int `json:"beta"`     // Default: -1 (unlimited)
}

// DefaultTesterLimits returns the default tester limits.
func DefaultTesterLimits() *TesterLimits <span class="cov6" title="8">{
        return &amp;TesterLimits{
                Internal: 200,
                Alpha:    -1,
                Beta:     -1,
        }
}</span>

// Paths contains OS-specific configuration paths.
type Paths struct {
        ConfigDir  string
        CacheDir   string
        ConfigFile string
}

var runtimeGOOS = runtime.GOOS
var jsonMarshalIndent = json.MarshalIndent
var osMkdirAll = os.MkdirAll
var osWriteFile = os.WriteFile

func getHomeDirForOS(goos string) string <span class="cov10" title="34">{
        if home := os.Getenv("HOME"); home != "" </span><span class="cov10" title="34">{
                return home
        }</span>
        <span class="cov0" title="0">if goos == "windows" </span><span class="cov0" title="0">{
                if home := os.Getenv("USERPROFILE"); home != "" </span><span class="cov0" title="0">{
                        return home
                }</span>
                <span class="cov0" title="0">if drive, path := os.Getenv("HOMEDRIVE"), os.Getenv("HOMEPATH"); drive != "" &amp;&amp; path != "" </span><span class="cov0" title="0">{
                        return drive + path
                }</span>
        }
        <span class="cov0" title="0">home, _ := os.UserHomeDir()
        return home</span>
}

// GetPaths returns the OS-appropriate configuration paths.
func GetPaths() Paths <span class="cov9" title="28">{
        return getPathsForOS(runtimeGOOS)
}</span>

func getPathsForOS(goos string) Paths <span class="cov9" title="31">{
        var configDir, cacheDir string

        switch goos </span>{
        case "darwin":<span class="cov9" title="28">
                home := getHomeDirForOS(goos)
                configDir = filepath.Join(home, "Library", "Application Support", "gpd")
                cacheDir = filepath.Join(home, "Library", "Caches", "gpd")</span>
        case "windows":<span class="cov1" title="1">
                appData := os.Getenv("APPDATA")
                localAppData := os.Getenv("LOCALAPPDATA")
                if appData == "" || localAppData == "" </span><span class="cov0" title="0">{
                        home := getHomeDirForOS(goos)
                        if appData == "" &amp;&amp; home != "" </span><span class="cov0" title="0">{
                                appData = filepath.Join(home, "AppData", "Roaming")
                        }</span>
                        <span class="cov0" title="0">if localAppData == "" &amp;&amp; home != "" </span><span class="cov0" title="0">{
                                localAppData = filepath.Join(home, "AppData", "Local")
                        }</span>
                }
                <span class="cov1" title="1">configDir = filepath.Join(appData, "gpd")
                cacheDir = filepath.Join(localAppData, "gpd")</span>
        default:<span class="cov2" title="2">
                home := getHomeDirForOS(goos)
                if xdgConfig := os.Getenv("XDG_CONFIG_HOME"); xdgConfig != "" </span><span class="cov1" title="1">{
                        configDir = filepath.Join(xdgConfig, "gpd")
                }</span> else<span class="cov1" title="1"> {
                        configDir = filepath.Join(home, ".config", "gpd")
                }</span>
                <span class="cov2" title="2">if xdgCache := os.Getenv("XDG_CACHE_HOME"); xdgCache != "" </span><span class="cov1" title="1">{
                        cacheDir = filepath.Join(xdgCache, "gpd")
                }</span> else<span class="cov1" title="1"> {
                        cacheDir = filepath.Join(home, ".cache", "gpd")
                }</span>
        }

        <span class="cov9" title="31">return Paths{
                ConfigDir:  configDir,
                CacheDir:   cacheDir,
                ConfigFile: filepath.Join(configDir, "config.json"),
        }</span>
}

// GetLegacyConfigDir returns the legacy ~/.gpd directory path.
func GetLegacyConfigDir() string <span class="cov4" title="4">{
        home := getHomeDirForOS(runtimeGOOS)
        return filepath.Join(home, ".gpd")
}</span>

// Load loads the configuration from the config file.
func Load() (*Config, error) <span class="cov3" title="3">{
        paths := GetPaths()

        // Try primary config location
        cfg, err := loadFromFile(paths.ConfigFile)
        if err == nil </span><span class="cov1" title="1">{
                return cfg, nil
        }</span>

        // Try legacy location
        <span class="cov2" title="2">legacyConfig := filepath.Join(GetLegacyConfigDir(), "config.json")
        cfg, err = loadFromFile(legacyConfig)
        if err == nil </span><span class="cov1" title="1">{
                return cfg, nil
        }</span>

        // Return default config
        <span class="cov1" title="1">return DefaultConfig(), nil</span>
}

func loadFromFile(path string) (*Config, error) <span class="cov5" title="6">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov3" title="3">{
                return nil, err
        }</span>

        <span class="cov3" title="3">var cfg Config
        if err := json.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov2" title="2">return &amp;cfg, nil</span>
}

// Save saves the configuration to the config file.
func (c *Config) Save() error <span class="cov6" title="9">{
        paths := GetPaths()

        // Ensure config directory exists
        if err := osMkdirAll(paths.ConfigDir, 0700); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="8">data, err := jsonMarshalIndent(c, "", "  ")
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov5" title="7">return osWriteFile(paths.ConfigFile, data, 0600)</span>
}

// DefaultConfig returns the default configuration.
func DefaultConfig() *Config <span class="cov5" title="7">{
        return &amp;Config{
                OutputFormat:   "json",
                TimeoutSeconds: 30,
                StoreTokens:    "auto",
                TesterLimits:   DefaultTesterLimits(),
                RateLimits: map[string]string{
                        "reviews.reply": "5s",
                },
        }
}</span>

// DetectCI returns true if running in a CI environment.
func DetectCI() bool <span class="cov3" title="3">{
        ciVars := []string{
                "CI",
                "GITHUB_ACTIONS",
                "JENKINS_URL",
                "BUILDKITE",
                "CIRCLECI",
                "TRAVIS",
                "GITLAB_CI",
                "GPD_CI",
        }
        for _, env := range ciVars </span><span class="cov7" title="11">{
                if os.Getenv(env) != "" </span><span class="cov2" title="2">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}

// Environment variable names for gpd configuration.
const (
        EnvServiceAccountKey = "GPD_SERVICE_ACCOUNT_KEY"
        EnvOAuthClientID     = "GPD_CLIENT_ID"
        EnvOAuthClientSecret = "GPD_CLIENT_SECRET" //nolint:gosec // G101: This is an env var name, not credentials
        EnvPackage           = "GPD_PACKAGE"
        EnvAuthProfile       = "GPD_AUTH_PROFILE"
        EnvTimeout           = "GPD_TIMEOUT"
        EnvStoreTokens       = "GPD_STORE_TOKENS" //nolint:gosec // G101: This is an env var name, not credentials
        EnvCI                = "GPD_CI"
)

// GetEnvServiceAccountKey returns the service account key from environment.
func GetEnvServiceAccountKey() string <span class="cov1" title="1">{
        return os.Getenv(EnvServiceAccountKey)
}</span>

func GetEnvOAuthClientID() string <span class="cov0" title="0">{
        return os.Getenv(EnvOAuthClientID)
}</span>

func GetEnvOAuthClientSecret() string <span class="cov0" title="0">{
        return os.Getenv(EnvOAuthClientSecret)
}</span>

// GetEnvPackage returns the default package from environment.
func GetEnvPackage() string <span class="cov1" title="1">{
        return os.Getenv(EnvPackage)
}</span>

func GetEnvAuthProfile() string <span class="cov0" title="0">{
        return os.Getenv(EnvAuthProfile)
}</span>

// GetEnvTimeout returns the timeout from environment.
func GetEnvTimeout() string <span class="cov1" title="1">{
        return os.Getenv(EnvTimeout)
}</span>

// GetEnvStoreTokens returns the store tokens setting from environment.
func GetEnvStoreTokens() string <span class="cov1" title="1">{
        return os.Getenv(EnvStoreTokens)
}</span>

// ValidTracks returns the list of valid track names.
func ValidTracks() []string <span class="cov6" title="9">{
        return []string{"internal", "alpha", "beta", "production"}
}</span>

// IsValidTrack checks if a track name is valid.
func IsValidTrack(track string) bool <span class="cov6" title="8">{
        track = strings.ToLower(track)
        for _, t := range ValidTracks() </span><span class="cov9" title="26">{
                if t == track </span><span class="cov4" title="4">{
                        return true
                }</span>
        }
        <span class="cov4" title="4">return false</span>
}

// NormalizeLocale converts locale codes from en_US to en-US format.
func NormalizeLocale(locale string) string <span class="cov5" title="6">{
        return strings.ReplaceAll(locale, "_", "-")
}</span>

// InitProject initializes a new project configuration.
func InitProject(dir string) error <span class="cov5" title="7">{
        paths := GetPaths()

        // Create config directory
        if err := osMkdirAll(paths.ConfigDir, 0700); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Create cache directory
        <span class="cov5" title="6">if err := osMkdirAll(paths.CacheDir, 0700); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Create default config
        <span class="cov5" title="5">cfg := DefaultConfig()
        if err := cfg.Save(); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Create assets directory structure
        <span class="cov4" title="4">assetsDir := filepath.Join(dir, "assets")
        for _, locale := range []string{"en-US"} </span><span class="cov4" title="4">{
                for _, category := range []string{"phone", "tablet", "tv", "wear"} </span><span class="cov7" title="13">{
                        catDir := filepath.Join(assetsDir, locale, category)
                        if err := osMkdirAll(catDir, 0755); err != nil </span><span class="cov1" title="1">{
                                return err
                        }</span>
                }
        }

        // Create sample release-notes.json
        <span class="cov3" title="3">releaseNotes := map[string]string{
                "en-US": "Bug fixes and improvements.",
        }
        rnData, _ := json.MarshalIndent(releaseNotes, "", "  ")
        if err := osWriteFile(filepath.Join(dir, "release-notes.json"), rnData, 0644); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Create .gitignore
        <span class="cov2" title="2">gitignore := `# gpd sensitive files
*.json.key
service-account*.json
.gpd/
`
        if err := osWriteFile(filepath.Join(dir, ".gitignore"), []byte(gitignore), 0644); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package edits

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "runtime"
        "strings"
        "sync"
        "time"

        "golang.org/x/sync/errgroup"

        "github.com/dl-alexandre/gpd/internal/config"
        "github.com/dl-alexandre/gpd/internal/errors"
)

// Edit represents an edit transaction.
type Edit struct {
        Handle      string    `json:"handle"`   // Local name from --edit-id
        ServerID    string    `json:"serverId"` // Actual edit ID from Google
        PackageName string    `json:"packageName"`
        CreatedAt   time.Time `json:"createdAt"`
        LastUsedAt  time.Time `json:"lastUsedAt"`
        State       EditState `json:"state"`
}

// EditState represents the state of an edit.
type EditState string

const (
        StateDraft      EditState = "draft"
        StateValidating EditState = "validating"
        StateCommitted  EditState = "committed"
        StateAborted    EditState = "aborted"
)

type Manager struct {
        editsDir   string
        cacheDir   string
        mu         sync.RWMutex
        lockFiles  map[string]*LockFile
        Idempotent *IdempotencyStore
}

func NewManager() *Manager <span class="cov1" title="1">{
        paths := config.GetPaths()
        return &amp;Manager{
                editsDir:   filepath.Join(paths.ConfigDir, "edits"),
                cacheDir:   filepath.Join(paths.CacheDir, "artifacts"),
                lockFiles:  make(map[string]*LockFile),
                Idempotent: NewIdempotencyStore(),
        }
}</span>

// LockFile represents a file lock for concurrent access protection.
type LockFile struct {
        PID       int       `json:"pid"`
        Hostname  string    `json:"hostname"`
        CreatedAt time.Time `json:"createdAt"`
        Command   string    `json:"command"`
        Heartbeat time.Time `json:"heartbeat,omitempty"`
}

const (
        lockTimeout      = 30 * time.Second
        staleLockAge     = 4 * time.Hour
        lockPollInterval = 100 * time.Millisecond
        editTTL          = 7 * 24 * time.Hour
        editIdleTTL      = 1 * time.Hour
)

// AcquireLock acquires a lock for the given package.
func (m *Manager) AcquireLock(ctx context.Context, packageName string) error <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if err := os.MkdirAll(m.editsDir, 0700); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">lockPath := filepath.Join(m.editsDir, packageName+".lock")
        hostname, err := os.Hostname()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">lockData := &amp;LockFile{
                PID:       os.Getpid(),
                Hostname:  hostname,
                CreatedAt: time.Now(),
                Command:   os.Args[0],
        }

        deadline := time.Now().Add(lockTimeout)
        for time.Now().Before(deadline) </span><span class="cov1" title="1">{
                // Try to create lock file atomically
                if m.tryAcquireLock(lockPath, lockData, hostname) </span><span class="cov1" title="1">{
                        m.lockFiles[packageName] = lockData
                        return nil
                }</span>

                <span class="cov0" title="0">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-time.After(lockPollInterval):<span class="cov0" title="0">
                        continue</span>
                }
        }

        <span class="cov0" title="0">return errors.ErrFileLockTimeout</span>
}

func (m *Manager) tryAcquireLock(lockPath string, newLock *LockFile, hostname string) bool <span class="cov1" title="1">{
        // Check existing lock
        data, err := os.ReadFile(lockPath)
        if err == nil </span><span class="cov0" title="0">{
                var existing LockFile
                if json.Unmarshal(data, &amp;existing) == nil </span><span class="cov0" title="0">{
                        // Check if lock is stale
                        if m.isLockStale(&amp;existing, hostname) </span><span class="cov0" title="0">{
                                // Remove stale lock
                                if err := os.Remove(lockPath); err != nil </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return false
                        }</span>
                }
        }

        // Try to create new lock atomically
        <span class="cov1" title="1">lockData, err := json.Marshal(newLock)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov1" title="1">f, err := os.OpenFile(lockPath, os.O_CREATE|os.O_EXCL|os.O_WRONLY, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov1" title="1">_, err = f.Write(lockData)
        if err != nil </span><span class="cov0" title="0">{
                if closeErr := f.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">return false</span>
        }
        <span class="cov1" title="1">if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov1" title="1">return true</span>
}

func (m *Manager) isLockStale(lock *LockFile, currentHostname string) bool <span class="cov3" title="3">{
        // Different hostname AND old enough
        if lock.Hostname != currentHostname &amp;&amp; time.Since(lock.CreatedAt) &gt; staleLockAge </span><span class="cov1" title="1">{
                return true
        }</span>

        // Same hostname but process is dead
        <span class="cov2" title="2">if lock.Hostname == currentHostname &amp;&amp; !isProcessAlive(lock.PID) </span><span class="cov1" title="1">{
                return true
        }</span>

        <span class="cov1" title="1">return false</span>
}

// isProcessAlive checks if a process is still running (best effort).
func isProcessAlive(pid int) bool <span class="cov3" title="3">{
        process, err := os.FindProcess(pid)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        // On Unix, FindProcess always succeeds, so we need to send signal 0
        // On Windows, FindProcess fails if process doesn't exist
        <span class="cov3" title="3">err = process.Signal(os.Signal(nil))
        return err == nil</span>
}

// ReleaseLock releases the lock for the given package.
func (m *Manager) ReleaseLock(packageName string) error <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        lockPath := filepath.Join(m.editsDir, packageName+".lock")
        delete(m.lockFiles, packageName)
        return os.Remove(lockPath)
}</span>

func (m *Manager) SaveEdit(edit *Edit) error <span class="cov6" title="14">{
        if err := os.MkdirAll(m.editsDir, 0700); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="13">path := m.editPath(edit.PackageName, edit.Handle)
        data, err := json.MarshalIndent(edit, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="13">return os.WriteFile(path, data, 0600)</span>
}

func (m *Manager) LoadEdit(packageName, handle string) (*Edit, error) <span class="cov6" title="12">{
        path := m.editPath(packageName, handle)
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov4" title="4">{
                if os.IsNotExist(err) </span><span class="cov4" title="4">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov5" title="8">var edit Edit
        if err := json.Unmarshal(data, &amp;edit); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="8">return &amp;edit, nil</span>
}

func (m *Manager) DeleteEdit(packageName, handle string) error <span class="cov1" title="1">{
        path := m.editPath(packageName, handle)
        return os.Remove(path)
}</span>

func (m *Manager) ListEdits(packageName string) ([]*Edit, error) <span class="cov3" title="3">{
        if err := os.MkdirAll(m.editsDir, 0700); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov2" title="2">pattern := filepath.Join(m.editsDir, m.editPrefix(packageName)+"*.json")
        matches, err := filepath.Glob(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">var editsList []*Edit
        for _, path := range matches </span><span class="cov3" title="3">{
                data, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov3" title="3">var edit Edit
                if json.Unmarshal(data, &amp;edit) != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov3" title="3">editsList = append(editsList, &amp;edit)</span>
        }
        <span class="cov2" title="2">return editsList, nil</span>
}

func (m *Manager) UpdateEditState(packageName, handle string, state EditState) (*Edit, error) <span class="cov3" title="3">{
        edit, err := m.LoadEdit(packageName, handle)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="3">if edit == nil </span><span class="cov1" title="1">{
                return nil, errors.NewAPIError(errors.CodeNotFound, "edit not found")
        }</span>
        <span class="cov2" title="2">edit.State = state
        edit.LastUsedAt = time.Now()
        if err := m.SaveEdit(edit); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="2">return edit, nil</span>
}

func (m *Manager) TouchEdit(packageName, handle string) (*Edit, error) <span class="cov3" title="3">{
        edit, err := m.LoadEdit(packageName, handle)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="3">if edit == nil </span><span class="cov1" title="1">{
                return nil, errors.NewAPIError(errors.CodeNotFound, "edit not found")
        }</span>
        <span class="cov2" title="2">edit.LastUsedAt = time.Now()
        if err := m.SaveEdit(edit); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="2">return edit, nil</span>
}

func (m *Manager) IsEditExpired(edit *Edit, now time.Time) bool <span class="cov3" title="3">{
        if edit == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov3" title="3">if now.Sub(edit.CreatedAt) &gt; editTTL </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov2" title="2">if now.Sub(edit.LastUsedAt) &gt; editIdleTTL </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov1" title="1">return false</span>
}

func (m *Manager) editPath(packageName, handle string) string <span class="cov8" title="27">{
        return filepath.Join(m.editsDir, m.editPrefix(packageName)+m.sanitizeHandle(handle)+".json")
}</span>

func (m *Manager) editPrefix(packageName string) string <span class="cov8" title="30">{
        return m.sanitizeHandle(packageName) + "_"
}</span>

func (m *Manager) sanitizeHandle(handle string) string <span class="cov10" title="59">{
        if handle == "" </span><span class="cov1" title="1">{
                handle = "default"
        }</span>
        <span class="cov10" title="59">replacer := strings.NewReplacer("/", "_", "\\", "_", ":", "_")
        return replacer.Replace(handle)</span>
}

// CacheEntry represents a cached artifact entry.
type CacheEntry struct {
        SHA256    string    `json:"sha256"`
        Path      string    `json:"path"`
        Size      int64     `json:"size"`
        CachedAt  time.Time `json:"cachedAt"`
        ExpiresAt time.Time `json:"expiresAt"`
}

const cacheTTL = 24 * time.Hour

const (
        largeFileThreshold = 100 * 1024 * 1024
        hashBufferSize     = 64 * 1024
)

type ProgressCallback func(bytesProcessed, totalBytes int64)

func (m *Manager) GetCachedArtifactByHash(packageName, hash string) (*CacheEntry, error) <span class="cov6" title="10">{
        cachePath := filepath.Join(m.cacheDir, packageName, hash+".json")
        data, err := os.ReadFile(cachePath)
        if err != nil </span><span class="cov1" title="1">{
                if os.IsNotExist(err) </span><span class="cov1" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov5" title="9">var entry CacheEntry
        if err := json.Unmarshal(data, &amp;entry); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="8">if time.Now().After(entry.ExpiresAt) </span><span class="cov1" title="1">{
                if err := os.Remove(cachePath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">return nil, nil</span>
        }

        <span class="cov5" title="7">return &amp;entry, nil</span>
}

func (m *Manager) CacheArtifactWithHash(packageName, artifactPath, hash string, versionCode int64) error <span class="cov5" title="9">{
        cacheDir := filepath.Join(m.cacheDir, packageName)
        if err := os.MkdirAll(cacheDir, 0700); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="9">info, err := os.Stat(artifactPath)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov5" title="8">entry := &amp;CacheEntry{
                SHA256:    hash,
                Path:      artifactPath,
                Size:      info.Size(),
                CachedAt:  time.Now(),
                ExpiresAt: time.Now().Add(cacheTTL),
        }

        data, err := json.MarshalIndent(entry, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="8">cachePath := filepath.Join(cacheDir, hash+".json")
        return os.WriteFile(cachePath, data, 0600)</span>
}

func (m *Manager) CleanExpiredCache() error <span class="cov1" title="1">{
        return m.CleanExpiredCacheWithContext(context.Background())
}</span>

func (m *Manager) CleanExpiredCacheWithContext(ctx context.Context) error <span class="cov4" title="4">{
        var paths []string
        err := filepath.Walk(m.cacheDir, func(path string, info os.FileInfo, err error) error </span><span class="cov6" title="10">{
                if err != nil </span><span class="cov1" title="1">{
                        return nil
                }</span>
                <span class="cov5" title="9">if info.IsDir() || filepath.Ext(path) != ".json" </span><span class="cov4" title="5">{
                        return nil
                }</span>
                <span class="cov4" title="4">paths = append(paths, path)
                return nil</span>
        })
        <span class="cov4" title="4">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="4">if len(paths) == 0 </span><span class="cov2" title="2">{
                return nil
        }</span>

        <span class="cov2" title="2">workers := runtime.GOMAXPROCS(0)
        if workers &gt; 4 </span><span class="cov2" title="2">{
                workers = 4
        }</span>

        <span class="cov2" title="2">g, gctx := errgroup.WithContext(ctx)
        g.SetLimit(workers)

        for _, p := range paths </span><span class="cov4" title="4">{
                g.Go(func() error </span><span class="cov4" title="4">{
                        select </span>{
                        case &lt;-gctx.Done():<span class="cov0" title="0">
                                return gctx.Err()</span>
                        default:<span class="cov4" title="4"></span>
                        }

                        <span class="cov4" title="4">data, err := os.ReadFile(p)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov4" title="4">var entry CacheEntry
                        if json.Unmarshal(data, &amp;entry) != nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov4" title="4">if time.Now().After(entry.ExpiresAt) </span><span class="cov2" title="2">{
                                if err := os.Remove(p); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov4" title="4">return nil</span>
                })
        }

        <span class="cov2" title="2">return g.Wait()</span>
}

func HashFile(path string) (string, error) <span class="cov3" title="3">{
        return HashFileWithProgress(path, nil)
}</span>

func HashFileWithProgress(path string, progress ProgressCallback) (hash string, err error) <span class="cov4" title="4">{
        f, err := os.Open(path)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov3" title="3">defer func() </span><span class="cov3" title="3">{
                if closeErr := f.Close(); closeErr != nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        err = closeErr
                }</span>
        }()

        <span class="cov3" title="3">info, err := f.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov3" title="3">h := sha256.New()
        totalBytes := info.Size()

        if totalBytes &lt;= largeFileThreshold &amp;&amp; progress == nil </span><span class="cov2" title="2">{
                if _, err := io.Copy(h, f); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov2" title="2">return hex.EncodeToString(h.Sum(nil)), nil</span>
        }

        <span class="cov1" title="1">buf := make([]byte, hashBufferSize)
        var bytesProcessed int64

        for </span><span class="cov2" title="2">{
                n, err := f.Read(buf)
                if n &gt; 0 </span><span class="cov1" title="1">{
                        if _, err := h.Write(buf[:n]); err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov1" title="1">bytesProcessed += int64(n)
                        if progress != nil </span><span class="cov1" title="1">{
                                progress(bytesProcessed, totalBytes)
                        }</span>
                }
                <span class="cov2" title="2">if err == io.EOF </span><span class="cov1" title="1">{
                        break</span>
                }
                <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }

        <span class="cov1" title="1">return hex.EncodeToString(h.Sum(nil)), nil</span>
}

// IdempotencyKey generates an idempotency key for an operation.
func IdempotencyKey(operation string, args ...string) string <span class="cov6" title="14">{
        h := sha256.New()
        if _, err := h.Write([]byte(operation)); err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov6" title="14">for _, arg := range args </span><span class="cov8" title="26">{
                if _, err := h.Write([]byte(arg)); err != nil </span><span class="cov0" title="0">{
                        return ""
                }</span>
        }
        <span class="cov6" title="14">return hex.EncodeToString(h.Sum(nil))[:16]</span>
}

// CheckIdempotency represents an idempotency check result.
type CheckIdempotency struct {
        Operation   string      `json:"operation"`
        Key         string      `json:"key"`
        LocalState  interface{} `json:"localState"`
        RemoteState interface{} `json:"remoteState"`
        Matches     bool        `json:"matches"`
        Action      string      `json:"action"` // "skip", "update", "create"
}

const idempotencyTTL = 24 * time.Hour

type IdempotencyEntry struct {
        Key         string      `json:"key"`
        Operation   string      `json:"operation"`
        PackageName string      `json:"packageName"`
        ContentHash string      `json:"contentHash,omitempty"`
        Data        interface{} `json:"data"`
        Timestamp   time.Time   `json:"timestamp"`
        ExpiresAt   time.Time   `json:"expiresAt"`
}

type IdempotencyStore struct {
        dir string
        ttl time.Duration
}

func NewIdempotencyStore() *IdempotencyStore <span class="cov1" title="1">{
        paths := config.GetPaths()
        return &amp;IdempotencyStore{
                dir: filepath.Join(paths.CacheDir, "idempotency"),
                ttl: idempotencyTTL,
        }
}</span>

func (s *IdempotencyStore) generateKey(operation, packageName, contentHash string) string <span class="cov7" title="21">{
        h := sha256.New()
        if _, err := h.Write([]byte(operation)); err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov7" title="21">if _, err := h.Write([]byte(packageName)); err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov7" title="21">if _, err := h.Write([]byte(contentHash)); err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov7" title="21">return hex.EncodeToString(h.Sum(nil))[:32]</span>
}

func (s *IdempotencyStore) Check(key string) (bool, error) <span class="cov5" title="9">{
        result, err := s.Get(key)
        if err != nil </span><span class="cov1" title="1">{
                return false, err
        }</span>
        <span class="cov5" title="8">return result.Found, nil</span>
}

func (s *IdempotencyStore) Record(key string, data interface{}) error <span class="cov4" title="6">{
        return s.RecordWithMeta(key, "", "", "", data)
}</span>

func (s *IdempotencyStore) RecordWithMeta(key, operation, packageName, contentHash string, data interface{}) error <span class="cov6" title="13">{
        if err := os.MkdirAll(s.dir, 0700); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="12">entry := &amp;IdempotencyEntry{
                Key:         key,
                Operation:   operation,
                PackageName: packageName,
                ContentHash: contentHash,
                Data:        data,
                Timestamp:   time.Now(),
                ExpiresAt:   time.Now().Add(s.ttl),
        }

        jsonData, err := json.MarshalIndent(entry, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="12">path := filepath.Join(s.dir, key+".json")
        return os.WriteFile(path, jsonData, 0600)</span>
}

func (s *IdempotencyStore) Clear(key string) error <span class="cov2" title="2">{
        path := filepath.Join(s.dir, key+".json")
        err := os.Remove(path)
        if os.IsNotExist(err) </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov1" title="1">return err</span>
}

type CheckResult struct {
        Found     bool        `json:"found"`
        Key       string      `json:"key"`
        Data      interface{} `json:"data,omitempty"`
        Timestamp time.Time   `json:"timestamp,omitempty"`
        Expired   bool        `json:"expired,omitempty"`
}

func (s *IdempotencyStore) Get(key string) (*CheckResult, error) <span class="cov7" title="23">{
        path := filepath.Join(s.dir, key+".json")
        data, err := os.ReadFile(path)
        if os.IsNotExist(err) </span><span class="cov5" title="7">{
                return &amp;CheckResult{Found: false, Key: key}, nil
        }</span>
        <span class="cov7" title="16">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="16">var entry IdempotencyEntry
        if err := json.Unmarshal(data, &amp;entry); err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov6" title="14">if time.Now().After(entry.ExpiresAt) </span><span class="cov1" title="1">{
                if err := os.Remove(path); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">return &amp;CheckResult{Found: false, Key: key, Expired: true}, nil</span>
        }

        <span class="cov6" title="13">return &amp;CheckResult{
                Found:     true,
                Key:       key,
                Data:      entry.Data,
                Timestamp: entry.Timestamp,
        }, nil</span>
}

func (s *IdempotencyStore) CleanExpired() error <span class="cov1" title="1">{
        return s.CleanExpiredWithContext(context.Background())
}</span>

func (s *IdempotencyStore) CleanExpiredWithContext(ctx context.Context) error <span class="cov4" title="4">{
        entries, err := os.ReadDir(s.dir)
        if err != nil </span><span class="cov1" title="1">{
                if os.IsNotExist(err) </span><span class="cov1" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov3" title="3">var paths []string
        for _, entry := range entries </span><span class="cov4" title="4">{
                if entry.IsDir() || filepath.Ext(entry.Name()) != ".json" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov4" title="4">paths = append(paths, filepath.Join(s.dir, entry.Name()))</span>
        }

        <span class="cov3" title="3">if len(paths) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov2" title="2">workers := runtime.GOMAXPROCS(0)
        if workers &gt; 4 </span><span class="cov2" title="2">{
                workers = 4
        }</span>

        <span class="cov2" title="2">g, gctx := errgroup.WithContext(ctx)
        g.SetLimit(workers)

        for _, p := range paths </span><span class="cov4" title="4">{
                g.Go(func() error </span><span class="cov4" title="4">{
                        select </span>{
                        case &lt;-gctx.Done():<span class="cov0" title="0">
                                return gctx.Err()</span>
                        default:<span class="cov4" title="4"></span>
                        }

                        <span class="cov4" title="4">data, err := os.ReadFile(p)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov4" title="4">var e IdempotencyEntry
                        if json.Unmarshal(data, &amp;e) != nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov4" title="4">if time.Now().After(e.ExpiresAt) </span><span class="cov2" title="2">{
                                if err := os.Remove(p); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov4" title="4">return nil</span>
                })
        }

        <span class="cov2" title="2">return g.Wait()</span>
}

type UploadResult struct {
        VersionCode int64  `json:"versionCode"`
        SHA256      string `json:"sha256"`
        Path        string `json:"path"`
        Size        int64  `json:"size"`
        Type        string `json:"type"`
        EditID      string `json:"editId"`
}

func (s *IdempotencyStore) CheckUploadByHash(packageName, hash string) (*CheckResult, string, error) <span class="cov3" title="3">{
        key := s.generateKey("upload", packageName, hash)
        result, err := s.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, key, err
        }</span>

        <span class="cov3" title="3">return result, key, nil</span>
}

func (s *IdempotencyStore) RecordUpload(key, packageName, hash string, result *UploadResult) error <span class="cov2" title="2">{
        return s.RecordWithMeta(key, "upload", packageName, hash, result)
}</span>

type CommitResult struct {
        EditID    string `json:"editId"`
        Committed bool   `json:"committed"`
}

func (s *IdempotencyStore) CheckCommit(packageName, editID, contentIdentifier string) (*CheckResult, string, error) <span class="cov3" title="3">{
        key := s.generateKey("commit", packageName, editID+":"+contentIdentifier)
        result, err := s.Get(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, key, err
        }</span>
        <span class="cov3" title="3">return result, key, nil</span>
}

func (s *IdempotencyStore) RecordCommit(key, packageName, editID string) error <span class="cov2" title="2">{
        result := &amp;CommitResult{
                EditID:    editID,
                Committed: true,
        }
        return s.RecordWithMeta(key, "commit", packageName, editID, result)
}</span>

// FormatBytes formats bytes as a human-readable string.
func FormatBytes(bytes int64) string <span class="cov5" title="7">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov3" title="3">{
                return fmt.Sprintf("%d B", bytes)
        }</span>
        <span class="cov4" title="4">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov3" title="3">{
                div *= unit
                exp++
        }</span>
        <span class="cov4" title="4">return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package errors

import (
        "encoding/json"
        "errors"
        "net/http"
        "strings"
        "time"

        "golang.org/x/oauth2"
        "google.golang.org/api/googleapi"
)

type oauthErrorResponse struct {
        Error            string `json:"error"`
        ErrorDescription string `json:"error_description"`
        ErrorURI         string `json:"error_uri"`
}

func ClassifyAuthError(err error) *APIError <span class="cov10" title="24">{
        if err == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov9" title="23">if apiErr, ok := err.(*APIError); ok </span><span class="cov1" title="1">{
                return apiErr
        }</span>

        <span class="cov9" title="22">var retrieveErr *oauth2.RetrieveError
        if errors.As(err, &amp;retrieveErr) </span><span class="cov9" title="18">{
                details := map[string]interface{}{
                        "httpStatus": retrieveErr.Response.StatusCode,
                }
                resp := oauthErrorResponse{}
                if retrieveErr.Body != nil </span><span class="cov9" title="17">{
                        _ = json.Unmarshal(retrieveErr.Body, &amp;resp)
                }</span>
                <span class="cov9" title="18">if resp.Error != "" </span><span class="cov8" title="16">{
                        details["oauthError"] = resp.Error
                }</span>
                <span class="cov9" title="18">if resp.ErrorDescription != "" </span><span class="cov6" title="7">{
                        details["oauthErrorDescription"] = resp.ErrorDescription
                }</span>
                <span class="cov9" title="18">skewed := addClockSkew(details, retrieveErr.Response.Header)
                switch resp.Error </span>{
                case "invalid_grant":<span class="cov7" title="9">
                        apiErr := NewAPIError(CodeAuthFailure, "refresh token expired or revoked").
                                WithHint("Re-authenticate or rotate credentials").
                                WithDetails(details).
                                WithHTTPStatus(retrieveErr.Response.StatusCode)
                        if skewed </span><span class="cov4" title="3">{
                                apiErr = apiErr.WithHint(appendHint(apiErr.Hint, "Sync system clock and retry"))
                        }</span>
                        <span class="cov7" title="9">return apiErr</span>
                case "invalid_client", "unauthorized_client":<span class="cov4" title="3">
                        apiErr := NewAPIError(CodeAuthFailure, "client not authorized to refresh tokens").
                                WithHint("Verify the client credentials or service account key").
                                WithDetails(details).
                                WithHTTPStatus(retrieveErr.Response.StatusCode)
                        if skewed </span><span class="cov1" title="1">{
                                apiErr = apiErr.WithHint(appendHint(apiErr.Hint, "Sync system clock and retry"))
                        }</span>
                        <span class="cov4" title="3">return apiErr</span>
                case "access_denied":<span class="cov2" title="2">
                        apiErr := NewAPIError(CodeAuthFailure, "access denied during token refresh").
                                WithHint("Re-authenticate and confirm access is granted").
                                WithDetails(details).
                                WithHTTPStatus(retrieveErr.Response.StatusCode)
                        if skewed </span><span class="cov1" title="1">{
                                apiErr = apiErr.WithHint(appendHint(apiErr.Hint, "Sync system clock and retry"))
                        }</span>
                        <span class="cov2" title="2">return apiErr</span>
                default:<span class="cov4" title="4">
                        apiErr := NewAPIError(CodeAuthFailure, "authentication refresh failed").
                                WithHint("Re-authenticate or verify credentials").
                                WithDetails(details).
                                WithHTTPStatus(retrieveErr.Response.StatusCode)
                        if skewed </span><span class="cov1" title="1">{
                                apiErr = apiErr.WithHint(appendHint(apiErr.Hint, "Sync system clock and retry"))
                        }</span>
                        <span class="cov4" title="4">return apiErr</span>
                }
        }

        <span class="cov4" title="4">var gapiErr *googleapi.Error
        if errors.As(err, &amp;gapiErr) </span><span class="cov4" title="3">{
                details := map[string]interface{}{
                        "httpStatus": gapiErr.Code,
                }
                skewed := addClockSkew(details, gapiErr.Header)
                code := FromHTTPStatus(gapiErr.Code)
                apiErr := NewAPIError(code, gapiErr.Message).WithDetails(details).WithHTTPStatus(gapiErr.Code)
                if gapiErr.Code == http.StatusUnauthorized </span><span class="cov2" title="2">{
                        apiErr = apiErr.WithHint("Re-authenticate and retry the command")
                }</span>
                <span class="cov4" title="3">if gapiErr.Code == http.StatusForbidden </span><span class="cov1" title="1">{
                        apiErr = apiErr.WithHint("Verify permissions and service account access")
                }</span>
                <span class="cov4" title="3">if skewed </span><span class="cov1" title="1">{
                        apiErr = apiErr.WithHint(appendHint(apiErr.Hint, "Sync system clock and retry"))
                }</span>
                <span class="cov4" title="3">return apiErr</span>
        }

        <span class="cov1" title="1">return NewAPIError(CodeAuthFailure, err.Error())</span>
}

func addClockSkew(details map[string]interface{}, header http.Header) bool <span class="cov9" title="23">{
        if header == nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov9" title="22">dateHeader := header.Get("Date")
        if dateHeader == "" </span><span class="cov4" title="4">{
                return false
        }</span>
        <span class="cov9" title="18">remoteTime, err := http.ParseTime(dateHeader)
        if err != nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov9" title="17">skew := time.Since(remoteTime)
        if skew &lt; 0 </span><span class="cov4" title="3">{
                skew = -skew
        }</span>
        <span class="cov9" title="17">if skew &gt; 5*time.Minute </span><span class="cov6" title="7">{
                details["clockSkewSeconds"] = int64(skew.Seconds())
                return true
        }</span>
        <span class="cov7" title="10">return false</span>
}

func appendHint(current, extra string) string <span class="cov7" title="11">{
        if current == "" </span><span class="cov1" title="1">{
                return extra
        }</span>
        <span class="cov7" title="10">if strings.Contains(current, extra) </span><span class="cov2" title="2">{
                return current
        }</span>
        <span class="cov6" title="8">return current + "; " + extra</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Package errors provides standardized error types and exit codes for gpd.
package errors

import (
        "fmt"
        "net/http"
)

// Exit codes for gpd CLI following the requirements specification.
const (
        ExitSuccess          = 0 // Command succeeded
        ExitGeneralError     = 1 // Other API errors
        ExitAuthFailure      = 2 // Authentication failures
        ExitPermissionDenied = 3 // Permission denied
        ExitValidationError  = 4 // Input validation errors
        ExitRateLimited      = 5 // Rate limit exceeded (HTTP 429 or quota)
        ExitNetworkError     = 6 // Network errors (DNS, TLS, timeouts)
        ExitNotFound         = 7 // Resource not found
        ExitConflict         = 8 // Conflicts (edit exists, file lock contention)
)

// ErrorCode represents a string error code for structured error responses.
type ErrorCode string

const (
        CodeSuccess          ErrorCode = "SUCCESS"
        CodeGeneralError     ErrorCode = "GENERAL_ERROR"
        CodeAuthFailure      ErrorCode = "AUTH_FAILURE"
        CodePermissionDenied ErrorCode = "PERMISSION_DENIED"
        CodeValidationError  ErrorCode = "VALIDATION_ERROR"
        CodeRateLimited      ErrorCode = "RATE_LIMITED"
        CodeNetworkError     ErrorCode = "NETWORK_ERROR"
        CodeNotFound         ErrorCode = "NOT_FOUND"
        CodeConflict         ErrorCode = "CONFLICT"
)

// APIError represents a structured error response.
type APIError struct {
        Code              ErrorCode   `json:"code"`
        Message           string      `json:"message"`
        Hint              string      `json:"hint,omitempty"`
        Details           interface{} `json:"details,omitempty"`
        HTTPStatus        int         `json:"httpStatus,omitempty"`
        RetryAfterSeconds int         `json:"retryAfterSeconds,omitempty"`
        Service           string      `json:"service,omitempty"`
        Operation         string      `json:"operation,omitempty"`
}

// Error implements the error interface.
func (e *APIError) Error() string <span class="cov2" title="2">{
        if e.Hint != "" </span><span class="cov1" title="1">{
                return fmt.Sprintf("%s: %s (hint: %s)", e.Code, e.Message, e.Hint)
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("%s: %s", e.Code, e.Message)</span>
}

// ExitCode returns the appropriate exit code for this error.
func (e *APIError) ExitCode() int <span class="cov6" title="9">{
        switch e.Code </span>{
        case CodeSuccess:<span class="cov1" title="1">
                return ExitSuccess</span>
        case CodeAuthFailure:<span class="cov1" title="1">
                return ExitAuthFailure</span>
        case CodePermissionDenied:<span class="cov1" title="1">
                return ExitPermissionDenied</span>
        case CodeValidationError:<span class="cov1" title="1">
                return ExitValidationError</span>
        case CodeRateLimited:<span class="cov1" title="1">
                return ExitRateLimited</span>
        case CodeNetworkError:<span class="cov1" title="1">
                return ExitNetworkError</span>
        case CodeNotFound:<span class="cov1" title="1">
                return ExitNotFound</span>
        case CodeConflict:<span class="cov1" title="1">
                return ExitConflict</span>
        default:<span class="cov1" title="1">
                return ExitGeneralError</span>
        }
}

// NewAPIError creates a new APIError with the given parameters.
func NewAPIError(code ErrorCode, message string) *APIError <span class="cov10" title="41">{
        return &amp;APIError{
                Code:    code,
                Message: message,
        }
}</span>

// WithHint adds a hint to the error.
func (e *APIError) WithHint(hint string) *APIError <span class="cov9" title="37">{
        e.Hint = hint
        return e
}</span>

// WithDetails adds details to the error.
func (e *APIError) WithDetails(details interface{}) *APIError <span class="cov8" title="22">{
        e.Details = details
        return e
}</span>

// WithHTTPStatus adds HTTP status to the error.
func (e *APIError) WithHTTPStatus(status int) *APIError <span class="cov8" title="22">{
        e.HTTPStatus = status
        return e
}</span>

// WithRetryAfter adds retry-after seconds to the error.
func (e *APIError) WithRetryAfter(seconds int) *APIError <span class="cov1" title="1">{
        e.RetryAfterSeconds = seconds
        return e
}</span>

// WithService adds service name to the error.
func (e *APIError) WithService(service string) *APIError <span class="cov1" title="1">{
        e.Service = service
        return e
}</span>

// WithOperation adds operation name to the error.
func (e *APIError) WithOperation(operation string) *APIError <span class="cov1" title="1">{
        e.Operation = operation
        return e
}</span>

// FromHTTPStatus creates an appropriate error code from HTTP status.
func FromHTTPStatus(status int) ErrorCode <span class="cov6" title="11">{
        switch </span>{
        case status == http.StatusUnauthorized:<span class="cov3" title="3">
                return CodeAuthFailure</span>
        case status == http.StatusForbidden:<span class="cov2" title="2">
                return CodePermissionDenied</span>
        case status == http.StatusNotFound:<span class="cov1" title="1">
                return CodeNotFound</span>
        case status == http.StatusConflict:<span class="cov1" title="1">
                return CodeConflict</span>
        case status == http.StatusTooManyRequests:<span class="cov1" title="1">
                return CodeRateLimited</span>
        case status &gt;= 400 &amp;&amp; status &lt; 500:<span class="cov1" title="1">
                return CodeValidationError</span>
        case status &gt;= 500:<span class="cov1" title="1">
                return CodeGeneralError</span>
        default:<span class="cov1" title="1">
                return CodeGeneralError</span>
        }
}

// Common errors with hints.
var (
        ErrAuthNotConfigured = NewAPIError(CodeAuthFailure, "authentication not configured").
                                WithHint("Provide --key, set GPD_SERVICE_ACCOUNT_KEY, or set GOOGLE_APPLICATION_CREDENTIALS")

        ErrServiceAccountInvalid = NewAPIError(CodeAuthFailure, "invalid service account key").
                                        WithHint("Ensure the service account key file is valid JSON and contains required fields")

        ErrPermissionDenied = NewAPIError(CodePermissionDenied, "permission denied").
                                WithHint("Ensure the service account has required permissions in Google Play Console")

        ErrPackageRequired = NewAPIError(CodeValidationError, "package name is required").
                                WithHint("Provide --package flag or set default package in config")

        ErrTrackInvalid = NewAPIError(CodeValidationError, "invalid track name").
                        WithHint("Valid tracks are: internal, alpha, beta, production")

        ErrEditConflict = NewAPIError(CodeConflict, "edit transaction conflict").
                        WithHint("Another process may be using this edit. Wait and retry, or use a different --edit-id")

        ErrFileLockTimeout = NewAPIError(CodeConflict, "file lock acquisition timeout").
                                WithHint("Another gpd process may be running. Wait for it to complete or check for stale locks")
)
</pre>
		
		<pre class="file" id="file46" style="display: none">// Package logging provides structured logging with PII redaction for gpd.
package logging

import (
        "encoding/json"
        "fmt"
        "io"
        "os"
        "regexp"
        "strings"
        "sync"
        "time"
)

// Level represents a log level.
type Level int

const (
        LevelDebug Level = iota
        LevelInfo
        LevelWarn
        LevelError
)

func (l Level) String() string <span class="cov7" title="19">{
        switch l </span>{
        case LevelDebug:<span class="cov2" title="2">
                return "DEBUG"</span>
        case LevelInfo:<span class="cov6" title="10">
                return "INFO"</span>
        case LevelWarn:<span class="cov3" title="3">
                return "WARN"</span>
        case LevelError:<span class="cov3" title="3">
                return "ERROR"</span>
        default:<span class="cov1" title="1">
                return "UNKNOWN"</span>
        }
}

// Field represents a log field.
type Field struct {
        Key   string
        Value interface{}
        PII   bool // Mark as PII for redaction
}

// Logger provides structured logging with PII redaction.
type Logger struct {
        mu       sync.Mutex
        writer   io.Writer
        level    Level
        verbose  bool
        redactor *PIIRedactor
}

// NewLogger creates a new logger.
func NewLogger(w io.Writer, verbose bool) *Logger <span class="cov6" title="11">{
        return &amp;Logger{
                writer:   w,
                level:    LevelInfo,
                verbose:  verbose,
                redactor: NewPIIRedactor(),
        }
}</span>

// SetLevel sets the minimum log level.
func (l *Logger) SetLevel(level Level) <span class="cov2" title="2">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.level = level
}</span>

// Debug logs a debug message.
func (l *Logger) Debug(msg string, fields ...Field) <span class="cov2" title="2">{
        l.log(LevelDebug, msg, fields...)
}</span>

// Info logs an info message.
func (l *Logger) Info(msg string, fields ...Field) <span class="cov6" title="10">{
        l.log(LevelInfo, msg, fields...)
}</span>

// Warn logs a warning message.
func (l *Logger) Warn(msg string, fields ...Field) <span class="cov2" title="2">{
        l.log(LevelWarn, msg, fields...)
}</span>

// Error logs an error message.
func (l *Logger) Error(msg string, fields ...Field) <span class="cov2" title="2">{
        l.log(LevelError, msg, fields...)
}</span>

func (l *Logger) log(level Level, msg string, fields ...Field) <span class="cov7" title="16">{
        l.mu.Lock()
        defer l.mu.Unlock()

        if level &lt; l.level </span><span class="cov2" title="2">{
                return
        }</span>

        // Apply PII redaction to fields
        <span class="cov7" title="14">redactedFields := make(map[string]interface{})
        for _, f := range fields </span><span class="cov6" title="12">{
                value := f.Value
                if f.PII || l.redactor.IsSensitiveField(f.Key) </span><span class="cov2" title="2">{
                        value = l.redactor.Redact(f.Key, f.Value)
                }</span>
                <span class="cov6" title="12">redactedFields[f.Key] = value</span>
        }

        <span class="cov7" title="14">if l.verbose </span><span class="cov4" title="4">{
                // JSON format for verbose mode
                entry := map[string]interface{}{
                        "timestamp": time.Now().UTC().Format(time.RFC3339),
                        "level":     level.String(),
                        "message":   msg,
                        "fields":    redactedFields,
                }
                data, err := json.Marshal(entry)
                if err != nil </span><span class="cov1" title="1">{
                        return
                }</span>
                <span class="cov3" title="3">if _, err := fmt.Fprintln(l.writer, string(data)); err != nil </span><span class="cov1" title="1">{
                        return
                }</span>
        } else<span class="cov6" title="10"> {
                // Simple format for normal mode
                var parts []string
                for k, v := range redactedFields </span><span class="cov5" title="8">{
                        parts = append(parts, fmt.Sprintf("%s=%v", k, v))
                }</span>
                <span class="cov6" title="10">fieldStr := ""
                if len(parts) &gt; 0 </span><span class="cov5" title="8">{
                        fieldStr = " " + strings.Join(parts, " ")
                }</span>
                <span class="cov6" title="10">if _, err := fmt.Fprintf(l.writer, "[%s] %s%s\n", level.String(), msg, fieldStr); err != nil </span><span class="cov1" title="1">{
                        return
                }</span>
        }
}

// PIIRedactor handles PII redaction in log output.
type PIIRedactor struct {
        // Allowlisted fields (safe to log)
        allowedFields map[string]bool
        // Sensitive field patterns
        sensitiveFields map[string]bool
        // Regex patterns for detecting PII
        patterns []*regexp.Regexp
}

// NewPIIRedactor creates a new PII redactor.
func NewPIIRedactor() *PIIRedactor <span class="cov8" title="23">{
        r := &amp;PIIRedactor{
                allowedFields: map[string]bool{
                        "command":     true,
                        "duration":    true,
                        "durationMs":  true,
                        "exit_code":   true,
                        "exitCode":    true,
                        "package":     true,
                        "packageName": true,
                        "track":       true,
                        "versionCode": true,
                        "status":      true,
                        "action":      true,
                        "editId":      true,
                        "locale":      true,
                        "format":      true,
                        "pageSize":    true,
                        "pageToken":   true,
                        "startDate":   true,
                        "endDate":     true,
                        "metrics":     true,
                        "dimensions":  true,
                        "productId":   true,
                        "productType": true,
                        "environment": true,
                        "success":     true,
                        "error":       true,
                        "hint":        true,
                        "retries":     true,
                        "noop":        true,
                        "dryRun":      true,
                },
                sensitiveFields: map[string]bool{
                        "email":             true,
                        "userName":          true,
                        "authorName":        true,
                        "reviewText":        true,
                        "text":              true,
                        "token":             true,
                        "purchaseToken":     true,
                        "accessToken":       true,
                        "refreshToken":      true,
                        "serviceAccountKey": true,
                        "privateKey":        true,
                        "orderId":           true,
                        "orderIds":          true,
                        "groups":            true,
                },
        }

        // Compile regex patterns for PII detection
        r.patterns = []*regexp.Regexp{
                regexp.MustCompile(`[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}`),       // Email
                regexp.MustCompile(`\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b`),               // IP address
                regexp.MustCompile(`\b\d{10,}\b`),                                          // Phone numbers (simplified)
                regexp.MustCompile(`ya29\.[a-zA-Z0-9_-]+`),                                 // Google access tokens
                regexp.MustCompile(`eyJ[a-zA-Z0-9_-]*\.eyJ[a-zA-Z0-9_-]*\.[a-zA-Z0-9_-]*`), // JWT tokens
        }

        return r
}</span>

// IsSensitiveField checks if a field is sensitive.
func (r *PIIRedactor) IsSensitiveField(key string) bool <span class="cov10" title="48">{
        if r.sensitiveFields[key] </span><span class="cov8" title="24">{
                return true
        }</span>
        // Check for common sensitive key patterns
        <span class="cov8" title="24">lowerKey := strings.ToLower(key)
        return strings.Contains(lowerKey, "password") ||
                strings.Contains(lowerKey, "secret") ||
                strings.Contains(lowerKey, "key") ||
                strings.Contains(lowerKey, "token") ||
                strings.Contains(lowerKey, "credential")</span>
}

// IsAllowedField checks if a field is safe to log.
func (r *PIIRedactor) IsAllowedField(key string) bool <span class="cov6" title="13">{
        return r.allowedFields[key]
}</span>

// Redact redacts sensitive data from a value.
func (r *PIIRedactor) Redact(key string, value interface{}) interface{} <span class="cov7" title="19">{
        // Handle nil values
        if value == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Handle string values
        <span class="cov7" title="18">if s, ok := value.(string); ok </span><span class="cov7" title="15">{
                return r.redactString(key, s)
        }</span>

        // Handle slices of strings (like email lists)
        <span class="cov3" title="3">if slice, ok := value.([]string); ok </span><span class="cov1" title="1">{
                result := make([]string, len(slice))
                for i, s := range slice </span><span class="cov1" title="1">{
                        result[i] = r.redactString(key, s)
                }</span>
                <span class="cov1" title="1">return result</span>
        }

        // Handle maps
        <span class="cov2" title="2">if m, ok := value.(map[string]interface{}); ok </span><span class="cov1" title="1">{
                result := make(map[string]interface{})
                for k, v := range m </span><span class="cov2" title="2">{
                        if r.IsSensitiveField(k) </span><span class="cov1" title="1">{
                                result[k] = r.Redact(k, v)
                        }</span> else<span class="cov1" title="1"> {
                                result[k] = v
                        }</span>
                }
                <span class="cov1" title="1">return result</span>
        }

        // For other types, return redacted placeholder
        <span class="cov1" title="1">return "[REDACTED]"</span>
}

func (r *PIIRedactor) redactString(key, value string) string <span class="cov7" title="17">{
        if value == "" </span><span class="cov1" title="1">{
                return ""
        }</span>

        // Check for known sensitive field names
        <span class="cov7" title="16">if r.IsSensitiveField(key) </span><span class="cov6" title="12">{
                if len(value) &lt;= 4 </span><span class="cov4" title="4">{
                        return "[REDACTED]"
                }</span>
                // Show first 2 and last 2 characters for debugging
                <span class="cov5" title="8">return value[:2] + "..." + value[len(value)-2:] + "[REDACTED]"</span>
        }

        // Apply pattern-based redaction
        <span class="cov4" title="4">result := value
        for _, pattern := range r.patterns </span><span class="cov7" title="20">{
                result = pattern.ReplaceAllString(result, "[REDACTED]")
        }</span>

        <span class="cov4" title="4">return result</span>
}

// RedactMap redacts all sensitive fields in a map.
func (r *PIIRedactor) RedactMap(data map[string]interface{}) map[string]interface{} <span class="cov1" title="1">{
        result := make(map[string]interface{})
        for k, v := range data </span><span class="cov5" title="7">{
                if r.IsSensitiveField(k) </span><span class="cov4" title="4">{
                        result[k] = r.Redact(k, v)
                }</span> else<span class="cov3" title="3"> if r.IsAllowedField(k) </span><span class="cov1" title="1">{
                        result[k] = v
                }</span> else<span class="cov2" title="2"> {
                        // For unknown fields, check if value contains PII patterns
                        if s, ok := v.(string); ok </span><span class="cov1" title="1">{
                                result[k] = r.redactString(k, s)
                        }</span> else<span class="cov1" title="1"> {
                                result[k] = v
                        }</span>
                }
        }
        <span class="cov1" title="1">return result</span>
}

// Global logger instance
var (
        defaultLogger     *Logger
        defaultLoggerOnce sync.Once
)

func getDefaultLogger() *Logger <span class="cov4" title="5">{
        defaultLoggerOnce.Do(func() </span><span class="cov1" title="1">{
                defaultLogger = NewLogger(os.Stderr, false)
        }</span>)
        <span class="cov4" title="5">return defaultLogger</span>
}

// SetDefault sets the default logger.
func SetDefault(l *Logger) <span class="cov1" title="1">{
        defaultLogger = l
}</span>

// Debug logs a debug message using the default logger.
func Debug(msg string, fields ...Field) <span class="cov1" title="1">{
        getDefaultLogger().Debug(msg, fields...)
}</span>

// Info logs an info message using the default logger.
func Info(msg string, fields ...Field) <span class="cov1" title="1">{
        getDefaultLogger().Info(msg, fields...)
}</span>

// Warn logs a warning message using the default logger.
func Warn(msg string, fields ...Field) <span class="cov1" title="1">{
        getDefaultLogger().Warn(msg, fields...)
}</span>

// Error logs an error message using the default logger.
func Error(msg string, fields ...Field) <span class="cov1" title="1">{
        getDefaultLogger().Error(msg, fields...)
}</span>

// String creates a string field.
func String(key, value string) Field <span class="cov6" title="11">{
        return Field{Key: key, Value: value}
}</span>

// Int creates an integer field.
func Int(key string, value int) Field <span class="cov1" title="1">{
        return Field{Key: key, Value: value}
}</span>

// Int64 creates an int64 field.
func Int64(key string, value int64) Field <span class="cov1" title="1">{
        return Field{Key: key, Value: value}
}</span>

// Bool creates a boolean field.
func Bool(key string, value bool) Field <span class="cov1" title="1">{
        return Field{Key: key, Value: value}
}</span>

// Duration creates a duration field.
func Duration(key string, value time.Duration) Field <span class="cov1" title="1">{
        return Field{Key: key, Value: value.String()}
}</span>

// Err creates an error field.
func Err(err error) Field <span class="cov2" title="2">{
        if err == nil </span><span class="cov1" title="1">{
                return Field{Key: "error", Value: nil}
        }</span>
        <span class="cov1" title="1">return Field{Key: "error", Value: err.Error()}</span>
}

// Sensitive creates a field marked as PII.
func Sensitive(key string, value interface{}) Field <span class="cov2" title="2">{
        return Field{Key: key, Value: value, PII: true}
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">// Package fastlane provides parsing and writing for fastlane metadata.
package fastlane

import (
        "os"
        "path/filepath"
        "sort"
        "strconv"
        "strings"
)

// LocaleMetadata represents fastlane metadata for a single locale.
type LocaleMetadata struct {
        Locale              string
        Title               string
        TitleSet            bool
        ShortDescription    string
        ShortDescriptionSet bool
        FullDescription     string
        FullDescriptionSet  bool
        Video               string
        VideoSet            bool
        Changelogs          map[string]string
        Images              map[string][]string
}

const (
        extPNG  = ".png"
        extJPG  = ".jpg"
        extJPEG = ".jpeg"
)

// ParseDirectory reads a fastlane metadata directory into structured metadata.
func ParseDirectory(dir string) ([]LocaleMetadata, error) <span class="cov4" title="3">{
        absDir, err := filepath.Abs(dir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="3">entries, err := os.ReadDir(absDir)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="2">var metas []LocaleMetadata
        for _, entry := range entries </span><span class="cov4" title="3">{
                if !entry.IsDir() </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov3" title="2">locale := entry.Name()
                meta, err := parseLocaleDir(filepath.Join(absDir, locale), locale)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="2">metas = append(metas, meta)</span>
        }

        <span class="cov3" title="2">sort.Slice(metas, func(i, j int) bool </span><span class="cov0" title="0">{
                return metas[i].Locale &lt; metas[j].Locale
        }</span>)
        <span class="cov3" title="2">return metas, nil</span>
}

// WriteDirectory writes locale metadata to a fastlane metadata directory.
func WriteDirectory(dir string, metadata []LocaleMetadata) error <span class="cov1" title="1">{
        if err := os.MkdirAll(dir, 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">for i := range metadata </span><span class="cov1" title="1">{
                if err := WriteLocale(dir, &amp;metadata[i]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// WriteLocale writes metadata for a single locale.
func WriteLocale(dir string, meta *LocaleMetadata) error <span class="cov3" title="2">{
        if meta == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov1" title="1">localeDir := filepath.Join(dir, meta.Locale)
        if err := os.MkdirAll(localeDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if meta.TitleSet </span><span class="cov1" title="1">{
                if err := writeTextFile(filepath.Join(localeDir, "title.txt"), meta.Title); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov1" title="1">if meta.ShortDescriptionSet </span><span class="cov1" title="1">{
                if err := writeTextFile(filepath.Join(localeDir, "short_description.txt"), meta.ShortDescription); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov1" title="1">if meta.FullDescriptionSet </span><span class="cov1" title="1">{
                if err := writeTextFile(filepath.Join(localeDir, "full_description.txt"), meta.FullDescription); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov1" title="1">if meta.VideoSet </span><span class="cov1" title="1">{
                if err := writeTextFile(filepath.Join(localeDir, "video.txt"), meta.Video); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov1" title="1">if len(meta.Changelogs) &gt; 0 </span><span class="cov1" title="1">{
                changelogDir := filepath.Join(localeDir, "changelogs")
                if err := os.MkdirAll(changelogDir, 0o755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">keys := make([]string, 0, len(meta.Changelogs))
                for key := range meta.Changelogs </span><span class="cov1" title="1">{
                        keys = append(keys, key)
                }</span>
                <span class="cov1" title="1">sort.Strings(keys)
                for _, key := range keys </span><span class="cov1" title="1">{
                        if err := writeTextFile(filepath.Join(changelogDir, key+".txt"), meta.Changelogs[key]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov1" title="1">return nil</span>
}

func parseLocaleDir(localeDir, locale string) (LocaleMetadata, error) <span class="cov3" title="2">{
        meta := LocaleMetadata{
                Locale: locale,
        }

        title, ok, err := readOptionalTextFile(filepath.Join(localeDir, "title.txt"))
        if err != nil </span><span class="cov0" title="0">{
                return meta, err
        }</span>
        <span class="cov3" title="2">if ok </span><span class="cov3" title="2">{
                meta.Title = title
                meta.TitleSet = true
        }</span>

        <span class="cov3" title="2">shortDesc, ok, err := readOptionalTextFile(filepath.Join(localeDir, "short_description.txt"))
        if err != nil </span><span class="cov0" title="0">{
                return meta, err
        }</span>
        <span class="cov3" title="2">if ok </span><span class="cov1" title="1">{
                meta.ShortDescription = shortDesc
                meta.ShortDescriptionSet = true
        }</span>

        <span class="cov3" title="2">fullDesc, ok, err := readOptionalTextFile(filepath.Join(localeDir, "full_description.txt"))
        if err != nil </span><span class="cov0" title="0">{
                return meta, err
        }</span>
        <span class="cov3" title="2">if ok </span><span class="cov1" title="1">{
                meta.FullDescription = fullDesc
                meta.FullDescriptionSet = true
        }</span>

        <span class="cov3" title="2">video, ok, err := readOptionalTextFile(filepath.Join(localeDir, "video.txt"))
        if err != nil </span><span class="cov0" title="0">{
                return meta, err
        }</span>
        <span class="cov3" title="2">if ok </span><span class="cov1" title="1">{
                meta.Video = video
                meta.VideoSet = true
        }</span>

        <span class="cov3" title="2">changelogs, err := readChangelogs(localeDir)
        if err != nil </span><span class="cov0" title="0">{
                return meta, err
        }</span>
        <span class="cov3" title="2">if len(changelogs) &gt; 0 </span><span class="cov1" title="1">{
                meta.Changelogs = changelogs
        }</span>

        <span class="cov3" title="2">images, err := readImages(localeDir)
        if err != nil </span><span class="cov0" title="0">{
                return meta, err
        }</span>
        <span class="cov3" title="2">if len(images) &gt; 0 </span><span class="cov1" title="1">{
                meta.Images = images
        }</span>

        <span class="cov3" title="2">return meta, nil</span>
}

func readOptionalTextFile(path string) (value string, ok bool, err error) <span class="cov9" title="11">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov4" title="3">{
                if os.IsNotExist(err) </span><span class="cov4" title="3">{
                        return "", false, nil
                }</span>
                <span class="cov0" title="0">return "", false, err</span>
        }
        <span class="cov8" title="8">return strings.TrimRight(string(data), "\r\n"), true, nil</span>
}

func writeTextFile(path, value string) error <span class="cov6" title="5">{
        if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="5">return os.WriteFile(path, []byte(value), 0o644)</span>
}

func readChangelogs(localeDir string) (map[string]string, error) <span class="cov6" title="5">{
        changelogDir := filepath.Join(localeDir, "changelogs")
        entries, err := os.ReadDir(changelogDir)
        if err != nil </span><span class="cov4" title="3">{
                if os.IsNotExist(err) </span><span class="cov3" title="2">{
                        if info, statErr := os.Stat(changelogDir); statErr == nil &amp;&amp; !info.IsDir() </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov3" title="2">return nil, nil</span>
                }
                <span class="cov1" title="1">return nil, err</span>
        }

        <span class="cov3" title="2">changelogs := map[string]string{}
        for _, entry := range entries </span><span class="cov4" title="3">{
                if entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov4" title="3">name := entry.Name()
                if filepath.Ext(name) != ".txt" </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov3" title="2">key := strings.TrimSuffix(name, ".txt")
                value, ok, err := readOptionalTextFile(filepath.Join(changelogDir, name))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="2">if ok </span><span class="cov3" title="2">{
                        changelogs[key] = value
                }</span>
        }
        <span class="cov3" title="2">return changelogs, nil</span>
}

func readImages(localeDir string) (map[string][]string, error) <span class="cov7" title="6">{
        imagesDir := filepath.Join(localeDir, "images")
        entries, err := os.ReadDir(imagesDir)
        if err != nil </span><span class="cov4" title="3">{
                if os.IsNotExist(err) </span><span class="cov3" title="2">{
                        if info, statErr := os.Stat(imagesDir); statErr == nil &amp;&amp; !info.IsDir() </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov3" title="2">return nil, nil</span>
                }
                <span class="cov1" title="1">return nil, err</span>
        }

        <span class="cov4" title="3">images := map[string][]string{}
        sort.Slice(entries, func(i, j int) bool </span><span class="cov6" title="5">{
                return entries[i].Name() &lt; entries[j].Name()
        }</span>)
        <span class="cov4" title="3">for _, entry := range entries </span><span class="cov8" title="8">{
                name := entry.Name()
                fullPath := filepath.Join(imagesDir, name)
                if entry.IsDir() </span><span class="cov3" title="2">{
                        if !isScreenshotDir(name) </span><span class="cov1" title="1">{
                                continue</span>
                        }
                        <span class="cov1" title="1">files, err := readImageFiles(fullPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov1" title="1">if len(files) &gt; 0 </span><span class="cov1" title="1">{
                                images[name] = files
                        }</span>
                        <span class="cov1" title="1">continue</span>
                }

                <span class="cov7" title="6">if !isImageFile(name) </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov6" title="5">base := strings.TrimSuffix(name, filepath.Ext(name))
                if isSingleImage(base) </span><span class="cov6" title="5">{
                        if singleImageExtRank(base, filepath.Ext(name)) == 0 </span><span class="cov1" title="1">{
                                continue</span>
                        }
                        <span class="cov6" title="4">existing := images[base]
                        if len(existing) == 0 </span><span class="cov4" title="3">{
                                images[base] = []string{fullPath}
                                continue</span>
                        }
                        <span class="cov1" title="1">images[base] = []string{preferSingleImage(base, existing[0], fullPath)}</span>
                }
        }

        <span class="cov4" title="3">return images, nil</span>
}

func readImageFiles(dir string) ([]string, error) <span class="cov1" title="1">{
        entries, err := os.ReadDir(dir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">var files []string
        for _, entry := range entries </span><span class="cov6" title="4">{
                if entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov6" title="4">if !isImageFile(entry.Name()) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov6" title="4">files = append(files, filepath.Join(dir, entry.Name()))</span>
        }
        <span class="cov1" title="1">sort.Slice(files, func(i, j int) bool </span><span class="cov7" title="6">{
                return compareImageNames(files[i], files[j])
        }</span>)
        <span class="cov1" title="1">return files, nil</span>
}

func isScreenshotDir(name string) bool <span class="cov6" title="4">{
        switch name </span>{
        case "phoneScreenshots", "tabletScreenshots", "sevenInchScreenshots", "tenInchScreenshots", "tvScreenshots", "wearScreenshots":<span class="cov3" title="2">
                return true</span>
        default:<span class="cov3" title="2">
                return false</span>
        }
}

func isSingleImage(name string) bool <span class="cov8" title="7">{
        switch name </span>{
        case "icon", "featureGraphic", "promoGraphic", "tvBanner":<span class="cov7" title="6">
                return true</span>
        default:<span class="cov1" title="1">
                return false</span>
        }
}

func isImageFile(name string) bool <span class="cov10" title="12">{
        ext := strings.ToLower(filepath.Ext(name))
        switch ext </span>{
        case extPNG, extJPG, extJPEG:<span class="cov9" title="10">
                return true</span>
        default:<span class="cov3" title="2">
                return false</span>
        }
}

func compareImageNames(a, b string) bool <span class="cov8" title="7">{
        aBase := filepath.Base(a)
        bBase := filepath.Base(b)
        aName := strings.TrimSuffix(aBase, filepath.Ext(aBase))
        bName := strings.TrimSuffix(bBase, filepath.Ext(bBase))
        aNum, aErr := strconv.Atoi(aName)
        bNum, bErr := strconv.Atoi(bName)
        if aErr == nil &amp;&amp; bErr == nil </span><span class="cov8" title="7">{
                if aNum == bNum </span><span class="cov1" title="1">{
                        return compareByExtensionThenName(aBase, bBase)
                }</span>
                <span class="cov7" title="6">return aNum &lt; bNum</span>
        }
        <span class="cov0" title="0">if aErr == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if bErr == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return aBase &lt; bBase</span>
}

func preferSingleImage(base, current, candidate string) string <span class="cov3" title="2">{
        currentRank := singleImageExtRank(base, filepath.Ext(current))
        candidateRank := singleImageExtRank(base, filepath.Ext(candidate))
        if candidateRank &gt; currentRank </span><span class="cov1" title="1">{
                return candidate
        }</span>
        <span class="cov1" title="1">if candidateRank &lt; currentRank </span><span class="cov0" title="0">{
                return current
        }</span>
        <span class="cov1" title="1">if filepath.Base(candidate) &lt; filepath.Base(current) </span><span class="cov0" title="0">{
                return candidate
        }</span>
        <span class="cov1" title="1">return current</span>
}

func singleImageExtRank(base, ext string) int <span class="cov8" title="9">{
        ext = strings.ToLower(ext)
        if base == "icon" </span><span class="cov4" title="3">{
                if ext == extPNG </span><span class="cov3" title="2">{
                        return 2
                }</span>
                <span class="cov1" title="1">return 0</span>
        }
        <span class="cov7" title="6">switch ext </span>{
        case extPNG:<span class="cov3" title="2">
                return 2</span>
        case extJPG, extJPEG:<span class="cov6" title="4">
                return 1</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

func compareByExtensionThenName(aBase, bBase string) bool <span class="cov3" title="2">{
        aRank := imageExtRank(filepath.Ext(aBase))
        bRank := imageExtRank(filepath.Ext(bBase))
        if aRank != bRank </span><span class="cov3" title="2">{
                return aRank &gt; bRank
        }</span>
        <span class="cov0" title="0">return aBase &lt; bBase</span>
}

func imageExtRank(ext string) int <span class="cov7" title="6">{
        switch strings.ToLower(ext) </span>{
        case extPNG:<span class="cov4" title="3">
                return 2</span>
        case extJPG, extJPEG:<span class="cov4" title="3">
                return 1</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package fastlane

import (
        "fmt"

        "github.com/dl-alexandre/gpd/internal/migrate"
)

// ValidateLocale validates fastlane metadata for a single locale.
func ValidateLocale(meta *LocaleMetadata) []migrate.ValidationError <span class="cov10" title="4">{
        var errs []migrate.ValidationError

        if meta == nil </span><span class="cov1" title="1">{
                return errs
        }</span>

        <span class="cov8" title="3">if meta.TitleSet </span><span class="cov5" title="2">{
                if err := migrate.ValidateText("title", meta.Title); err != nil </span><span class="cov0" title="0">{
                        err.Locale = meta.Locale
                        errs = append(errs, *err)
                }</span>
        }
        <span class="cov8" title="3">if meta.ShortDescriptionSet </span><span class="cov5" title="2">{
                if err := migrate.ValidateText("shortDescription", meta.ShortDescription); err != nil </span><span class="cov1" title="1">{
                        err.Locale = meta.Locale
                        errs = append(errs, *err)
                }</span>
        }
        <span class="cov8" title="3">if meta.FullDescriptionSet </span><span class="cov5" title="2">{
                if err := migrate.ValidateText("fullDescription", meta.FullDescription); err != nil </span><span class="cov0" title="0">{
                        err.Locale = meta.Locale
                        errs = append(errs, *err)
                }</span>
        }
        <span class="cov8" title="3">for key, text := range meta.Changelogs </span><span class="cov8" title="3">{
                if err := migrate.ValidateText("releaseNotes", text); err != nil </span><span class="cov1" title="1">{
                        err.Locale = meta.Locale
                        err.Message = fmt.Sprintf("release notes %s exceeds limit", key)
                        errs = append(errs, *err)
                }</span>
        }

        <span class="cov8" title="3">return errs</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Package migrate provides shared validation helpers for metadata migrations.
package migrate

import "unicode/utf8"

var limits = map[string]int{
        "title":            30,
        "shortDescription": 80,
        "fullDescription":  4000,
        "releaseNotes":     500,
}

// ValidationError represents a single metadata validation issue.
type ValidationError struct {
        Locale  string `json:"locale"`
        Field   string `json:"field"`
        Message string `json:"message"`
        Current int    `json:"current"`
        Limit   int    `json:"limit"`
}

// ValidateText returns a ValidationError when text exceeds Google Play limits.
func ValidateText(field, text string) *ValidationError <span class="cov10" title="5">{
        limit, ok := limits[field]
        if !ok || text == "" </span><span class="cov4" title="2">{
                return nil
        }</span>
        <span class="cov7" title="3">current := utf8.RuneCountInString(text)
        if current &lt;= limit </span><span class="cov4" title="2">{
                return nil
        }</span>
        <span class="cov1" title="1">return &amp;ValidationError{
                Field:   field,
                Message: "exceeds limit",
                Current: current,
                Limit:   limit,
        }</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">// Package output provides structured output formatting for gpd.
package output

import (
        "encoding/json"
        "fmt"
        "io"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/dl-alexandre/gpd/internal/errors"
)

// Format represents the output format type.
type Format string

const (
        FormatJSON     Format = "json"
        FormatTable    Format = "table"
        FormatMarkdown Format = "markdown"
        FormatCSV      Format = "csv" // Only for analytics/vitals
)

// Metadata contains response metadata.
type Metadata struct {
        // Core fields (always present)
        NoOp       bool     `json:"noop"`
        DurationMs int64    `json:"durationMs"`
        Services   []string `json:"services"`

        // Optional pagination fields
        RequestID     string `json:"requestId,omitempty"`
        PageToken     string `json:"pageToken,omitempty"`
        NextPageToken string `json:"nextPageToken,omitempty"`
        HasMorePages  *bool  `json:"hasMorePages,omitempty"`

        // Optional warning/info fields
        Warnings []string `json:"warnings,omitempty"`

        // Extended fields for specific operations
        Partial          bool       `json:"partial,omitempty"`
        ScannedCount     int        `json:"scannedCount,omitempty"`
        FilteredCount    int        `json:"filteredCount,omitempty"`
        TotalAvailable   int        `json:"totalAvailable,omitempty"`
        Retries          int        `json:"retries,omitempty"`
        DataFreshnessUTC *time.Time `json:"dataFreshnessUtc,omitempty"`
        NoOpReason       string     `json:"noopReason,omitempty"`
}

// Result represents the standard JSON envelope structure.
type Result struct {
        Data     interface{}      `json:"data"`
        Error    *errors.APIError `json:"error"`
        Meta     *Metadata        `json:"meta"`
        ExitCode int              `json:"-"` // Process state only, not in JSON
}

// NewResult creates a successful result with data.
func NewResult(data interface{}) *Result <span class="cov9" title="38">{
        return &amp;Result{
                Data:     data,
                Error:    nil,
                Meta:     &amp;Metadata{Services: []string{}},
                ExitCode: errors.ExitSuccess,
        }
}</span>

// NewErrorResult creates an error result.
func NewErrorResult(err *errors.APIError) *Result <span class="cov5" title="8">{
        return &amp;Result{
                Data:     nil,
                Error:    err,
                Meta:     &amp;Metadata{Services: []string{}},
                ExitCode: err.ExitCode(),
        }
}</span>

// NewEmptyResult creates a result with no data (for operations that don't return data).
func NewEmptyResult() *Result <span class="cov1" title="1">{
        return &amp;Result{
                Data:     nil,
                Error:    nil,
                Meta:     &amp;Metadata{Services: []string{}},
                ExitCode: errors.ExitSuccess,
        }
}</span>

// WithDuration sets the duration metadata.
func (r *Result) WithDuration(d time.Duration) *Result <span class="cov4" title="4">{
        if r.Meta == nil </span><span class="cov1" title="1">{
                r.Meta = &amp;Metadata{}
        }</span>
        <span class="cov4" title="4">r.Meta.DurationMs = d.Milliseconds()
        return r</span>
}

// WithServices sets the services metadata.
func (r *Result) WithServices(services ...string) *Result <span class="cov4" title="5">{
        if r.Meta == nil </span><span class="cov1" title="1">{
                r.Meta = &amp;Metadata{}
        }</span>
        <span class="cov4" title="5">r.Meta.Services = services
        return r</span>
}

// WithNoOp marks the result as a no-op with a reason.
func (r *Result) WithNoOp(reason string) *Result <span class="cov2" title="2">{
        if r.Meta == nil </span><span class="cov1" title="1">{
                r.Meta = &amp;Metadata{}
        }</span>
        <span class="cov2" title="2">r.Meta.NoOp = true
        r.Meta.NoOpReason = reason
        return r</span>
}

// WithPagination sets pagination metadata.
func (r *Result) WithPagination(pageToken, nextPageToken string) *Result <span class="cov3" title="3">{
        if r.Meta == nil </span><span class="cov1" title="1">{
                r.Meta = &amp;Metadata{}
        }</span>
        <span class="cov3" title="3">r.Meta.PageToken = pageToken
        r.Meta.NextPageToken = nextPageToken
        hasMore := nextPageToken != ""
        r.Meta.HasMorePages = &amp;hasMore
        return r</span>
}

// WithWarnings adds warnings to the result.
func (r *Result) WithWarnings(warnings ...string) *Result <span class="cov3" title="3">{
        if r.Meta == nil </span><span class="cov1" title="1">{
                r.Meta = &amp;Metadata{}
        }</span>
        <span class="cov3" title="3">r.Meta.Warnings = append(r.Meta.Warnings, warnings...)
        return r</span>
}

// WithPartial marks the result as partial with scan metadata.
func (r *Result) WithPartial(scanned, filtered, total int) *Result <span class="cov2" title="2">{
        if r.Meta == nil </span><span class="cov1" title="1">{
                r.Meta = &amp;Metadata{}
        }</span>
        <span class="cov2" title="2">r.Meta.Partial = true
        r.Meta.ScannedCount = scanned
        r.Meta.FilteredCount = filtered
        r.Meta.TotalAvailable = total
        return r</span>
}

// WithRetries sets the retry count metadata.
func (r *Result) WithRetries(count int) *Result <span class="cov3" title="3">{
        if r.Meta == nil </span><span class="cov1" title="1">{
                r.Meta = &amp;Metadata{}
        }</span>
        <span class="cov3" title="3">r.Meta.Retries = count
        return r</span>
}

// WithRequestID sets the request ID metadata.
func (r *Result) WithRequestID(id string) *Result <span class="cov2" title="2">{
        if r.Meta == nil </span><span class="cov1" title="1">{
                r.Meta = &amp;Metadata{}
        }</span>
        <span class="cov2" title="2">r.Meta.RequestID = id
        return r</span>
}

// Manager handles output formatting and writing.
type Manager struct {
        format Format
        pretty bool
        fields []string
        writer io.Writer
}

// NewManager creates a new output manager.
func NewManager(w io.Writer) *Manager <span class="cov10" title="47">{
        return &amp;Manager{
                format: FormatJSON,
                pretty: false,
                writer: w,
        }
}</span>

// SetFormat sets the output format.
func (m *Manager) SetFormat(f Format) *Manager <span class="cov9" title="40">{
        m.format = f
        return m
}</span>

// SetPretty enables pretty printing for JSON.
func (m *Manager) SetPretty(pretty bool) *Manager <span class="cov2" title="2">{
        m.pretty = pretty
        return m
}</span>

// SetFields sets field projection paths.
func (m *Manager) SetFields(fields []string) *Manager <span class="cov1" title="1">{
        m.fields = fields
        return m
}</span>

// Write formats and writes the result.
func (m *Manager) Write(r *Result) error <span class="cov8" title="29">{
        switch m.format </span>{
        case FormatJSON:<span class="cov5" title="8">
                return m.writeJSON(r)</span>
        case FormatTable:<span class="cov5" title="7">
                return m.writeTable(r)</span>
        case FormatMarkdown:<span class="cov5" title="7">
                return m.writeMarkdown(r)</span>
        case FormatCSV:<span class="cov5" title="6">
                return m.writeCSV(r)</span>
        default:<span class="cov1" title="1">
                return m.writeJSON(r)</span>
        }
}

func (m *Manager) writeJSON(r *Result) error <span class="cov7" title="17">{
        var data []byte
        var err error

        // Apply field projection if specified
        output := m.applyFieldProjection(r)

        if m.pretty </span><span class="cov2" title="2">{
                data, err = json.MarshalIndent(output, "", "  ")
        }</span> else<span class="cov7" title="15"> {
                data, err = json.Marshal(output)
        }</span>
        <span class="cov7" title="17">if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov7" title="16">_, err = fmt.Fprintln(m.writer, string(data))
        return err</span>
}

func (m *Manager) writeTable(r *Result) error <span class="cov5" title="7">{
        if r.Error != nil </span><span class="cov1" title="1">{
                return m.writeJSON(r) // Errors always as JSON
        }</span>

        // Convert data to table format
        <span class="cov5" title="6">data := r.Data
        if data == nil </span><span class="cov1" title="1">{
                return m.writeWarnings(r)
        }</span>

        // Handle slice data
        <span class="cov4" title="5">switch v := data.(type) </span>{
        case []interface{}:<span class="cov3" title="3">
                if err := m.writeTableSlice(v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov3" title="3">return m.writeWarnings(r)</span>
        case []map[string]interface{}:<span class="cov0" title="0">
                if err := m.writeTableSlice(m.mapSliceToInterface(v)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return m.writeWarnings(r)</span>
        case map[string]interface{}:<span class="cov1" title="1">
                if err := m.writeTableMap(v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">return m.writeWarnings(r)</span>
        default:<span class="cov1" title="1">
                // Fall back to JSON for complex types
                return m.writeJSON(r)</span>
        }
}

func (m *Manager) writeTableSlice(data []interface{}) error <span class="cov5" title="7">{
        if len(data) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Get headers from first item
        <span class="cov5" title="6">first, ok := data[0].(map[string]interface{})
        if !ok </span><span class="cov1" title="1">{
                return m.writeJSON(&amp;Result{Data: data})
        }</span>

        <span class="cov4" title="5">var headers []string
        for k := range first </span><span class="cov5" title="6">{
                headers = append(headers, k)
        }</span>

        // Write headers
        <span class="cov4" title="5">if _, err := fmt.Fprintln(m.writer, strings.Join(headers, "\t")); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov4" title="4">if _, err := fmt.Fprintln(m.writer, strings.Repeat("-", len(strings.Join(headers, "\t")))); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Write rows
        <span class="cov3" title="3">for _, item := range data </span><span class="cov4" title="5">{
                row, ok := item.(map[string]interface{})
                if !ok </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov4" title="4">var values []string
                for _, h := range headers </span><span class="cov5" title="6">{
                        values = append(values, fmt.Sprintf("%v", row[h]))
                }</span>
                <span class="cov4" title="4">if _, err := fmt.Fprintln(m.writer, strings.Join(values, "\t")); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }

        <span class="cov2" title="2">return nil</span>
}

func (m *Manager) writeTableMap(data map[string]interface{}) error <span class="cov2" title="2">{
        for k, v := range data </span><span class="cov3" title="3">{
                if _, err := fmt.Fprintf(m.writer, "%s:\t%v\n", k, v); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

func (m *Manager) writeMarkdown(r *Result) error <span class="cov6" title="9">{
        if r.Error != nil </span><span class="cov4" title="4">{
                if _, err := fmt.Fprintf(m.writer, "## Error\n\n**Code:** %s\n\n**Message:** %s\n", r.Error.Code, r.Error.Message); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov3" title="3">if r.Error.Hint != "" </span><span class="cov2" title="2">{
                        if _, err := fmt.Fprintf(m.writer, "\n**Hint:** %s\n", r.Error.Hint); err != nil </span><span class="cov1" title="1">{
                                return err
                        }</span>
                }
                <span class="cov2" title="2">return nil</span>
        }

        <span class="cov4" title="5">data := r.Data
        if data == nil </span><span class="cov1" title="1">{
                return m.writeWarnings(r)
        }</span>

        <span class="cov4" title="4">switch v := data.(type) </span>{
        case []interface{}:<span class="cov2" title="2">
                if err := m.writeMarkdownTable(v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov2" title="2">return m.writeWarnings(r)</span>
        case []map[string]interface{}:<span class="cov0" title="0">
                if err := m.writeMarkdownTable(m.mapSliceToInterface(v)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return m.writeWarnings(r)</span>
        case map[string]interface{}:<span class="cov1" title="1">
                if err := m.writeMarkdownMap(v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">return m.writeWarnings(r)</span>
        default:<span class="cov1" title="1">
                return m.writeJSON(r)</span>
        }
}

func (m *Manager) writeMarkdownTable(data []interface{}) error <span class="cov5" title="8">{
        if len(data) == 0 </span><span class="cov2" title="2">{
                if _, err := fmt.Fprintln(m.writer, "*No data*"); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov1" title="1">return nil</span>
        }

        <span class="cov5" title="6">first, ok := data[0].(map[string]interface{})
        if !ok </span><span class="cov1" title="1">{
                return m.writeJSON(&amp;Result{Data: data})
        }</span>

        <span class="cov4" title="5">var headers []string
        for k := range first </span><span class="cov5" title="6">{
                headers = append(headers, k)
        }</span>

        // Write headers
        <span class="cov4" title="5">if _, err := fmt.Fprintf(m.writer, "| %s |\n", strings.Join(headers, " | ")); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov4" title="4">var sep []string
        for range headers </span><span class="cov4" title="5">{
                sep = append(sep, "---")
        }</span>
        <span class="cov4" title="4">if _, err := fmt.Fprintf(m.writer, "| %s |\n", strings.Join(sep, " | ")); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Write rows
        <span class="cov3" title="3">for _, item := range data </span><span class="cov4" title="5">{
                row, ok := item.(map[string]interface{})
                if !ok </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov4" title="4">var values []string
                for _, h := range headers </span><span class="cov5" title="6">{
                        values = append(values, fmt.Sprintf("%v", row[h]))
                }</span>
                <span class="cov4" title="4">if _, err := fmt.Fprintf(m.writer, "| %s |\n", strings.Join(values, " | ")); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }

        <span class="cov2" title="2">return nil</span>
}

func (m *Manager) writeMarkdownMap(data map[string]interface{}) error <span class="cov2" title="2">{
        for k, v := range data </span><span class="cov2" title="2">{
                if _, err := fmt.Fprintf(m.writer, "- **%s:** %v\n", k, v); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

func (m *Manager) writeCSV(r *Result) error <span class="cov6" title="10">{
        if r.Error != nil </span><span class="cov1" title="1">{
                return m.writeJSON(r)
        }</span>

        <span class="cov6" title="9">data := r.Data
        if data == nil </span><span class="cov1" title="1">{
                return m.writeWarnings(r)
        }</span>

        <span class="cov5" title="8">slice, ok := data.([]interface{})
        if !ok </span><span class="cov1" title="1">{
                if mapSlice, ok := data.([]map[string]interface{}); ok </span><span class="cov0" title="0">{
                        slice = m.mapSliceToInterface(mapSlice)
                }</span> else<span class="cov1" title="1"> {
                        return m.writeJSON(r)
                }</span>
        }

        <span class="cov5" title="7">if len(slice) == 0 </span><span class="cov1" title="1">{
                return m.writeWarnings(r)
        }</span>

        <span class="cov5" title="6">first, ok := slice[0].(map[string]interface{})
        if !ok </span><span class="cov1" title="1">{
                return m.writeJSON(r)
        }</span>

        <span class="cov4" title="5">var headers []string
        for k := range first </span><span class="cov5" title="7">{
                headers = append(headers, k)
        }</span>

        // Write CSV header
        <span class="cov4" title="5">if _, err := fmt.Fprintln(m.writer, strings.Join(headers, ",")); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Write rows
        <span class="cov4" title="4">for _, item := range slice </span><span class="cov5" title="6">{
                row, ok := item.(map[string]interface{})
                if !ok </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov4" title="5">var values []string
                for _, h := range headers </span><span class="cov5" title="8">{
                        val := fmt.Sprintf("%v", row[h])
                        // Escape CSV values
                        if strings.Contains(val, ",") || strings.Contains(val, "\"") || strings.Contains(val, "\n") </span><span class="cov2" title="2">{
                                val = "\"" + strings.ReplaceAll(val, "\"", "\"\"") + "\""
                        }</span>
                        <span class="cov5" title="8">values = append(values, val)</span>
                }
                <span class="cov4" title="5">if _, err := fmt.Fprintln(m.writer, strings.Join(values, ",")); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }

        <span class="cov3" title="3">return m.writeWarnings(r)</span>
}

func (m *Manager) mapSliceToInterface(data []map[string]interface{}) []interface{} <span class="cov0" title="0">{
        slice := make([]interface{}, 0, len(data))
        for _, item := range data </span><span class="cov0" title="0">{
                slice = append(slice, item)
        }</span>
        <span class="cov0" title="0">return slice</span>
}

// applyFieldProjection applies --fields projection to the result.
func (m *Manager) applyFieldProjection(r *Result) interface{} <span class="cov7" title="17">{
        if len(m.fields) == 0 </span><span class="cov7" title="16">{
                return r
        }</span>

        <span class="cov1" title="1">raw, err := resultToMap(r)
        if err != nil </span><span class="cov0" title="0">{
                return r
        }</span>

        <span class="cov1" title="1">projected := make(map[string]interface{})
        for _, field := range m.fields </span><span class="cov1" title="1">{
                field = strings.TrimSpace(field)
                if field == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">parts := strings.Split(field, ".")
                value, ok := getPathValue(raw, parts)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov1" title="1">updated := setPathValueAny(projected, parts, value)
                next, ok := updated.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return projected
                }</span>
                <span class="cov1" title="1">projected = next</span>
        }
        <span class="cov1" title="1">return projected</span>
}

func resultToMap(r *Result) (map[string]interface{}, error) <span class="cov1" title="1">{
        data, err := json.Marshal(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">var raw map[string]interface{}
        if err := json.Unmarshal(data, &amp;raw); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return raw, nil</span>
}

func getPathValue(value interface{}, parts []string) (interface{}, bool) <span class="cov1" title="1">{
        current := value
        for _, part := range parts </span><span class="cov2" title="2">{
                switch typed := current.(type) </span>{
                case map[string]interface{}:<span class="cov2" title="2">
                        next, ok := typed[part]
                        if !ok </span><span class="cov0" title="0">{
                                return nil, false
                        }</span>
                        <span class="cov2" title="2">current = next</span>
                case []interface{}:<span class="cov0" title="0">
                        index, err := strconv.Atoi(part)
                        if err != nil || index &lt; 0 || index &gt;= len(typed) </span><span class="cov0" title="0">{
                                return nil, false
                        }</span>
                        <span class="cov0" title="0">current = typed[index]</span>
                default:<span class="cov0" title="0">
                        return nil, false</span>
                }
        }
        <span class="cov1" title="1">return current, true</span>
}

func setPathValueAny(container interface{}, parts []string, value interface{}) interface{} <span class="cov2" title="2">{
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return container
        }</span>
        <span class="cov2" title="2">part := parts[0]
        if index, err := strconv.Atoi(part); err == nil </span><span class="cov0" title="0">{
                var slice []interface{}
                switch typed := container.(type) </span>{
                case []interface{}:<span class="cov0" title="0">
                        slice = typed</span>
                case nil:<span class="cov0" title="0">
                        slice = []interface{}{}</span>
                default:<span class="cov0" title="0">
                        return container</span>
                }
                <span class="cov0" title="0">if index &lt; 0 </span><span class="cov0" title="0">{
                        return slice
                }</span>
                <span class="cov0" title="0">if index &gt;= len(slice) </span><span class="cov0" title="0">{
                        extended := make([]interface{}, index+1)
                        copy(extended, slice)
                        slice = extended
                }</span>
                <span class="cov0" title="0">if len(parts) == 1 </span><span class="cov0" title="0">{
                        slice[index] = value
                        return slice
                }</span>
                <span class="cov0" title="0">slice[index] = setPathValueAny(slice[index], parts[1:], value)
                return slice</span>
        }

        <span class="cov2" title="2">var m map[string]interface{}
        switch typed := container.(type) </span>{
        case map[string]interface{}:<span class="cov1" title="1">
                m = typed</span>
        case nil:<span class="cov1" title="1">
                m = make(map[string]interface{})</span>
        default:<span class="cov0" title="0">
                return container</span>
        }
        <span class="cov2" title="2">if len(parts) == 1 </span><span class="cov1" title="1">{
                m[part] = value
                return m
        }</span>
        <span class="cov1" title="1">m[part] = setPathValueAny(m[part], parts[1:], value)
        return m</span>
}

func (m *Manager) writeWarnings(r *Result) error <span class="cov7" title="14">{
        if r.Meta == nil || len(r.Meta.Warnings) == 0 </span><span class="cov7" title="14">{
                return nil
        }</span>
        <span class="cov0" title="0">switch m.format </span>{
        case FormatMarkdown:<span class="cov0" title="0">
                if _, err := fmt.Fprintln(m.writer, "\n## Warnings"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for _, warning := range r.Meta.Warnings </span><span class="cov0" title="0">{
                        if _, err := fmt.Fprintf(m.writer, "- %s\n", warning); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        case FormatCSV:<span class="cov0" title="0">
                for _, warning := range r.Meta.Warnings </span><span class="cov0" title="0">{
                        if _, err := fmt.Fprintf(os.Stderr, "warning: %s\n", warning); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        default:<span class="cov0" title="0">
                if _, err := fmt.Fprintln(m.writer, "\nWarnings:"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for _, warning := range r.Meta.Warnings </span><span class="cov0" title="0">{
                        if _, err := fmt.Fprintf(m.writer, "- %s\n", warning); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }
}

// ParseFormat parses a format string into a Format type.
func ParseFormat(s string) Format <span class="cov6" title="9">{
        switch strings.ToLower(s) </span>{
        case "json":<span class="cov2" title="2">
                return FormatJSON</span>
        case "table":<span class="cov2" title="2">
                return FormatTable</span>
        case "markdown", "md":<span class="cov2" title="2">
                return FormatMarkdown</span>
        case "csv":<span class="cov1" title="1">
                return FormatCSV</span>
        default:<span class="cov2" title="2">
                return FormatJSON</span>
        }
}
</pre>
		
		<pre class="file" id="file51" style="display: none">// Package storage provides platform-specific secure credential storage.
package storage

import (
        "runtime"

        "github.com/99designs/keyring"
)

const (
        serviceName = "gpd"
)

// SecureStorage provides secure credential storage using the system keychain.
type SecureStorage struct {
        ring      keyring.Keyring
        available bool
}

// New creates a new SecureStorage instance.
func New() *SecureStorage <span class="cov5" title="2">{
        ring, err := openKeyring(keyring.Config{
                ServiceName: serviceName,
                // macOS specific
                KeychainName:                   "gpd",
                KeychainTrustApplication:       true,
                KeychainSynchronizable:         false,
                KeychainAccessibleWhenUnlocked: true,
                // Linux specific - prefer Secret Service
                LibSecretCollectionName: "gpd",
                // Windows specific
                WinCredPrefix: "gpd",
                // Disable file-based fallback for security
                FileDir:          "",
                FilePasswordFunc: nil,
        })

        if err != nil </span><span class="cov1" title="1">{
                return &amp;SecureStorage{available: false}
        }</span>

        <span class="cov1" title="1">return NewWithKeyring(ring)</span>
}

var openKeyring = keyring.Open

func NewWithKeyring(ring keyring.Keyring) *SecureStorage <span class="cov10" title="4">{
        if ring == nil </span><span class="cov1" title="1">{
                return &amp;SecureStorage{available: false}
        }</span>
        <span class="cov8" title="3">return &amp;SecureStorage{
                ring:      ring,
                available: true,
        }</span>
}

// Store stores a value securely.
func (s *SecureStorage) Store(key string, value []byte) error <span class="cov5" title="2">{
        if !s.available </span><span class="cov1" title="1">{
                return ErrStorageUnavailable
        }</span>
        <span class="cov1" title="1">return s.ring.Set(keyring.Item{
                Key:  key,
                Data: value,
        })</span>
}

// Retrieve retrieves a value from secure storage.
func (s *SecureStorage) Retrieve(key string) ([]byte, error) <span class="cov10" title="4">{
        if !s.available </span><span class="cov1" title="1">{
                return nil, ErrStorageUnavailable
        }</span>
        <span class="cov8" title="3">item, err := s.ring.Get(key)
        if err != nil </span><span class="cov5" title="2">{
                if err == keyring.ErrKeyNotFound </span><span class="cov1" title="1">{
                        return nil, ErrKeyNotFound
                }</span>
                <span class="cov1" title="1">return nil, err</span>
        }
        <span class="cov1" title="1">return item.Data, nil</span>
}

// Delete removes a value from secure storage.
func (s *SecureStorage) Delete(key string) error <span class="cov5" title="2">{
        if !s.available </span><span class="cov1" title="1">{
                return ErrStorageUnavailable
        }</span>
        <span class="cov1" title="1">return s.ring.Remove(key)</span>
}

// Available returns whether secure storage is available.
func (s *SecureStorage) Available() bool <span class="cov5" title="2">{
        return s.available
}</span>

// Platform returns the current platform name.
func Platform() string <span class="cov1" title="1">{
        return runtime.GOOS
}</span>

// Error represents storage operation errors.
type Error struct {
        message string
}

func (e *Error) Error() string <span class="cov5" title="2">{
        return e.message
}</span>

var (
        ErrStorageUnavailable = &amp;Error{"secure storage not available on this platform"}
        ErrKeyNotFound        = &amp;Error{"key not found in secure storage"}
)
</pre>
		
		<pre class="file" id="file52" style="display: none">// Package version provides build version information for gpd.
package version

import (
        "fmt"
        "runtime"
)

// Build information set by ldflags during compilation.
var (
        Version   = "dev"
        GitCommit = "unknown"
        BuildTime = "unknown"
)

// Info contains version information.
type Info struct {
        Version   string `json:"version"`
        GitCommit string `json:"gitCommit"`
        BuildTime string `json:"buildTime"`
        GoVersion string `json:"goVersion"`
        Platform  string `json:"platform"`
}

// Get returns the current version information.
func Get() *Info <span class="cov8" title="1">{
        return &amp;Info{
                Version:   Version,
                GitCommit: GitCommit,
                BuildTime: BuildTime,
                GoVersion: runtime.Version(),
                Platform:  fmt.Sprintf("%s/%s", runtime.GOOS, runtime.GOARCH),
        }
}</span>

// String returns a human-readable version string.
func (i *Info) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("gpd %s (%s) built %s", i.Version, i.GitCommit, i.BuildTime)
}</span>

// Short returns a short version string.
func (i *Info) Short() string <span class="cov8" title="1">{
        return i.Version
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
